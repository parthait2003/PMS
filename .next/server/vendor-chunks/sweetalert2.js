"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sweetalert2";
exports.ids = ["vendor-chunks/sweetalert2"];
exports.modules = {

/***/ "(ssr)/./node_modules/sweetalert2/dist/sweetalert2.esm.all.js":
/*!**************************************************************!*\
  !*** ./node_modules/sweetalert2/dist/sweetalert2.esm.all.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Swal)\n/* harmony export */ });\n/*!\n* sweetalert2 v11.17.2\n* Released under the MIT License.\n*/ function _assertClassBrand(e, t, n) {\n    if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n    throw new TypeError(\"Private element is not present on this object\");\n}\nfunction _checkPrivateRedeclaration(e, t) {\n    if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet2(s, a) {\n    return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n    _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _classPrivateFieldSet2(s, a, r) {\n    return s.set(_assertClassBrand(s, a), r), r;\n}\nconst RESTORE_FOCUS_TIMEOUT = 100;\n/** @type {GlobalState} */ const globalState = {};\nconst focusPreviousActiveElement = ()=>{\n    if (globalState.previousActiveElement instanceof HTMLElement) {\n        globalState.previousActiveElement.focus();\n        globalState.previousActiveElement = null;\n    } else if (document.body) {\n        document.body.focus();\n    }\n};\n/**\n * Restore previous active (focused) element\n *\n * @param {boolean} returnFocus\n * @returns {Promise<void>}\n */ const restoreActiveElement = (returnFocus)=>{\n    return new Promise((resolve)=>{\n        if (!returnFocus) {\n            return resolve();\n        }\n        const x = window.scrollX;\n        const y = window.scrollY;\n        globalState.restoreFocusTimeout = setTimeout(()=>{\n            focusPreviousActiveElement();\n            resolve();\n        }, RESTORE_FOCUS_TIMEOUT); // issues/900\n        window.scrollTo(x, y);\n    });\n};\nconst swalPrefix = \"swal2-\";\n/**\n * @typedef {Record<SwalClass, string>} SwalClasses\n */ /**\n * @typedef {'success' | 'warning' | 'info' | 'question' | 'error'} SwalIcon\n * @typedef {Record<SwalIcon, string>} SwalIcons\n */ /** @type {SwalClass[]} */ const classNames = [\n    \"container\",\n    \"shown\",\n    \"height-auto\",\n    \"iosfix\",\n    \"popup\",\n    \"modal\",\n    \"no-backdrop\",\n    \"no-transition\",\n    \"toast\",\n    \"toast-shown\",\n    \"show\",\n    \"hide\",\n    \"close\",\n    \"title\",\n    \"html-container\",\n    \"actions\",\n    \"confirm\",\n    \"deny\",\n    \"cancel\",\n    \"default-outline\",\n    \"footer\",\n    \"icon\",\n    \"icon-content\",\n    \"image\",\n    \"input\",\n    \"file\",\n    \"range\",\n    \"select\",\n    \"radio\",\n    \"checkbox\",\n    \"label\",\n    \"textarea\",\n    \"inputerror\",\n    \"input-label\",\n    \"validation-message\",\n    \"progress-steps\",\n    \"active-progress-step\",\n    \"progress-step\",\n    \"progress-step-line\",\n    \"loader\",\n    \"loading\",\n    \"styled\",\n    \"top\",\n    \"top-start\",\n    \"top-end\",\n    \"top-left\",\n    \"top-right\",\n    \"center\",\n    \"center-start\",\n    \"center-end\",\n    \"center-left\",\n    \"center-right\",\n    \"bottom\",\n    \"bottom-start\",\n    \"bottom-end\",\n    \"bottom-left\",\n    \"bottom-right\",\n    \"grow-row\",\n    \"grow-column\",\n    \"grow-fullscreen\",\n    \"rtl\",\n    \"timer-progress-bar\",\n    \"timer-progress-bar-container\",\n    \"scrollbar-measure\",\n    \"icon-success\",\n    \"icon-warning\",\n    \"icon-info\",\n    \"icon-question\",\n    \"icon-error\",\n    \"draggable\",\n    \"dragging\"\n];\nconst swalClasses = classNames.reduce((acc, className)=>{\n    acc[className] = swalPrefix + className;\n    return acc;\n}, /** @type {SwalClasses} */ {});\n/** @type {SwalIcon[]} */ const icons = [\n    \"success\",\n    \"warning\",\n    \"info\",\n    \"question\",\n    \"error\"\n];\nconst iconTypes = icons.reduce((acc, icon)=>{\n    acc[icon] = swalPrefix + icon;\n    return acc;\n}, /** @type {SwalIcons} */ {});\nconst consolePrefix = \"SweetAlert2:\";\n/**\n * Capitalize the first letter of a string\n *\n * @param {string} str\n * @returns {string}\n */ const capitalizeFirstLetter = (str)=>str.charAt(0).toUpperCase() + str.slice(1);\n/**\n * Standardize console warnings\n *\n * @param {string | string[]} message\n */ const warn = (message)=>{\n    console.warn(`${consolePrefix} ${typeof message === \"object\" ? message.join(\" \") : message}`);\n};\n/**\n * Standardize console errors\n *\n * @param {string} message\n */ const error = (message)=>{\n    console.error(`${consolePrefix} ${message}`);\n};\n/**\n * Private global state for `warnOnce`\n *\n * @type {string[]}\n * @private\n */ const previousWarnOnceMessages = [];\n/**\n * Show a console warning, but only if it hasn't already been shown\n *\n * @param {string} message\n */ const warnOnce = (message)=>{\n    if (!previousWarnOnceMessages.includes(message)) {\n        previousWarnOnceMessages.push(message);\n        warn(message);\n    }\n};\n/**\n * Show a one-time console warning about deprecated params/methods\n *\n * @param {string} deprecatedParam\n * @param {string?} useInstead\n */ const warnAboutDeprecation = function(deprecatedParam) {\n    let useInstead = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    warnOnce(`\"${deprecatedParam}\" is deprecated and will be removed in the next major release.${useInstead ? ` Use \"${useInstead}\" instead.` : \"\"}`);\n};\n/**\n * If `arg` is a function, call it (with no arguments or context) and return the result.\n * Otherwise, just pass the value through\n *\n * @param {Function | any} arg\n * @returns {any}\n */ const callIfFunction = (arg)=>typeof arg === \"function\" ? arg() : arg;\n/**\n * @param {any} arg\n * @returns {boolean}\n */ const hasToPromiseFn = (arg)=>arg && typeof arg.toPromise === \"function\";\n/**\n * @param {any} arg\n * @returns {Promise<any>}\n */ const asPromise = (arg)=>hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);\n/**\n * @param {any} arg\n * @returns {boolean}\n */ const isPromise = (arg)=>arg && Promise.resolve(arg) === arg;\n/**\n * Gets the popup container which contains the backdrop and the popup itself.\n *\n * @returns {HTMLElement | null}\n */ const getContainer = ()=>document.body.querySelector(`.${swalClasses.container}`);\n/**\n * @param {string} selectorString\n * @returns {HTMLElement | null}\n */ const elementBySelector = (selectorString)=>{\n    const container = getContainer();\n    return container ? container.querySelector(selectorString) : null;\n};\n/**\n * @param {string} className\n * @returns {HTMLElement | null}\n */ const elementByClass = (className)=>{\n    return elementBySelector(`.${className}`);\n};\n/**\n * @returns {HTMLElement | null}\n */ const getPopup = ()=>elementByClass(swalClasses.popup);\n/**\n * @returns {HTMLElement | null}\n */ const getIcon = ()=>elementByClass(swalClasses.icon);\n/**\n * @returns {HTMLElement | null}\n */ const getIconContent = ()=>elementByClass(swalClasses[\"icon-content\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getTitle = ()=>elementByClass(swalClasses.title);\n/**\n * @returns {HTMLElement | null}\n */ const getHtmlContainer = ()=>elementByClass(swalClasses[\"html-container\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getImage = ()=>elementByClass(swalClasses.image);\n/**\n * @returns {HTMLElement | null}\n */ const getProgressSteps = ()=>elementByClass(swalClasses[\"progress-steps\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getValidationMessage = ()=>elementByClass(swalClasses[\"validation-message\"]);\n/**\n * @returns {HTMLButtonElement | null}\n */ const getConfirmButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`);\n/**\n * @returns {HTMLButtonElement | null}\n */ const getCancelButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`);\n/**\n * @returns {HTMLButtonElement | null}\n */ const getDenyButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`);\n/**\n * @returns {HTMLElement | null}\n */ const getInputLabel = ()=>elementByClass(swalClasses[\"input-label\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getLoader = ()=>elementBySelector(`.${swalClasses.loader}`);\n/**\n * @returns {HTMLElement | null}\n */ const getActions = ()=>elementByClass(swalClasses.actions);\n/**\n * @returns {HTMLElement | null}\n */ const getFooter = ()=>elementByClass(swalClasses.footer);\n/**\n * @returns {HTMLElement | null}\n */ const getTimerProgressBar = ()=>elementByClass(swalClasses[\"timer-progress-bar\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getCloseButton = ()=>elementByClass(swalClasses.close);\n// https://github.com/jkup/focusable/blob/master/index.js\nconst focusable = `\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex=\"0\"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n`;\n/**\n * @returns {HTMLElement[]}\n */ const getFocusableElements = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return [];\n    }\n    /** @type {NodeListOf<HTMLElement>} */ const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex=\"-1\"]):not([tabindex=\"0\"])');\n    const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex)// sort according to tabindex\n    .sort((a, b)=>{\n        const tabindexA = parseInt(a.getAttribute(\"tabindex\") || \"0\");\n        const tabindexB = parseInt(b.getAttribute(\"tabindex\") || \"0\");\n        if (tabindexA > tabindexB) {\n            return 1;\n        } else if (tabindexA < tabindexB) {\n            return -1;\n        }\n        return 0;\n    });\n    /** @type {NodeListOf<HTMLElement>} */ const otherFocusableElements = popup.querySelectorAll(focusable);\n    const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter((el)=>el.getAttribute(\"tabindex\") !== \"-1\");\n    return [\n        ...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))\n    ].filter((el)=>isVisible$1(el));\n};\n/**\n * @returns {boolean}\n */ const isModal = ()=>{\n    return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses[\"toast-shown\"]) && !hasClass(document.body, swalClasses[\"no-backdrop\"]);\n};\n/**\n * @returns {boolean}\n */ const isToast = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return false;\n    }\n    return hasClass(popup, swalClasses.toast);\n};\n/**\n * @returns {boolean}\n */ const isLoading = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return false;\n    }\n    return popup.hasAttribute(\"data-loading\");\n};\n/**\n * Securely set innerHTML of an element\n * https://github.com/sweetalert2/sweetalert2/issues/1926\n *\n * @param {HTMLElement} elem\n * @param {string} html\n */ const setInnerHtml = (elem, html)=>{\n    elem.textContent = \"\";\n    if (html) {\n        const parser = new DOMParser();\n        const parsed = parser.parseFromString(html, `text/html`);\n        const head = parsed.querySelector(\"head\");\n        if (head) {\n            Array.from(head.childNodes).forEach((child)=>{\n                elem.appendChild(child);\n            });\n        }\n        const body = parsed.querySelector(\"body\");\n        if (body) {\n            Array.from(body.childNodes).forEach((child)=>{\n                if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {\n                    elem.appendChild(child.cloneNode(true)); // https://github.com/sweetalert2/sweetalert2/issues/2507\n                } else {\n                    elem.appendChild(child);\n                }\n            });\n        }\n    }\n};\n/**\n * @param {HTMLElement} elem\n * @param {string} className\n * @returns {boolean}\n */ const hasClass = (elem, className)=>{\n    if (!className) {\n        return false;\n    }\n    const classList = className.split(/\\s+/);\n    for(let i = 0; i < classList.length; i++){\n        if (!elem.classList.contains(classList[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param {HTMLElement} elem\n * @param {SweetAlertOptions} params\n */ const removeCustomClasses = (elem, params)=>{\n    Array.from(elem.classList).forEach((className)=>{\n        if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {\n            elem.classList.remove(className);\n        }\n    });\n};\n/**\n * @param {HTMLElement} elem\n * @param {SweetAlertOptions} params\n * @param {string} className\n */ const applyCustomClass = (elem, params, className)=>{\n    removeCustomClasses(elem, params);\n    if (!params.customClass) {\n        return;\n    }\n    const customClass = params.customClass[/** @type {keyof SweetAlertCustomClass} */ className];\n    if (!customClass) {\n        return;\n    }\n    if (typeof customClass !== \"string\" && !customClass.forEach) {\n        warn(`Invalid type of customClass.${className}! Expected string or iterable object, got \"${typeof customClass}\"`);\n        return;\n    }\n    addClass(elem, customClass);\n};\n/**\n * @param {HTMLElement} popup\n * @param {import('./renderers/renderInput').InputClass | SweetAlertInput} inputClass\n * @returns {HTMLInputElement | null}\n */ const getInput$1 = (popup, inputClass)=>{\n    if (!inputClass) {\n        return null;\n    }\n    switch(inputClass){\n        case \"select\":\n        case \"textarea\":\n        case \"file\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);\n        case \"checkbox\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);\n        case \"radio\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);\n        case \"range\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);\n        default:\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);\n    }\n};\n/**\n * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input\n */ const focusInput = (input)=>{\n    input.focus();\n    // place cursor at end of text in text input\n    if (input.type !== \"file\") {\n        // http://stackoverflow.com/a/2345915\n        const val = input.value;\n        input.value = \"\";\n        input.value = val;\n    }\n};\n/**\n * @param {HTMLElement | HTMLElement[] | null} target\n * @param {string | string[] | readonly string[] | undefined} classList\n * @param {boolean} condition\n */ const toggleClass = (target, classList, condition)=>{\n    if (!target || !classList) {\n        return;\n    }\n    if (typeof classList === \"string\") {\n        classList = classList.split(/\\s+/).filter(Boolean);\n    }\n    classList.forEach((className)=>{\n        if (Array.isArray(target)) {\n            target.forEach((elem)=>{\n                if (condition) {\n                    elem.classList.add(className);\n                } else {\n                    elem.classList.remove(className);\n                }\n            });\n        } else {\n            if (condition) {\n                target.classList.add(className);\n            } else {\n                target.classList.remove(className);\n            }\n        }\n    });\n};\n/**\n * @param {HTMLElement | HTMLElement[] | null} target\n * @param {string | string[] | readonly string[] | undefined} classList\n */ const addClass = (target, classList)=>{\n    toggleClass(target, classList, true);\n};\n/**\n * @param {HTMLElement | HTMLElement[] | null} target\n * @param {string | string[] | readonly string[] | undefined} classList\n */ const removeClass = (target, classList)=>{\n    toggleClass(target, classList, false);\n};\n/**\n * Get direct child of an element by class name\n *\n * @param {HTMLElement} elem\n * @param {string} className\n * @returns {HTMLElement | undefined}\n */ const getDirectChildByClass = (elem, className)=>{\n    const children = Array.from(elem.children);\n    for(let i = 0; i < children.length; i++){\n        const child = children[i];\n        if (child instanceof HTMLElement && hasClass(child, className)) {\n            return child;\n        }\n    }\n};\n/**\n * @param {HTMLElement} elem\n * @param {string} property\n * @param {*} value\n */ const applyNumericalStyle = (elem, property, value)=>{\n    if (value === `${parseInt(value)}`) {\n        value = parseInt(value);\n    }\n    if (value || parseInt(value) === 0) {\n        elem.style.setProperty(property, typeof value === \"number\" ? `${value}px` : value);\n    } else {\n        elem.style.removeProperty(property);\n    }\n};\n/**\n * @param {HTMLElement | null} elem\n * @param {string} display\n */ const show = function(elem) {\n    let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"flex\";\n    if (!elem) {\n        return;\n    }\n    elem.style.display = display;\n};\n/**\n * @param {HTMLElement | null} elem\n */ const hide = (elem)=>{\n    if (!elem) {\n        return;\n    }\n    elem.style.display = \"none\";\n};\n/**\n * @param {HTMLElement | null} elem\n * @param {string} display\n */ const showWhenInnerHtmlPresent = function(elem) {\n    let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"block\";\n    if (!elem) {\n        return;\n    }\n    new MutationObserver(()=>{\n        toggle(elem, elem.innerHTML, display);\n    }).observe(elem, {\n        childList: true,\n        subtree: true\n    });\n};\n/**\n * @param {HTMLElement} parent\n * @param {string} selector\n * @param {string} property\n * @param {string} value\n */ const setStyle = (parent, selector, property, value)=>{\n    /** @type {HTMLElement | null} */ const el = parent.querySelector(selector);\n    if (el) {\n        el.style.setProperty(property, value);\n    }\n};\n/**\n * @param {HTMLElement} elem\n * @param {any} condition\n * @param {string} display\n */ const toggle = function(elem, condition) {\n    let display = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"flex\";\n    if (condition) {\n        show(elem, display);\n    } else {\n        hide(elem);\n    }\n};\n/**\n * borrowed from jquery $(elem).is(':visible') implementation\n *\n * @param {HTMLElement | null} elem\n * @returns {boolean}\n */ const isVisible$1 = (elem)=>!!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));\n/**\n * @returns {boolean}\n */ const allButtonsAreHidden = ()=>!isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());\n/**\n * @param {HTMLElement} elem\n * @returns {boolean}\n */ const isScrollable = (elem)=>!!(elem.scrollHeight > elem.clientHeight);\n/**\n * borrowed from https://stackoverflow.com/a/46352119\n *\n * @param {HTMLElement} elem\n * @returns {boolean}\n */ const hasCssAnimation = (elem)=>{\n    const style = window.getComputedStyle(elem);\n    const animDuration = parseFloat(style.getPropertyValue(\"animation-duration\") || \"0\");\n    const transDuration = parseFloat(style.getPropertyValue(\"transition-duration\") || \"0\");\n    return animDuration > 0 || transDuration > 0;\n};\n/**\n * @param {number} timer\n * @param {boolean} reset\n */ const animateTimerProgressBar = function(timer) {\n    let reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const timerProgressBar = getTimerProgressBar();\n    if (!timerProgressBar) {\n        return;\n    }\n    if (isVisible$1(timerProgressBar)) {\n        if (reset) {\n            timerProgressBar.style.transition = \"none\";\n            timerProgressBar.style.width = \"100%\";\n        }\n        setTimeout(()=>{\n            timerProgressBar.style.transition = `width ${timer / 1000}s linear`;\n            timerProgressBar.style.width = \"0%\";\n        }, 10);\n    }\n};\nconst stopTimerProgressBar = ()=>{\n    const timerProgressBar = getTimerProgressBar();\n    if (!timerProgressBar) {\n        return;\n    }\n    const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n    timerProgressBar.style.removeProperty(\"transition\");\n    timerProgressBar.style.width = \"100%\";\n    const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n    const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;\n    timerProgressBar.style.width = `${timerProgressBarPercent}%`;\n};\n/**\n * Detect Node env\n *\n * @returns {boolean}\n */ const isNodeEnv = ()=> true || 0;\nconst sweetHTML = `\n <div aria-labelledby=\"${swalClasses.title}\" aria-describedby=\"${swalClasses[\"html-container\"]}\" class=\"${swalClasses.popup}\" tabindex=\"-1\">\n   <button type=\"button\" class=\"${swalClasses.close}\"></button>\n   <ul class=\"${swalClasses[\"progress-steps\"]}\"></ul>\n   <div class=\"${swalClasses.icon}\"></div>\n   <img class=\"${swalClasses.image}\" />\n   <h2 class=\"${swalClasses.title}\" id=\"${swalClasses.title}\"></h2>\n   <div class=\"${swalClasses[\"html-container\"]}\" id=\"${swalClasses[\"html-container\"]}\"></div>\n   <input class=\"${swalClasses.input}\" id=\"${swalClasses.input}\" />\n   <input type=\"file\" class=\"${swalClasses.file}\" />\n   <div class=\"${swalClasses.range}\">\n     <input type=\"range\" />\n     <output></output>\n   </div>\n   <select class=\"${swalClasses.select}\" id=\"${swalClasses.select}\"></select>\n   <div class=\"${swalClasses.radio}\"></div>\n   <label class=\"${swalClasses.checkbox}\">\n     <input type=\"checkbox\" id=\"${swalClasses.checkbox}\" />\n     <span class=\"${swalClasses.label}\"></span>\n   </label>\n   <textarea class=\"${swalClasses.textarea}\" id=\"${swalClasses.textarea}\"></textarea>\n   <div class=\"${swalClasses[\"validation-message\"]}\" id=\"${swalClasses[\"validation-message\"]}\"></div>\n   <div class=\"${swalClasses.actions}\">\n     <div class=\"${swalClasses.loader}\"></div>\n     <button type=\"button\" class=\"${swalClasses.confirm}\"></button>\n     <button type=\"button\" class=\"${swalClasses.deny}\"></button>\n     <button type=\"button\" class=\"${swalClasses.cancel}\"></button>\n   </div>\n   <div class=\"${swalClasses.footer}\"></div>\n   <div class=\"${swalClasses[\"timer-progress-bar-container\"]}\">\n     <div class=\"${swalClasses[\"timer-progress-bar\"]}\"></div>\n   </div>\n </div>\n`.replace(/(^|\\n)\\s*/g, \"\");\n/**\n * @returns {boolean}\n */ const resetOldContainer = ()=>{\n    const oldContainer = getContainer();\n    if (!oldContainer) {\n        return false;\n    }\n    oldContainer.remove();\n    removeClass([\n        document.documentElement,\n        document.body\n    ], [\n        swalClasses[\"no-backdrop\"],\n        swalClasses[\"toast-shown\"],\n        swalClasses[\"has-column\"]\n    ]);\n    return true;\n};\nconst resetValidationMessage$1 = ()=>{\n    globalState.currentInstance.resetValidationMessage();\n};\nconst addInputChangeListeners = ()=>{\n    const popup = getPopup();\n    const input = getDirectChildByClass(popup, swalClasses.input);\n    const file = getDirectChildByClass(popup, swalClasses.file);\n    /** @type {HTMLInputElement} */ const range = popup.querySelector(`.${swalClasses.range} input`);\n    /** @type {HTMLOutputElement} */ const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);\n    const select = getDirectChildByClass(popup, swalClasses.select);\n    /** @type {HTMLInputElement} */ const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);\n    const textarea = getDirectChildByClass(popup, swalClasses.textarea);\n    input.oninput = resetValidationMessage$1;\n    file.onchange = resetValidationMessage$1;\n    select.onchange = resetValidationMessage$1;\n    checkbox.onchange = resetValidationMessage$1;\n    textarea.oninput = resetValidationMessage$1;\n    range.oninput = ()=>{\n        resetValidationMessage$1();\n        rangeOutput.value = range.value;\n    };\n    range.onchange = ()=>{\n        resetValidationMessage$1();\n        rangeOutput.value = range.value;\n    };\n};\n/**\n * @param {string | HTMLElement} target\n * @returns {HTMLElement}\n */ const getTarget = (target)=>typeof target === \"string\" ? document.querySelector(target) : target;\n/**\n * @param {SweetAlertOptions} params\n */ const setupAccessibility = (params)=>{\n    const popup = getPopup();\n    popup.setAttribute(\"role\", params.toast ? \"alert\" : \"dialog\");\n    popup.setAttribute(\"aria-live\", params.toast ? \"polite\" : \"assertive\");\n    if (!params.toast) {\n        popup.setAttribute(\"aria-modal\", \"true\");\n    }\n};\n/**\n * @param {HTMLElement} targetElement\n */ const setupRTL = (targetElement)=>{\n    if (window.getComputedStyle(targetElement).direction === \"rtl\") {\n        addClass(getContainer(), swalClasses.rtl);\n    }\n};\n/**\n * Add modal + backdrop + no-war message for Russians to DOM\n *\n * @param {SweetAlertOptions} params\n */ const init = (params)=>{\n    // Clean up the old popup container if it exists\n    const oldContainerExisted = resetOldContainer();\n    if (isNodeEnv()) {\n        error(\"SweetAlert2 requires document to initialize\");\n        return;\n    }\n    const container = document.createElement(\"div\");\n    container.className = swalClasses.container;\n    if (oldContainerExisted) {\n        addClass(container, swalClasses[\"no-transition\"]);\n    }\n    setInnerHtml(container, sweetHTML);\n    container.dataset[\"swal2Theme\"] = params.theme;\n    const targetElement = getTarget(params.target);\n    targetElement.appendChild(container);\n    setupAccessibility(params);\n    setupRTL(targetElement);\n    addInputChangeListeners();\n};\n/**\n * @param {HTMLElement | object | string} param\n * @param {HTMLElement} target\n */ const parseHtmlToContainer = (param, target)=>{\n    // DOM element\n    if (param instanceof HTMLElement) {\n        target.appendChild(param);\n    } else if (typeof param === \"object\") {\n        handleObject(param, target);\n    } else if (param) {\n        setInnerHtml(target, param);\n    }\n};\n/**\n * @param {any} param\n * @param {HTMLElement} target\n */ const handleObject = (param, target)=>{\n    // JQuery element(s)\n    if (param.jquery) {\n        handleJqueryElem(target, param);\n    } else {\n        setInnerHtml(target, param.toString());\n    }\n};\n/**\n * @param {HTMLElement} target\n * @param {any} elem\n */ const handleJqueryElem = (target, elem)=>{\n    target.textContent = \"\";\n    if (0 in elem) {\n        for(let i = 0; (i in elem); i++){\n            target.appendChild(elem[i].cloneNode(true));\n        }\n    } else {\n        target.appendChild(elem.cloneNode(true));\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderActions = (instance, params)=>{\n    const actions = getActions();\n    const loader = getLoader();\n    if (!actions || !loader) {\n        return;\n    }\n    // Actions (buttons) wrapper\n    if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {\n        hide(actions);\n    } else {\n        show(actions);\n    }\n    // Custom class\n    applyCustomClass(actions, params, \"actions\");\n    // Render all the buttons\n    renderButtons(actions, loader, params);\n    // Loader\n    setInnerHtml(loader, params.loaderHtml || \"\");\n    applyCustomClass(loader, params, \"loader\");\n};\n/**\n * @param {HTMLElement} actions\n * @param {HTMLElement} loader\n * @param {SweetAlertOptions} params\n */ function renderButtons(actions, loader, params) {\n    const confirmButton = getConfirmButton();\n    const denyButton = getDenyButton();\n    const cancelButton = getCancelButton();\n    if (!confirmButton || !denyButton || !cancelButton) {\n        return;\n    }\n    // Render buttons\n    renderButton(confirmButton, \"confirm\", params);\n    renderButton(denyButton, \"deny\", params);\n    renderButton(cancelButton, \"cancel\", params);\n    handleButtonsStyling(confirmButton, denyButton, cancelButton, params);\n    if (params.reverseButtons) {\n        if (params.toast) {\n            actions.insertBefore(cancelButton, confirmButton);\n            actions.insertBefore(denyButton, confirmButton);\n        } else {\n            actions.insertBefore(cancelButton, loader);\n            actions.insertBefore(denyButton, loader);\n            actions.insertBefore(confirmButton, loader);\n        }\n    }\n}\n/**\n * @param {HTMLElement} confirmButton\n * @param {HTMLElement} denyButton\n * @param {HTMLElement} cancelButton\n * @param {SweetAlertOptions} params\n */ function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {\n    if (!params.buttonsStyling) {\n        removeClass([\n            confirmButton,\n            denyButton,\n            cancelButton\n        ], swalClasses.styled);\n        return;\n    }\n    addClass([\n        confirmButton,\n        denyButton,\n        cancelButton\n    ], swalClasses.styled);\n    // Buttons background colors\n    if (params.confirmButtonColor) {\n        confirmButton.style.backgroundColor = params.confirmButtonColor;\n        addClass(confirmButton, swalClasses[\"default-outline\"]);\n    }\n    if (params.denyButtonColor) {\n        denyButton.style.backgroundColor = params.denyButtonColor;\n        addClass(denyButton, swalClasses[\"default-outline\"]);\n    }\n    if (params.cancelButtonColor) {\n        cancelButton.style.backgroundColor = params.cancelButtonColor;\n        addClass(cancelButton, swalClasses[\"default-outline\"]);\n    }\n}\n/**\n * @param {HTMLElement} button\n * @param {'confirm' | 'deny' | 'cancel'} buttonType\n * @param {SweetAlertOptions} params\n */ function renderButton(button, buttonType, params) {\n    const buttonName = /** @type {'Confirm' | 'Deny' | 'Cancel'} */ capitalizeFirstLetter(buttonType);\n    toggle(button, params[`show${buttonName}Button`], \"inline-block\");\n    setInnerHtml(button, params[`${buttonType}ButtonText`] || \"\"); // Set caption text\n    button.setAttribute(\"aria-label\", params[`${buttonType}ButtonAriaLabel`] || \"\"); // ARIA label\n    // Add buttons custom classes\n    button.className = swalClasses[buttonType];\n    applyCustomClass(button, params, `${buttonType}Button`);\n}\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderCloseButton = (instance, params)=>{\n    const closeButton = getCloseButton();\n    if (!closeButton) {\n        return;\n    }\n    setInnerHtml(closeButton, params.closeButtonHtml || \"\");\n    // Custom class\n    applyCustomClass(closeButton, params, \"closeButton\");\n    toggle(closeButton, params.showCloseButton);\n    closeButton.setAttribute(\"aria-label\", params.closeButtonAriaLabel || \"\");\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderContainer = (instance, params)=>{\n    const container = getContainer();\n    if (!container) {\n        return;\n    }\n    handleBackdropParam(container, params.backdrop);\n    handlePositionParam(container, params.position);\n    handleGrowParam(container, params.grow);\n    // Custom class\n    applyCustomClass(container, params, \"container\");\n};\n/**\n * @param {HTMLElement} container\n * @param {SweetAlertOptions['backdrop']} backdrop\n */ function handleBackdropParam(container, backdrop) {\n    if (typeof backdrop === \"string\") {\n        container.style.background = backdrop;\n    } else if (!backdrop) {\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses[\"no-backdrop\"]);\n    }\n}\n/**\n * @param {HTMLElement} container\n * @param {SweetAlertOptions['position']} position\n */ function handlePositionParam(container, position) {\n    if (!position) {\n        return;\n    }\n    if (position in swalClasses) {\n        addClass(container, swalClasses[position]);\n    } else {\n        warn('The \"position\" parameter is not valid, defaulting to \"center\"');\n        addClass(container, swalClasses.center);\n    }\n}\n/**\n * @param {HTMLElement} container\n * @param {SweetAlertOptions['grow']} grow\n */ function handleGrowParam(container, grow) {\n    if (!grow) {\n        return;\n    }\n    addClass(container, swalClasses[`grow-${grow}`]);\n}\n/**\n * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n * This is the approach that Babel will probably take to implement private methods/fields\n *   https://github.com/tc39/proposal-private-methods\n *   https://github.com/babel/babel/pull/7555\n * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n *   then we can use that language feature.\n */ var privateProps = {\n    innerParams: new WeakMap(),\n    domCache: new WeakMap()\n};\n/// <reference path=\"../../../../sweetalert2.d.ts\"/>\n/** @type {InputClass[]} */ const inputClasses = [\n    \"input\",\n    \"file\",\n    \"range\",\n    \"select\",\n    \"radio\",\n    \"checkbox\",\n    \"textarea\"\n];\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderInput = (instance, params)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const innerParams = privateProps.innerParams.get(instance);\n    const rerender = !innerParams || params.input !== innerParams.input;\n    inputClasses.forEach((inputClass)=>{\n        const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);\n        if (!inputContainer) {\n            return;\n        }\n        // set attributes\n        setAttributes(inputClass, params.inputAttributes);\n        // set class\n        inputContainer.className = swalClasses[inputClass];\n        if (rerender) {\n            hide(inputContainer);\n        }\n    });\n    if (params.input) {\n        if (rerender) {\n            showInput(params);\n        }\n        // set custom class\n        setCustomClass(params);\n    }\n};\n/**\n * @param {SweetAlertOptions} params\n */ const showInput = (params)=>{\n    if (!params.input) {\n        return;\n    }\n    if (!renderInputType[params.input]) {\n        error(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(\" | \")}, got \"${params.input}\"`);\n        return;\n    }\n    const inputContainer = getInputContainer(params.input);\n    if (!inputContainer) {\n        return;\n    }\n    const input = renderInputType[params.input](inputContainer, params);\n    show(inputContainer);\n    // input autofocus\n    if (params.inputAutoFocus) {\n        setTimeout(()=>{\n            focusInput(input);\n        });\n    }\n};\n/**\n * @param {HTMLInputElement} input\n */ const removeAttributes = (input)=>{\n    for(let i = 0; i < input.attributes.length; i++){\n        const attrName = input.attributes[i].name;\n        if (![\n            \"id\",\n            \"type\",\n            \"value\",\n            \"style\"\n        ].includes(attrName)) {\n            input.removeAttribute(attrName);\n        }\n    }\n};\n/**\n * @param {InputClass} inputClass\n * @param {SweetAlertOptions['inputAttributes']} inputAttributes\n */ const setAttributes = (inputClass, inputAttributes)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const input = getInput$1(popup, inputClass);\n    if (!input) {\n        return;\n    }\n    removeAttributes(input);\n    for(const attr in inputAttributes){\n        input.setAttribute(attr, inputAttributes[attr]);\n    }\n};\n/**\n * @param {SweetAlertOptions} params\n */ const setCustomClass = (params)=>{\n    if (!params.input) {\n        return;\n    }\n    const inputContainer = getInputContainer(params.input);\n    if (inputContainer) {\n        applyCustomClass(inputContainer, params, \"input\");\n    }\n};\n/**\n * @param {HTMLInputElement | HTMLTextAreaElement} input\n * @param {SweetAlertOptions} params\n */ const setInputPlaceholder = (input, params)=>{\n    if (!input.placeholder && params.inputPlaceholder) {\n        input.placeholder = params.inputPlaceholder;\n    }\n};\n/**\n * @param {Input} input\n * @param {Input} prependTo\n * @param {SweetAlertOptions} params\n */ const setInputLabel = (input, prependTo, params)=>{\n    if (params.inputLabel) {\n        const label = document.createElement(\"label\");\n        const labelClass = swalClasses[\"input-label\"];\n        label.setAttribute(\"for\", input.id);\n        label.className = labelClass;\n        if (typeof params.customClass === \"object\") {\n            addClass(label, params.customClass.inputLabel);\n        }\n        label.innerText = params.inputLabel;\n        prependTo.insertAdjacentElement(\"beforebegin\", label);\n    }\n};\n/**\n * @param {SweetAlertInput} inputType\n * @returns {HTMLElement | undefined}\n */ const getInputContainer = (inputType)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    return getDirectChildByClass(popup, swalClasses[/** @type {SwalClass} */ inputType] || swalClasses.input);\n};\n/**\n * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input\n * @param {SweetAlertOptions['inputValue']} inputValue\n */ const checkAndSetInputValue = (input, inputValue)=>{\n    if ([\n        \"string\",\n        \"number\"\n    ].includes(typeof inputValue)) {\n        input.value = `${inputValue}`;\n    } else if (!isPromise(inputValue)) {\n        warn(`Unexpected type of inputValue! Expected \"string\", \"number\" or \"Promise\", got \"${typeof inputValue}\"`);\n    }\n};\n/** @type {Record<SweetAlertInput, (input: Input | HTMLElement, params: SweetAlertOptions) => Input>} */ const renderInputType = {};\n/**\n * @param {HTMLInputElement} input\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType[\"datetime-local\"] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */ (input, params)=>{\n    checkAndSetInputValue(input, params.inputValue);\n    setInputLabel(input, input, params);\n    setInputPlaceholder(input, params);\n    input.type = params.input;\n    return input;\n};\n/**\n * @param {HTMLInputElement} input\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.file = (input, params)=>{\n    setInputLabel(input, input, params);\n    setInputPlaceholder(input, params);\n    return input;\n};\n/**\n * @param {HTMLInputElement} range\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.range = (range, params)=>{\n    const rangeInput = range.querySelector(\"input\");\n    const rangeOutput = range.querySelector(\"output\");\n    checkAndSetInputValue(rangeInput, params.inputValue);\n    rangeInput.type = params.input;\n    checkAndSetInputValue(rangeOutput, params.inputValue);\n    setInputLabel(rangeInput, range, params);\n    return range;\n};\n/**\n * @param {HTMLSelectElement} select\n * @param {SweetAlertOptions} params\n * @returns {HTMLSelectElement}\n */ renderInputType.select = (select, params)=>{\n    select.textContent = \"\";\n    if (params.inputPlaceholder) {\n        const placeholder = document.createElement(\"option\");\n        setInnerHtml(placeholder, params.inputPlaceholder);\n        placeholder.value = \"\";\n        placeholder.disabled = true;\n        placeholder.selected = true;\n        select.appendChild(placeholder);\n    }\n    setInputLabel(select, select, params);\n    return select;\n};\n/**\n * @param {HTMLInputElement} radio\n * @returns {HTMLInputElement}\n */ renderInputType.radio = (radio)=>{\n    radio.textContent = \"\";\n    return radio;\n};\n/**\n * @param {HTMLLabelElement} checkboxContainer\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.checkbox = (checkboxContainer, params)=>{\n    const checkbox = getInput$1(getPopup(), \"checkbox\");\n    checkbox.value = \"1\";\n    checkbox.checked = Boolean(params.inputValue);\n    const label = checkboxContainer.querySelector(\"span\");\n    setInnerHtml(label, params.inputPlaceholder || params.inputLabel);\n    return checkbox;\n};\n/**\n * @param {HTMLTextAreaElement} textarea\n * @param {SweetAlertOptions} params\n * @returns {HTMLTextAreaElement}\n */ renderInputType.textarea = (textarea, params)=>{\n    checkAndSetInputValue(textarea, params.inputValue);\n    setInputPlaceholder(textarea, params);\n    setInputLabel(textarea, textarea, params);\n    /**\n   * @param {HTMLElement} el\n   * @returns {number}\n   */ const getMargin = (el)=>parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);\n    // https://github.com/sweetalert2/sweetalert2/issues/2291\n    setTimeout(()=>{\n        // https://github.com/sweetalert2/sweetalert2/issues/1699\n        if (\"MutationObserver\" in window) {\n            const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);\n            const textareaResizeHandler = ()=>{\n                // check if texarea is still in document (i.e. popup wasn't closed in the meantime)\n                if (!document.body.contains(textarea)) {\n                    return;\n                }\n                const textareaWidth = textarea.offsetWidth + getMargin(textarea);\n                if (textareaWidth > initialPopupWidth) {\n                    getPopup().style.width = `${textareaWidth}px`;\n                } else {\n                    applyNumericalStyle(getPopup(), \"width\", params.width);\n                }\n            };\n            new MutationObserver(textareaResizeHandler).observe(textarea, {\n                attributes: true,\n                attributeFilter: [\n                    \"style\"\n                ]\n            });\n        }\n    });\n    return textarea;\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderContent = (instance, params)=>{\n    const htmlContainer = getHtmlContainer();\n    if (!htmlContainer) {\n        return;\n    }\n    showWhenInnerHtmlPresent(htmlContainer);\n    applyCustomClass(htmlContainer, params, \"htmlContainer\");\n    // Content as HTML\n    if (params.html) {\n        parseHtmlToContainer(params.html, htmlContainer);\n        show(htmlContainer, \"block\");\n    } else if (params.text) {\n        htmlContainer.textContent = params.text;\n        show(htmlContainer, \"block\");\n    } else {\n        hide(htmlContainer);\n    }\n    renderInput(instance, params);\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderFooter = (instance, params)=>{\n    const footer = getFooter();\n    if (!footer) {\n        return;\n    }\n    showWhenInnerHtmlPresent(footer);\n    toggle(footer, params.footer, \"block\");\n    if (params.footer) {\n        parseHtmlToContainer(params.footer, footer);\n    }\n    // Custom class\n    applyCustomClass(footer, params, \"footer\");\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderIcon = (instance, params)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    const icon = getIcon();\n    if (!icon) {\n        return;\n    }\n    // if the given icon already rendered, apply the styling without re-rendering the icon\n    if (innerParams && params.icon === innerParams.icon) {\n        // Custom or default content\n        setContent(icon, params);\n        applyStyles(icon, params);\n        return;\n    }\n    if (!params.icon && !params.iconHtml) {\n        hide(icon);\n        return;\n    }\n    if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {\n        error(`Unknown icon! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"${params.icon}\"`);\n        hide(icon);\n        return;\n    }\n    show(icon);\n    // Custom or default content\n    setContent(icon, params);\n    applyStyles(icon, params);\n    // Animate icon\n    addClass(icon, params.showClass && params.showClass.icon);\n    // Re-adjust the success icon on system theme change\n    const colorSchemeQueryList = window.matchMedia(\"(prefers-color-scheme: dark)\");\n    colorSchemeQueryList.addEventListener(\"change\", adjustSuccessIconBackgroundColor);\n};\n/**\n * @param {HTMLElement} icon\n * @param {SweetAlertOptions} params\n */ const applyStyles = (icon, params)=>{\n    for (const [iconType, iconClassName] of Object.entries(iconTypes)){\n        if (params.icon !== iconType) {\n            removeClass(icon, iconClassName);\n        }\n    }\n    addClass(icon, params.icon && iconTypes[params.icon]);\n    // Icon color\n    setColor(icon, params);\n    // Success icon background color\n    adjustSuccessIconBackgroundColor();\n    // Custom class\n    applyCustomClass(icon, params, \"icon\");\n};\n// Adjust success icon background color to match the popup background color\nconst adjustSuccessIconBackgroundColor = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue(\"background-color\");\n    /** @type {NodeListOf<HTMLElement>} */ const successIconParts = popup.querySelectorAll(\"[class^=swal2-success-circular-line], .swal2-success-fix\");\n    for(let i = 0; i < successIconParts.length; i++){\n        successIconParts[i].style.backgroundColor = popupBackgroundColor;\n    }\n};\nconst successIconHtml = `\n  <div class=\"swal2-success-circular-line-left\"></div>\n  <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n  <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\n  <div class=\"swal2-success-circular-line-right\"></div>\n`;\nconst errorIconHtml = `\n  <span class=\"swal2-x-mark\">\n    <span class=\"swal2-x-mark-line-left\"></span>\n    <span class=\"swal2-x-mark-line-right\"></span>\n  </span>\n`;\n/**\n * @param {HTMLElement} icon\n * @param {SweetAlertOptions} params\n */ const setContent = (icon, params)=>{\n    if (!params.icon && !params.iconHtml) {\n        return;\n    }\n    let oldContent = icon.innerHTML;\n    let newContent = \"\";\n    if (params.iconHtml) {\n        newContent = iconContent(params.iconHtml);\n    } else if (params.icon === \"success\") {\n        newContent = successIconHtml;\n        oldContent = oldContent.replace(/ style=\".*?\"/g, \"\"); // undo adjustSuccessIconBackgroundColor()\n    } else if (params.icon === \"error\") {\n        newContent = errorIconHtml;\n    } else if (params.icon) {\n        const defaultIconHtml = {\n            question: \"?\",\n            warning: \"!\",\n            info: \"i\"\n        };\n        newContent = iconContent(defaultIconHtml[params.icon]);\n    }\n    if (oldContent.trim() !== newContent.trim()) {\n        setInnerHtml(icon, newContent);\n    }\n};\n/**\n * @param {HTMLElement} icon\n * @param {SweetAlertOptions} params\n */ const setColor = (icon, params)=>{\n    if (!params.iconColor) {\n        return;\n    }\n    icon.style.color = params.iconColor;\n    icon.style.borderColor = params.iconColor;\n    for (const sel of [\n        \".swal2-success-line-tip\",\n        \".swal2-success-line-long\",\n        \".swal2-x-mark-line-left\",\n        \".swal2-x-mark-line-right\"\n    ]){\n        setStyle(icon, sel, \"background-color\", params.iconColor);\n    }\n    setStyle(icon, \".swal2-success-ring\", \"border-color\", params.iconColor);\n};\n/**\n * @param {string} content\n * @returns {string}\n */ const iconContent = (content)=>`<div class=\"${swalClasses[\"icon-content\"]}\">${content}</div>`;\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderImage = (instance, params)=>{\n    const image = getImage();\n    if (!image) {\n        return;\n    }\n    if (!params.imageUrl) {\n        hide(image);\n        return;\n    }\n    show(image, \"\");\n    // Src, alt\n    image.setAttribute(\"src\", params.imageUrl);\n    image.setAttribute(\"alt\", params.imageAlt || \"\");\n    // Width, height\n    applyNumericalStyle(image, \"width\", params.imageWidth);\n    applyNumericalStyle(image, \"height\", params.imageHeight);\n    // Class\n    image.className = swalClasses.image;\n    applyCustomClass(image, params, \"image\");\n};\nlet dragging = false;\nlet mousedownX = 0;\nlet mousedownY = 0;\nlet initialX = 0;\nlet initialY = 0;\n/**\n * @param {HTMLElement} popup\n */ const addDraggableListeners = (popup)=>{\n    popup.addEventListener(\"mousedown\", down);\n    document.body.addEventListener(\"mousemove\", move);\n    popup.addEventListener(\"mouseup\", up);\n    popup.addEventListener(\"touchstart\", down);\n    document.body.addEventListener(\"touchmove\", move);\n    popup.addEventListener(\"touchend\", up);\n};\n/**\n * @param {HTMLElement} popup\n */ const removeDraggableListeners = (popup)=>{\n    popup.removeEventListener(\"mousedown\", down);\n    document.body.removeEventListener(\"mousemove\", move);\n    popup.removeEventListener(\"mouseup\", up);\n    popup.removeEventListener(\"touchstart\", down);\n    document.body.removeEventListener(\"touchmove\", move);\n    popup.removeEventListener(\"touchend\", up);\n};\n/**\n * @param {MouseEvent | TouchEvent} event\n */ const down = (event)=>{\n    const popup = getPopup();\n    if (event.target === popup || getIcon().contains(/** @type {HTMLElement} */ event.target)) {\n        dragging = true;\n        const clientXY = getClientXY(event);\n        mousedownX = clientXY.clientX;\n        mousedownY = clientXY.clientY;\n        initialX = parseInt(popup.style.insetInlineStart) || 0;\n        initialY = parseInt(popup.style.insetBlockStart) || 0;\n        addClass(popup, \"swal2-dragging\");\n    }\n};\n/**\n * @param {MouseEvent | TouchEvent} event\n */ const move = (event)=>{\n    const popup = getPopup();\n    if (dragging) {\n        let { clientX, clientY } = getClientXY(event);\n        popup.style.insetInlineStart = `${initialX + (clientX - mousedownX)}px`;\n        popup.style.insetBlockStart = `${initialY + (clientY - mousedownY)}px`;\n    }\n};\nconst up = ()=>{\n    const popup = getPopup();\n    dragging = false;\n    removeClass(popup, \"swal2-dragging\");\n};\n/**\n * @param {MouseEvent | TouchEvent} event\n * @returns {{ clientX: number, clientY: number }}\n */ const getClientXY = (event)=>{\n    let clientX = 0, clientY = 0;\n    if (event.type.startsWith(\"mouse\")) {\n        clientX = /** @type {MouseEvent} */ event.clientX;\n        clientY = /** @type {MouseEvent} */ event.clientY;\n    } else if (event.type.startsWith(\"touch\")) {\n        clientX = /** @type {TouchEvent} */ event.touches[0].clientX;\n        clientY = /** @type {TouchEvent} */ event.touches[0].clientY;\n    }\n    return {\n        clientX,\n        clientY\n    };\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderPopup = (instance, params)=>{\n    const container = getContainer();\n    const popup = getPopup();\n    if (!container || !popup) {\n        return;\n    }\n    // Width\n    // https://github.com/sweetalert2/sweetalert2/issues/2170\n    if (params.toast) {\n        applyNumericalStyle(container, \"width\", params.width);\n        popup.style.width = \"100%\";\n        const loader = getLoader();\n        if (loader) {\n            popup.insertBefore(loader, getIcon());\n        }\n    } else {\n        applyNumericalStyle(popup, \"width\", params.width);\n    }\n    // Padding\n    applyNumericalStyle(popup, \"padding\", params.padding);\n    // Color\n    if (params.color) {\n        popup.style.color = params.color;\n    }\n    // Background\n    if (params.background) {\n        popup.style.background = params.background;\n    }\n    hide(getValidationMessage());\n    // Classes\n    addClasses$1(popup, params);\n    if (params.draggable && !params.toast) {\n        addClass(popup, swalClasses.draggable);\n        addDraggableListeners(popup);\n    } else {\n        removeClass(popup, swalClasses.draggable);\n        removeDraggableListeners(popup);\n    }\n};\n/**\n * @param {HTMLElement} popup\n * @param {SweetAlertOptions} params\n */ const addClasses$1 = (popup, params)=>{\n    const showClass = params.showClass || {};\n    // Default Class + showClass when updating Swal.update({})\n    popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : \"\"}`;\n    if (params.toast) {\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses[\"toast-shown\"]);\n        addClass(popup, swalClasses.toast);\n    } else {\n        addClass(popup, swalClasses.modal);\n    }\n    // Custom class\n    applyCustomClass(popup, params, \"popup\");\n    // TODO: remove in the next major\n    if (typeof params.customClass === \"string\") {\n        addClass(popup, params.customClass);\n    }\n    // Icon class (#1842)\n    if (params.icon) {\n        addClass(popup, swalClasses[`icon-${params.icon}`]);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderProgressSteps = (instance, params)=>{\n    const progressStepsContainer = getProgressSteps();\n    if (!progressStepsContainer) {\n        return;\n    }\n    const { progressSteps, currentProgressStep } = params;\n    if (!progressSteps || progressSteps.length === 0 || currentProgressStep === undefined) {\n        hide(progressStepsContainer);\n        return;\n    }\n    show(progressStepsContainer);\n    progressStepsContainer.textContent = \"\";\n    if (currentProgressStep >= progressSteps.length) {\n        warn(\"Invalid currentProgressStep parameter, it should be less than progressSteps.length \" + \"(currentProgressStep like JS arrays starts from 0)\");\n    }\n    progressSteps.forEach((step, index)=>{\n        const stepEl = createStepElement(step);\n        progressStepsContainer.appendChild(stepEl);\n        if (index === currentProgressStep) {\n            addClass(stepEl, swalClasses[\"active-progress-step\"]);\n        }\n        if (index !== progressSteps.length - 1) {\n            const lineEl = createLineElement(params);\n            progressStepsContainer.appendChild(lineEl);\n        }\n    });\n};\n/**\n * @param {string} step\n * @returns {HTMLLIElement}\n */ const createStepElement = (step)=>{\n    const stepEl = document.createElement(\"li\");\n    addClass(stepEl, swalClasses[\"progress-step\"]);\n    setInnerHtml(stepEl, step);\n    return stepEl;\n};\n/**\n * @param {SweetAlertOptions} params\n * @returns {HTMLLIElement}\n */ const createLineElement = (params)=>{\n    const lineEl = document.createElement(\"li\");\n    addClass(lineEl, swalClasses[\"progress-step-line\"]);\n    if (params.progressStepsDistance) {\n        applyNumericalStyle(lineEl, \"width\", params.progressStepsDistance);\n    }\n    return lineEl;\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderTitle = (instance, params)=>{\n    const title = getTitle();\n    if (!title) {\n        return;\n    }\n    showWhenInnerHtmlPresent(title);\n    toggle(title, params.title || params.titleText, \"block\");\n    if (params.title) {\n        parseHtmlToContainer(params.title, title);\n    }\n    if (params.titleText) {\n        title.innerText = params.titleText;\n    }\n    // Custom class\n    applyCustomClass(title, params, \"title\");\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const render = (instance, params)=>{\n    renderPopup(instance, params);\n    renderContainer(instance, params);\n    renderProgressSteps(instance, params);\n    renderIcon(instance, params);\n    renderImage(instance, params);\n    renderTitle(instance, params);\n    renderCloseButton(instance, params);\n    renderContent(instance, params);\n    renderActions(instance, params);\n    renderFooter(instance, params);\n    const popup = getPopup();\n    if (typeof params.didRender === \"function\" && popup) {\n        params.didRender(popup);\n    }\n    globalState.eventEmitter.emit(\"didRender\", popup);\n};\n/*\n * Global function to determine if SweetAlert2 popup is shown\n */ const isVisible = ()=>{\n    return isVisible$1(getPopup());\n};\n/*\n * Global function to click 'Confirm' button\n */ const clickConfirm = ()=>{\n    var _dom$getConfirmButton;\n    return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();\n};\n/*\n * Global function to click 'Deny' button\n */ const clickDeny = ()=>{\n    var _dom$getDenyButton;\n    return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();\n};\n/*\n * Global function to click 'Cancel' button\n */ const clickCancel = ()=>{\n    var _dom$getCancelButton;\n    return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();\n};\n/** @typedef {'cancel' | 'backdrop' | 'close' | 'esc' | 'timer'} DismissReason */ /** @type {Record<DismissReason, DismissReason>} */ const DismissReason = Object.freeze({\n    cancel: \"cancel\",\n    backdrop: \"backdrop\",\n    close: \"close\",\n    esc: \"esc\",\n    timer: \"timer\"\n});\n/**\n * @param {GlobalState} globalState\n */ const removeKeydownHandler = (globalState)=>{\n    if (globalState.keydownTarget && globalState.keydownHandlerAdded) {\n        globalState.keydownTarget.removeEventListener(\"keydown\", globalState.keydownHandler, {\n            capture: globalState.keydownListenerCapture\n        });\n        globalState.keydownHandlerAdded = false;\n    }\n};\n/**\n * @param {GlobalState} globalState\n * @param {SweetAlertOptions} innerParams\n * @param {*} dismissWith\n */ const addKeydownHandler = (globalState, innerParams, dismissWith)=>{\n    removeKeydownHandler(globalState);\n    if (!innerParams.toast) {\n        globalState.keydownHandler = (e)=>keydownHandler(innerParams, e, dismissWith);\n        globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();\n        globalState.keydownListenerCapture = innerParams.keydownListenerCapture;\n        globalState.keydownTarget.addEventListener(\"keydown\", globalState.keydownHandler, {\n            capture: globalState.keydownListenerCapture\n        });\n        globalState.keydownHandlerAdded = true;\n    }\n};\n/**\n * @param {number} index\n * @param {number} increment\n */ const setFocus = (index, increment)=>{\n    var _dom$getPopup;\n    const focusableElements = getFocusableElements();\n    // search for visible elements and select the next possible match\n    if (focusableElements.length) {\n        index = index + increment;\n        // rollover to first item\n        if (index === focusableElements.length) {\n            index = 0;\n        // go to last item\n        } else if (index === -1) {\n            index = focusableElements.length - 1;\n        }\n        focusableElements[index].focus();\n        return;\n    }\n    // no visible focusable elements, focus the popup\n    (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();\n};\nconst arrowKeysNextButton = [\n    \"ArrowRight\",\n    \"ArrowDown\"\n];\nconst arrowKeysPreviousButton = [\n    \"ArrowLeft\",\n    \"ArrowUp\"\n];\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {KeyboardEvent} event\n * @param {Function} dismissWith\n */ const keydownHandler = (innerParams, event, dismissWith)=>{\n    if (!innerParams) {\n        return; // This instance has already been destroyed\n    }\n    // Ignore keydown during IME composition\n    // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition\n    // https://github.com/sweetalert2/sweetalert2/issues/720\n    // https://github.com/sweetalert2/sweetalert2/issues/2406\n    if (event.isComposing || event.keyCode === 229) {\n        return;\n    }\n    if (innerParams.stopKeydownPropagation) {\n        event.stopPropagation();\n    }\n    // ENTER\n    if (event.key === \"Enter\") {\n        handleEnter(event, innerParams);\n    } else if (event.key === \"Tab\") {\n        handleTab(event);\n    } else if ([\n        ...arrowKeysNextButton,\n        ...arrowKeysPreviousButton\n    ].includes(event.key)) {\n        handleArrows(event.key);\n    } else if (event.key === \"Escape\") {\n        handleEsc(event, innerParams, dismissWith);\n    }\n};\n/**\n * @param {KeyboardEvent} event\n * @param {SweetAlertOptions} innerParams\n */ const handleEnter = (event, innerParams)=>{\n    // https://github.com/sweetalert2/sweetalert2/issues/2386\n    if (!callIfFunction(innerParams.allowEnterKey)) {\n        return;\n    }\n    const input = getInput$1(getPopup(), innerParams.input);\n    if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {\n        if ([\n            \"textarea\",\n            \"file\"\n        ].includes(innerParams.input)) {\n            return; // do not submit\n        }\n        clickConfirm();\n        event.preventDefault();\n    }\n};\n/**\n * @param {KeyboardEvent} event\n */ const handleTab = (event)=>{\n    const targetElement = event.target;\n    const focusableElements = getFocusableElements();\n    let btnIndex = -1;\n    for(let i = 0; i < focusableElements.length; i++){\n        if (targetElement === focusableElements[i]) {\n            btnIndex = i;\n            break;\n        }\n    }\n    // Cycle to the next button\n    if (!event.shiftKey) {\n        setFocus(btnIndex, 1);\n    } else {\n        setFocus(btnIndex, -1);\n    }\n    event.stopPropagation();\n    event.preventDefault();\n};\n/**\n * @param {string} key\n */ const handleArrows = (key)=>{\n    const actions = getActions();\n    const confirmButton = getConfirmButton();\n    const denyButton = getDenyButton();\n    const cancelButton = getCancelButton();\n    if (!actions || !confirmButton || !denyButton || !cancelButton) {\n        return;\n    }\n    /** @type HTMLElement[] */ const buttons = [\n        confirmButton,\n        denyButton,\n        cancelButton\n    ];\n    if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {\n        return;\n    }\n    const sibling = arrowKeysNextButton.includes(key) ? \"nextElementSibling\" : \"previousElementSibling\";\n    let buttonToFocus = document.activeElement;\n    if (!buttonToFocus) {\n        return;\n    }\n    for(let i = 0; i < actions.children.length; i++){\n        buttonToFocus = buttonToFocus[sibling];\n        if (!buttonToFocus) {\n            return;\n        }\n        if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {\n            break;\n        }\n    }\n    if (buttonToFocus instanceof HTMLButtonElement) {\n        buttonToFocus.focus();\n    }\n};\n/**\n * @param {KeyboardEvent} event\n * @param {SweetAlertOptions} innerParams\n * @param {Function} dismissWith\n */ const handleEsc = (event, innerParams, dismissWith)=>{\n    if (callIfFunction(innerParams.allowEscapeKey)) {\n        event.preventDefault();\n        dismissWith(DismissReason.esc);\n    }\n};\n/**\n * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n * This is the approach that Babel will probably take to implement private methods/fields\n *   https://github.com/tc39/proposal-private-methods\n *   https://github.com/babel/babel/pull/7555\n * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n *   then we can use that language feature.\n */ var privateMethods = {\n    swalPromiseResolve: new WeakMap(),\n    swalPromiseReject: new WeakMap()\n};\n// From https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/\n// Adding aria-hidden=\"true\" to elements outside of the active modal dialog ensures that\n// elements not within the active modal dialog will not be surfaced if a user opens a screen\n// readers list of elements (headings, form controls, landmarks, etc.) in the document.\nconst setAriaHidden = ()=>{\n    const container = getContainer();\n    const bodyChildren = Array.from(document.body.children);\n    bodyChildren.forEach((el)=>{\n        if (el.contains(container)) {\n            return;\n        }\n        if (el.hasAttribute(\"aria-hidden\")) {\n            el.setAttribute(\"data-previous-aria-hidden\", el.getAttribute(\"aria-hidden\") || \"\");\n        }\n        el.setAttribute(\"aria-hidden\", \"true\");\n    });\n};\nconst unsetAriaHidden = ()=>{\n    const bodyChildren = Array.from(document.body.children);\n    bodyChildren.forEach((el)=>{\n        if (el.hasAttribute(\"data-previous-aria-hidden\")) {\n            el.setAttribute(\"aria-hidden\", el.getAttribute(\"data-previous-aria-hidden\") || \"\");\n            el.removeAttribute(\"data-previous-aria-hidden\");\n        } else {\n            el.removeAttribute(\"aria-hidden\");\n        }\n    });\n};\n// @ts-ignore\nconst isSafariOrIOS =  false && 0; // true for Safari desktop + all iOS browsers https://stackoverflow.com/a/70585394\n/**\n * Fix iOS scrolling\n * http://stackoverflow.com/q/39626302\n */ const iOSfix = ()=>{\n    if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {\n        const offset = document.body.scrollTop;\n        document.body.style.top = `${offset * -1}px`;\n        addClass(document.body, swalClasses.iosfix);\n        lockBodyScroll();\n    }\n};\n/**\n * https://github.com/sweetalert2/sweetalert2/issues/1246\n */ const lockBodyScroll = ()=>{\n    const container = getContainer();\n    if (!container) {\n        return;\n    }\n    /** @type {boolean} */ let preventTouchMove;\n    /**\n   * @param {TouchEvent} event\n   */ container.ontouchstart = (event)=>{\n        preventTouchMove = shouldPreventTouchMove(event);\n    };\n    /**\n   * @param {TouchEvent} event\n   */ container.ontouchmove = (event)=>{\n        if (preventTouchMove) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    };\n};\n/**\n * @param {TouchEvent} event\n * @returns {boolean}\n */ const shouldPreventTouchMove = (event)=>{\n    const target = event.target;\n    const container = getContainer();\n    const htmlContainer = getHtmlContainer();\n    if (!container || !htmlContainer) {\n        return false;\n    }\n    if (isStylus(event) || isZoom(event)) {\n        return false;\n    }\n    if (target === container) {\n        return true;\n    }\n    if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== \"INPUT\" && // #1603\n    target.tagName !== \"TEXTAREA\" && // #2266\n    !(isScrollable(htmlContainer) && // #1944\n    htmlContainer.contains(target))) {\n        return true;\n    }\n    return false;\n};\n/**\n * https://github.com/sweetalert2/sweetalert2/issues/1786\n *\n * @param {*} event\n * @returns {boolean}\n */ const isStylus = (event)=>{\n    return event.touches && event.touches.length && event.touches[0].touchType === \"stylus\";\n};\n/**\n * https://github.com/sweetalert2/sweetalert2/issues/1891\n *\n * @param {TouchEvent} event\n * @returns {boolean}\n */ const isZoom = (event)=>{\n    return event.touches && event.touches.length > 1;\n};\nconst undoIOSfix = ()=>{\n    if (hasClass(document.body, swalClasses.iosfix)) {\n        const offset = parseInt(document.body.style.top, 10);\n        removeClass(document.body, swalClasses.iosfix);\n        document.body.style.top = \"\";\n        document.body.scrollTop = offset * -1;\n    }\n};\n/**\n * Measure scrollbar width for padding body during modal show/hide\n * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js\n *\n * @returns {number}\n */ const measureScrollbar = ()=>{\n    const scrollDiv = document.createElement(\"div\");\n    scrollDiv.className = swalClasses[\"scrollbar-measure\"];\n    document.body.appendChild(scrollDiv);\n    const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n};\n/**\n * Remember state in cases where opening and handling a modal will fiddle with it.\n * @type {number | null}\n */ let previousBodyPadding = null;\n/**\n * @param {string} initialBodyOverflow\n */ const replaceScrollbarWithPadding = (initialBodyOverflow)=>{\n    // for queues, do not do this more than once\n    if (previousBodyPadding !== null) {\n        return;\n    }\n    // if the body has overflow\n    if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === \"scroll\" // https://github.com/sweetalert2/sweetalert2/issues/2663\n    ) {\n        // add padding so the content doesn't shift after removal of scrollbar\n        previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue(\"padding-right\"));\n        document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;\n    }\n};\nconst undoReplaceScrollbarWithPadding = ()=>{\n    if (previousBodyPadding !== null) {\n        document.body.style.paddingRight = `${previousBodyPadding}px`;\n        previousBodyPadding = null;\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {HTMLElement} container\n * @param {boolean} returnFocus\n * @param {Function} didClose\n */ function removePopupAndResetState(instance, container, returnFocus, didClose) {\n    if (isToast()) {\n        triggerDidCloseAndDispose(instance, didClose);\n    } else {\n        restoreActiveElement(returnFocus).then(()=>triggerDidCloseAndDispose(instance, didClose));\n        removeKeydownHandler(globalState);\n    }\n    // workaround for https://github.com/sweetalert2/sweetalert2/issues/2088\n    // for some reason removing the container in Safari will scroll the document to bottom\n    if (isSafariOrIOS) {\n        container.setAttribute(\"style\", \"display:none !important\");\n        container.removeAttribute(\"class\");\n        container.innerHTML = \"\";\n    } else {\n        container.remove();\n    }\n    if (isModal()) {\n        undoReplaceScrollbarWithPadding();\n        undoIOSfix();\n        unsetAriaHidden();\n    }\n    removeBodyClasses();\n}\n/**\n * Remove SweetAlert2 classes from body\n */ function removeBodyClasses() {\n    removeClass([\n        document.documentElement,\n        document.body\n    ], [\n        swalClasses.shown,\n        swalClasses[\"height-auto\"],\n        swalClasses[\"no-backdrop\"],\n        swalClasses[\"toast-shown\"]\n    ]);\n}\n/**\n * Instance method to close sweetAlert\n *\n * @param {any} resolveValue\n */ function close(resolveValue) {\n    resolveValue = prepareResolveValue(resolveValue);\n    const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);\n    const didClose = triggerClosePopup(this);\n    if (this.isAwaitingPromise) {\n        // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335\n        if (!resolveValue.isDismissed) {\n            handleAwaitingPromise(this);\n            swalPromiseResolve(resolveValue);\n        }\n    } else if (didClose) {\n        // Resolve Swal promise\n        swalPromiseResolve(resolveValue);\n    }\n}\nconst triggerClosePopup = (instance)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return false;\n    }\n    const innerParams = privateProps.innerParams.get(instance);\n    if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {\n        return false;\n    }\n    removeClass(popup, innerParams.showClass.popup);\n    addClass(popup, innerParams.hideClass.popup);\n    const backdrop = getContainer();\n    removeClass(backdrop, innerParams.showClass.backdrop);\n    addClass(backdrop, innerParams.hideClass.backdrop);\n    handlePopupAnimation(instance, popup, innerParams);\n    return true;\n};\n/**\n * @param {any} error\n */ function rejectPromise(error) {\n    const rejectPromise = privateMethods.swalPromiseReject.get(this);\n    handleAwaitingPromise(this);\n    if (rejectPromise) {\n        // Reject Swal promise\n        rejectPromise(error);\n    }\n}\n/**\n * @param {SweetAlert} instance\n */ const handleAwaitingPromise = (instance)=>{\n    if (instance.isAwaitingPromise) {\n        delete instance.isAwaitingPromise;\n        // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335\n        if (!privateProps.innerParams.get(instance)) {\n            instance._destroy();\n        }\n    }\n};\n/**\n * @param {any} resolveValue\n * @returns {SweetAlertResult}\n */ const prepareResolveValue = (resolveValue)=>{\n    // When user calls Swal.close()\n    if (typeof resolveValue === \"undefined\") {\n        return {\n            isConfirmed: false,\n            isDenied: false,\n            isDismissed: true\n        };\n    }\n    return Object.assign({\n        isConfirmed: false,\n        isDenied: false,\n        isDismissed: false\n    }, resolveValue);\n};\n/**\n * @param {SweetAlert} instance\n * @param {HTMLElement} popup\n * @param {SweetAlertOptions} innerParams\n */ const handlePopupAnimation = (instance, popup, innerParams)=>{\n    var _globalState$eventEmi;\n    const container = getContainer();\n    // If animation is supported, animate\n    const animationIsSupported = hasCssAnimation(popup);\n    if (typeof innerParams.willClose === \"function\") {\n        innerParams.willClose(popup);\n    }\n    (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit(\"willClose\", popup);\n    if (animationIsSupported) {\n        animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);\n    } else {\n        // Otherwise, remove immediately\n        removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {HTMLElement} popup\n * @param {HTMLElement} container\n * @param {boolean} returnFocus\n * @param {Function} didClose\n */ const animatePopup = (instance, popup, container, returnFocus, didClose)=>{\n    globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);\n    /**\n   * @param {AnimationEvent | TransitionEvent} e\n   */ const swalCloseAnimationFinished = function(e) {\n        if (e.target === popup) {\n            var _globalState$swalClos;\n            (_globalState$swalClos = globalState.swalCloseEventFinishedCallback) === null || _globalState$swalClos === void 0 || _globalState$swalClos.call(globalState);\n            delete globalState.swalCloseEventFinishedCallback;\n            popup.removeEventListener(\"animationend\", swalCloseAnimationFinished);\n            popup.removeEventListener(\"transitionend\", swalCloseAnimationFinished);\n        }\n    };\n    popup.addEventListener(\"animationend\", swalCloseAnimationFinished);\n    popup.addEventListener(\"transitionend\", swalCloseAnimationFinished);\n};\n/**\n * @param {SweetAlert} instance\n * @param {Function} didClose\n */ const triggerDidCloseAndDispose = (instance, didClose)=>{\n    setTimeout(()=>{\n        var _globalState$eventEmi2;\n        if (typeof didClose === \"function\") {\n            didClose.bind(instance.params)();\n        }\n        (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === void 0 || _globalState$eventEmi2.emit(\"didClose\");\n        // instance might have been destroyed already\n        if (instance._destroy) {\n            instance._destroy();\n        }\n    });\n};\n/**\n * Shows loader (spinner), this is useful with AJAX requests.\n * By default the loader be shown instead of the \"Confirm\" button.\n *\n * @param {HTMLButtonElement | null} [buttonToReplace]\n */ const showLoading = (buttonToReplace)=>{\n    let popup = getPopup();\n    if (!popup) {\n        new Swal();\n    }\n    popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const loader = getLoader();\n    if (isToast()) {\n        hide(getIcon());\n    } else {\n        replaceButton(popup, buttonToReplace);\n    }\n    show(loader);\n    popup.setAttribute(\"data-loading\", \"true\");\n    popup.setAttribute(\"aria-busy\", \"true\");\n    popup.focus();\n};\n/**\n * @param {HTMLElement} popup\n * @param {HTMLButtonElement | null} [buttonToReplace]\n */ const replaceButton = (popup, buttonToReplace)=>{\n    const actions = getActions();\n    const loader = getLoader();\n    if (!actions || !loader) {\n        return;\n    }\n    if (!buttonToReplace && isVisible$1(getConfirmButton())) {\n        buttonToReplace = getConfirmButton();\n    }\n    show(actions);\n    if (buttonToReplace) {\n        hide(buttonToReplace);\n        loader.setAttribute(\"data-button-to-replace\", buttonToReplace.className);\n        actions.insertBefore(loader, buttonToReplace);\n    }\n    addClass([\n        popup,\n        actions\n    ], swalClasses.loading);\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const handleInputOptionsAndValue = (instance, params)=>{\n    if (params.input === \"select\" || params.input === \"radio\") {\n        handleInputOptions(instance, params);\n    } else if ([\n        \"text\",\n        \"email\",\n        \"number\",\n        \"tel\",\n        \"textarea\"\n    ].some((i)=>i === params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {\n        showLoading(getConfirmButton());\n        handleInputValue(instance, params);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} innerParams\n * @returns {SweetAlertInputValue}\n */ const getInputValue = (instance, innerParams)=>{\n    const input = instance.getInput();\n    if (!input) {\n        return null;\n    }\n    switch(innerParams.input){\n        case \"checkbox\":\n            return getCheckboxValue(input);\n        case \"radio\":\n            return getRadioValue(input);\n        case \"file\":\n            return getFileValue(input);\n        default:\n            return innerParams.inputAutoTrim ? input.value.trim() : input.value;\n    }\n};\n/**\n * @param {HTMLInputElement} input\n * @returns {number}\n */ const getCheckboxValue = (input)=>input.checked ? 1 : 0;\n/**\n * @param {HTMLInputElement} input\n * @returns {string | null}\n */ const getRadioValue = (input)=>input.checked ? input.value : null;\n/**\n * @param {HTMLInputElement} input\n * @returns {FileList | File | null}\n */ const getFileValue = (input)=>input.files && input.files.length ? input.getAttribute(\"multiple\") !== null ? input.files : input.files[0] : null;\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const handleInputOptions = (instance, params)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    /**\n   * @param {Record<string, any>} inputOptions\n   */ const processInputOptions = (inputOptions)=>{\n        if (params.input === \"select\") {\n            populateSelectOptions(popup, formatInputOptions(inputOptions), params);\n        } else if (params.input === \"radio\") {\n            populateRadioOptions(popup, formatInputOptions(inputOptions), params);\n        }\n    };\n    if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {\n        showLoading(getConfirmButton());\n        asPromise(params.inputOptions).then((inputOptions)=>{\n            instance.hideLoading();\n            processInputOptions(inputOptions);\n        });\n    } else if (typeof params.inputOptions === \"object\") {\n        processInputOptions(params.inputOptions);\n    } else {\n        error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const handleInputValue = (instance, params)=>{\n    const input = instance.getInput();\n    if (!input) {\n        return;\n    }\n    hide(input);\n    asPromise(params.inputValue).then((inputValue)=>{\n        input.value = params.input === \"number\" ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;\n        show(input);\n        input.focus();\n        instance.hideLoading();\n    }).catch((err)=>{\n        error(`Error in inputValue promise: ${err}`);\n        input.value = \"\";\n        show(input);\n        input.focus();\n        instance.hideLoading();\n    });\n};\n/**\n * @param {HTMLElement} popup\n * @param {InputOptionFlattened[]} inputOptions\n * @param {SweetAlertOptions} params\n */ function populateSelectOptions(popup, inputOptions, params) {\n    const select = getDirectChildByClass(popup, swalClasses.select);\n    if (!select) {\n        return;\n    }\n    /**\n   * @param {HTMLElement} parent\n   * @param {string} optionLabel\n   * @param {string} optionValue\n   */ const renderOption = (parent, optionLabel, optionValue)=>{\n        const option = document.createElement(\"option\");\n        option.value = optionValue;\n        setInnerHtml(option, optionLabel);\n        option.selected = isSelected(optionValue, params.inputValue);\n        parent.appendChild(option);\n    };\n    inputOptions.forEach((inputOption)=>{\n        const optionValue = inputOption[0];\n        const optionLabel = inputOption[1];\n        // <optgroup> spec:\n        // https://www.w3.org/TR/html401/interact/forms.html#h-17.6\n        // \"...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)...\"\n        // check whether this is a <optgroup>\n        if (Array.isArray(optionLabel)) {\n            // if it is an array, then it is an <optgroup>\n            const optgroup = document.createElement(\"optgroup\");\n            optgroup.label = optionValue;\n            optgroup.disabled = false; // not configurable for now\n            select.appendChild(optgroup);\n            optionLabel.forEach((o)=>renderOption(optgroup, o[1], o[0]));\n        } else {\n            // case of <option>\n            renderOption(select, optionLabel, optionValue);\n        }\n    });\n    select.focus();\n}\n/**\n * @param {HTMLElement} popup\n * @param {InputOptionFlattened[]} inputOptions\n * @param {SweetAlertOptions} params\n */ function populateRadioOptions(popup, inputOptions, params) {\n    const radio = getDirectChildByClass(popup, swalClasses.radio);\n    if (!radio) {\n        return;\n    }\n    inputOptions.forEach((inputOption)=>{\n        const radioValue = inputOption[0];\n        const radioLabel = inputOption[1];\n        const radioInput = document.createElement(\"input\");\n        const radioLabelElement = document.createElement(\"label\");\n        radioInput.type = \"radio\";\n        radioInput.name = swalClasses.radio;\n        radioInput.value = radioValue;\n        if (isSelected(radioValue, params.inputValue)) {\n            radioInput.checked = true;\n        }\n        const label = document.createElement(\"span\");\n        setInnerHtml(label, radioLabel);\n        label.className = swalClasses.label;\n        radioLabelElement.appendChild(radioInput);\n        radioLabelElement.appendChild(label);\n        radio.appendChild(radioLabelElement);\n    });\n    const radios = radio.querySelectorAll(\"input\");\n    if (radios.length) {\n        radios[0].focus();\n    }\n}\n/**\n * Converts `inputOptions` into an array of `[value, label]`s\n *\n * @param {Record<string, any>} inputOptions\n * @typedef {string[]} InputOptionFlattened\n * @returns {InputOptionFlattened[]}\n */ const formatInputOptions = (inputOptions)=>{\n    /** @type {InputOptionFlattened[]} */ const result = [];\n    if (inputOptions instanceof Map) {\n        inputOptions.forEach((value, key)=>{\n            let valueFormatted = value;\n            if (typeof valueFormatted === \"object\") {\n                // case of <optgroup>\n                valueFormatted = formatInputOptions(valueFormatted);\n            }\n            result.push([\n                key,\n                valueFormatted\n            ]);\n        });\n    } else {\n        Object.keys(inputOptions).forEach((key)=>{\n            let valueFormatted = inputOptions[key];\n            if (typeof valueFormatted === \"object\") {\n                // case of <optgroup>\n                valueFormatted = formatInputOptions(valueFormatted);\n            }\n            result.push([\n                key,\n                valueFormatted\n            ]);\n        });\n    }\n    return result;\n};\n/**\n * @param {string} optionValue\n * @param {SweetAlertInputValue} inputValue\n * @returns {boolean}\n */ const isSelected = (optionValue, inputValue)=>{\n    return !!inputValue && inputValue.toString() === optionValue.toString();\n};\n/**\n * @param {SweetAlert} instance\n */ const handleConfirmButtonClick = (instance)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableButtons();\n    if (innerParams.input) {\n        handleConfirmOrDenyWithInput(instance, \"confirm\");\n    } else {\n        confirm(instance, true);\n    }\n};\n/**\n * @param {SweetAlert} instance\n */ const handleDenyButtonClick = (instance)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableButtons();\n    if (innerParams.returnInputValueOnDeny) {\n        handleConfirmOrDenyWithInput(instance, \"deny\");\n    } else {\n        deny(instance, false);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {Function} dismissWith\n */ const handleCancelButtonClick = (instance, dismissWith)=>{\n    instance.disableButtons();\n    dismissWith(DismissReason.cancel);\n};\n/**\n * @param {SweetAlert} instance\n * @param {'confirm' | 'deny'} type\n */ const handleConfirmOrDenyWithInput = (instance, type)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    if (!innerParams.input) {\n        error(`The \"input\" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);\n        return;\n    }\n    const input = instance.getInput();\n    const inputValue = getInputValue(instance, innerParams);\n    if (innerParams.inputValidator) {\n        handleInputValidator(instance, inputValue, type);\n    } else if (input && !input.checkValidity()) {\n        instance.enableButtons();\n        instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);\n    } else if (type === \"deny\") {\n        deny(instance, inputValue);\n    } else {\n        confirm(instance, inputValue);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertInputValue} inputValue\n * @param {'confirm' | 'deny'} type\n */ const handleInputValidator = (instance, inputValue, type)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableInput();\n    const validationPromise = Promise.resolve().then(()=>asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));\n    validationPromise.then((validationMessage)=>{\n        instance.enableButtons();\n        instance.enableInput();\n        if (validationMessage) {\n            instance.showValidationMessage(validationMessage);\n        } else if (type === \"deny\") {\n            deny(instance, inputValue);\n        } else {\n            confirm(instance, inputValue);\n        }\n    });\n};\n/**\n * @param {SweetAlert} instance\n * @param {any} value\n */ const deny = (instance, value)=>{\n    const innerParams = privateProps.innerParams.get(instance || undefined);\n    if (innerParams.showLoaderOnDeny) {\n        showLoading(getDenyButton());\n    }\n    if (innerParams.preDeny) {\n        instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received\n        const preDenyPromise = Promise.resolve().then(()=>asPromise(innerParams.preDeny(value, innerParams.validationMessage)));\n        preDenyPromise.then((preDenyValue)=>{\n            if (preDenyValue === false) {\n                instance.hideLoading();\n                handleAwaitingPromise(instance);\n            } else {\n                instance.close({\n                    isDenied: true,\n                    value: typeof preDenyValue === \"undefined\" ? value : preDenyValue\n                });\n            }\n        }).catch((error)=>rejectWith(instance || undefined, error));\n    } else {\n        instance.close({\n            isDenied: true,\n            value\n        });\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {any} value\n */ const succeedWith = (instance, value)=>{\n    instance.close({\n        isConfirmed: true,\n        value\n    });\n};\n/**\n *\n * @param {SweetAlert} instance\n * @param {string} error\n */ const rejectWith = (instance, error)=>{\n    instance.rejectPromise(error);\n};\n/**\n *\n * @param {SweetAlert} instance\n * @param {any} value\n */ const confirm = (instance, value)=>{\n    const innerParams = privateProps.innerParams.get(instance || undefined);\n    if (innerParams.showLoaderOnConfirm) {\n        showLoading();\n    }\n    if (innerParams.preConfirm) {\n        instance.resetValidationMessage();\n        instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received\n        const preConfirmPromise = Promise.resolve().then(()=>asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));\n        preConfirmPromise.then((preConfirmValue)=>{\n            if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {\n                instance.hideLoading();\n                handleAwaitingPromise(instance);\n            } else {\n                succeedWith(instance, typeof preConfirmValue === \"undefined\" ? value : preConfirmValue);\n            }\n        }).catch((error)=>rejectWith(instance || undefined, error));\n    } else {\n        succeedWith(instance, value);\n    }\n};\n/**\n * Hides loader and shows back the button which was hidden by .showLoading()\n */ function hideLoading() {\n    // do nothing if popup is closed\n    const innerParams = privateProps.innerParams.get(this);\n    if (!innerParams) {\n        return;\n    }\n    const domCache = privateProps.domCache.get(this);\n    hide(domCache.loader);\n    if (isToast()) {\n        if (innerParams.icon) {\n            show(getIcon());\n        }\n    } else {\n        showRelatedButton(domCache);\n    }\n    removeClass([\n        domCache.popup,\n        domCache.actions\n    ], swalClasses.loading);\n    domCache.popup.removeAttribute(\"aria-busy\");\n    domCache.popup.removeAttribute(\"data-loading\");\n    domCache.confirmButton.disabled = false;\n    domCache.denyButton.disabled = false;\n    domCache.cancelButton.disabled = false;\n}\nconst showRelatedButton = (domCache)=>{\n    const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute(\"data-button-to-replace\"));\n    if (buttonToReplace.length) {\n        show(buttonToReplace[0], \"inline-block\");\n    } else if (allButtonsAreHidden()) {\n        hide(domCache.actions);\n    }\n};\n/**\n * Gets the input DOM node, this method works with input parameter.\n *\n * @returns {HTMLInputElement | null}\n */ function getInput() {\n    const innerParams = privateProps.innerParams.get(this);\n    const domCache = privateProps.domCache.get(this);\n    if (!domCache) {\n        return null;\n    }\n    return getInput$1(domCache.popup, innerParams.input);\n}\n/**\n * @param {SweetAlert} instance\n * @param {string[]} buttons\n * @param {boolean} disabled\n */ function setButtonsDisabled(instance, buttons, disabled) {\n    const domCache = privateProps.domCache.get(instance);\n    buttons.forEach((button)=>{\n        domCache[button].disabled = disabled;\n    });\n}\n/**\n * @param {HTMLInputElement | null} input\n * @param {boolean} disabled\n */ function setInputDisabled(input, disabled) {\n    const popup = getPopup();\n    if (!popup || !input) {\n        return;\n    }\n    if (input.type === \"radio\") {\n        /** @type {NodeListOf<HTMLInputElement>} */ const radios = popup.querySelectorAll(`[name=\"${swalClasses.radio}\"]`);\n        for(let i = 0; i < radios.length; i++){\n            radios[i].disabled = disabled;\n        }\n    } else {\n        input.disabled = disabled;\n    }\n}\n/**\n * Enable all the buttons\n * @this {SweetAlert}\n */ function enableButtons() {\n    setButtonsDisabled(this, [\n        \"confirmButton\",\n        \"denyButton\",\n        \"cancelButton\"\n    ], false);\n}\n/**\n * Disable all the buttons\n * @this {SweetAlert}\n */ function disableButtons() {\n    setButtonsDisabled(this, [\n        \"confirmButton\",\n        \"denyButton\",\n        \"cancelButton\"\n    ], true);\n}\n/**\n * Enable the input field\n * @this {SweetAlert}\n */ function enableInput() {\n    setInputDisabled(this.getInput(), false);\n}\n/**\n * Disable the input field\n * @this {SweetAlert}\n */ function disableInput() {\n    setInputDisabled(this.getInput(), true);\n}\n/**\n * Show block with validation message\n *\n * @param {string} error\n * @this {SweetAlert}\n */ function showValidationMessage(error) {\n    const domCache = privateProps.domCache.get(this);\n    const params = privateProps.innerParams.get(this);\n    setInnerHtml(domCache.validationMessage, error);\n    domCache.validationMessage.className = swalClasses[\"validation-message\"];\n    if (params.customClass && params.customClass.validationMessage) {\n        addClass(domCache.validationMessage, params.customClass.validationMessage);\n    }\n    show(domCache.validationMessage);\n    const input = this.getInput();\n    if (input) {\n        input.setAttribute(\"aria-invalid\", \"true\");\n        input.setAttribute(\"aria-describedby\", swalClasses[\"validation-message\"]);\n        focusInput(input);\n        addClass(input, swalClasses.inputerror);\n    }\n}\n/**\n * Hide block with validation message\n *\n * @this {SweetAlert}\n */ function resetValidationMessage() {\n    const domCache = privateProps.domCache.get(this);\n    if (domCache.validationMessage) {\n        hide(domCache.validationMessage);\n    }\n    const input = this.getInput();\n    if (input) {\n        input.removeAttribute(\"aria-invalid\");\n        input.removeAttribute(\"aria-describedby\");\n        removeClass(input, swalClasses.inputerror);\n    }\n}\nconst defaultParams = {\n    title: \"\",\n    titleText: \"\",\n    text: \"\",\n    html: \"\",\n    footer: \"\",\n    icon: undefined,\n    iconColor: undefined,\n    iconHtml: undefined,\n    template: undefined,\n    toast: false,\n    draggable: false,\n    animation: true,\n    theme: \"light\",\n    showClass: {\n        popup: \"swal2-show\",\n        backdrop: \"swal2-backdrop-show\",\n        icon: \"swal2-icon-show\"\n    },\n    hideClass: {\n        popup: \"swal2-hide\",\n        backdrop: \"swal2-backdrop-hide\",\n        icon: \"swal2-icon-hide\"\n    },\n    customClass: {},\n    target: \"body\",\n    color: undefined,\n    backdrop: true,\n    heightAuto: true,\n    allowOutsideClick: true,\n    allowEscapeKey: true,\n    allowEnterKey: true,\n    stopKeydownPropagation: true,\n    keydownListenerCapture: false,\n    showConfirmButton: true,\n    showDenyButton: false,\n    showCancelButton: false,\n    preConfirm: undefined,\n    preDeny: undefined,\n    confirmButtonText: \"OK\",\n    confirmButtonAriaLabel: \"\",\n    confirmButtonColor: undefined,\n    denyButtonText: \"No\",\n    denyButtonAriaLabel: \"\",\n    denyButtonColor: undefined,\n    cancelButtonText: \"Cancel\",\n    cancelButtonAriaLabel: \"\",\n    cancelButtonColor: undefined,\n    buttonsStyling: true,\n    reverseButtons: false,\n    focusConfirm: true,\n    focusDeny: false,\n    focusCancel: false,\n    returnFocus: true,\n    showCloseButton: false,\n    closeButtonHtml: \"&times;\",\n    closeButtonAriaLabel: \"Close this dialog\",\n    loaderHtml: \"\",\n    showLoaderOnConfirm: false,\n    showLoaderOnDeny: false,\n    imageUrl: undefined,\n    imageWidth: undefined,\n    imageHeight: undefined,\n    imageAlt: \"\",\n    timer: undefined,\n    timerProgressBar: false,\n    width: undefined,\n    padding: undefined,\n    background: undefined,\n    input: undefined,\n    inputPlaceholder: \"\",\n    inputLabel: \"\",\n    inputValue: \"\",\n    inputOptions: {},\n    inputAutoFocus: true,\n    inputAutoTrim: true,\n    inputAttributes: {},\n    inputValidator: undefined,\n    returnInputValueOnDeny: false,\n    validationMessage: undefined,\n    grow: false,\n    position: \"center\",\n    progressSteps: [],\n    currentProgressStep: undefined,\n    progressStepsDistance: undefined,\n    willOpen: undefined,\n    didOpen: undefined,\n    didRender: undefined,\n    willClose: undefined,\n    didClose: undefined,\n    didDestroy: undefined,\n    scrollbarPadding: true\n};\nconst updatableParams = [\n    \"allowEscapeKey\",\n    \"allowOutsideClick\",\n    \"background\",\n    \"buttonsStyling\",\n    \"cancelButtonAriaLabel\",\n    \"cancelButtonColor\",\n    \"cancelButtonText\",\n    \"closeButtonAriaLabel\",\n    \"closeButtonHtml\",\n    \"color\",\n    \"confirmButtonAriaLabel\",\n    \"confirmButtonColor\",\n    \"confirmButtonText\",\n    \"currentProgressStep\",\n    \"customClass\",\n    \"denyButtonAriaLabel\",\n    \"denyButtonColor\",\n    \"denyButtonText\",\n    \"didClose\",\n    \"didDestroy\",\n    \"draggable\",\n    \"footer\",\n    \"hideClass\",\n    \"html\",\n    \"icon\",\n    \"iconColor\",\n    \"iconHtml\",\n    \"imageAlt\",\n    \"imageHeight\",\n    \"imageUrl\",\n    \"imageWidth\",\n    \"preConfirm\",\n    \"preDeny\",\n    \"progressSteps\",\n    \"returnFocus\",\n    \"reverseButtons\",\n    \"showCancelButton\",\n    \"showCloseButton\",\n    \"showConfirmButton\",\n    \"showDenyButton\",\n    \"text\",\n    \"title\",\n    \"titleText\",\n    \"theme\",\n    \"willClose\"\n];\n/** @type {Record<string, string | undefined>} */ const deprecatedParams = {\n    allowEnterKey: undefined\n};\nconst toastIncompatibleParams = [\n    \"allowOutsideClick\",\n    \"allowEnterKey\",\n    \"backdrop\",\n    \"draggable\",\n    \"focusConfirm\",\n    \"focusDeny\",\n    \"focusCancel\",\n    \"returnFocus\",\n    \"heightAuto\",\n    \"keydownListenerCapture\"\n];\n/**\n * Is valid parameter\n *\n * @param {string} paramName\n * @returns {boolean}\n */ const isValidParameter = (paramName)=>{\n    return Object.prototype.hasOwnProperty.call(defaultParams, paramName);\n};\n/**\n * Is valid parameter for Swal.update() method\n *\n * @param {string} paramName\n * @returns {boolean}\n */ const isUpdatableParameter = (paramName)=>{\n    return updatableParams.indexOf(paramName) !== -1;\n};\n/**\n * Is deprecated parameter\n *\n * @param {string} paramName\n * @returns {string | undefined}\n */ const isDeprecatedParameter = (paramName)=>{\n    return deprecatedParams[paramName];\n};\n/**\n * @param {string} param\n */ const checkIfParamIsValid = (param)=>{\n    if (!isValidParameter(param)) {\n        warn(`Unknown parameter \"${param}\"`);\n    }\n};\n/**\n * @param {string} param\n */ const checkIfToastParamIsValid = (param)=>{\n    if (toastIncompatibleParams.includes(param)) {\n        warn(`The parameter \"${param}\" is incompatible with toasts`);\n    }\n};\n/**\n * @param {string} param\n */ const checkIfParamIsDeprecated = (param)=>{\n    const isDeprecated = isDeprecatedParameter(param);\n    if (isDeprecated) {\n        warnAboutDeprecation(param, isDeprecated);\n    }\n};\n/**\n * Show relevant warnings for given params\n *\n * @param {SweetAlertOptions} params\n */ const showWarningsForParams = (params)=>{\n    if (params.backdrop === false && params.allowOutsideClick) {\n        warn('\"allowOutsideClick\" parameter requires `backdrop` parameter to be set to `true`');\n    }\n    if (params.theme && ![\n        \"light\",\n        \"dark\",\n        \"auto\",\n        \"borderless\"\n    ].includes(params.theme)) {\n        warn(`Invalid theme \"${params.theme}\". Expected \"light\", \"dark\", \"auto\", or \"borderless\"`);\n    }\n    for(const param in params){\n        checkIfParamIsValid(param);\n        if (params.toast) {\n            checkIfToastParamIsValid(param);\n        }\n        checkIfParamIsDeprecated(param);\n    }\n};\n/**\n * Updates popup parameters.\n *\n * @param {SweetAlertOptions} params\n */ function update(params) {\n    const container = getContainer();\n    const popup = getPopup();\n    const innerParams = privateProps.innerParams.get(this);\n    if (!popup || hasClass(popup, innerParams.hideClass.popup)) {\n        warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);\n        return;\n    }\n    const validUpdatableParams = filterValidParams(params);\n    const updatedParams = Object.assign({}, innerParams, validUpdatableParams);\n    showWarningsForParams(updatedParams);\n    container.dataset[\"swal2Theme\"] = updatedParams.theme;\n    render(this, updatedParams);\n    privateProps.innerParams.set(this, updatedParams);\n    Object.defineProperties(this, {\n        params: {\n            value: Object.assign({}, this.params, params),\n            writable: false,\n            enumerable: true\n        }\n    });\n}\n/**\n * @param {SweetAlertOptions} params\n * @returns {SweetAlertOptions}\n */ const filterValidParams = (params)=>{\n    const validUpdatableParams = {};\n    Object.keys(params).forEach((param)=>{\n        if (isUpdatableParameter(param)) {\n            validUpdatableParams[param] = params[param];\n        } else {\n            warn(`Invalid parameter to update: ${param}`);\n        }\n    });\n    return validUpdatableParams;\n};\n/**\n * Dispose the current SweetAlert2 instance\n */ function _destroy() {\n    const domCache = privateProps.domCache.get(this);\n    const innerParams = privateProps.innerParams.get(this);\n    if (!innerParams) {\n        disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335\n        return; // This instance has already been destroyed\n    }\n    // Check if there is another Swal closing\n    if (domCache.popup && globalState.swalCloseEventFinishedCallback) {\n        globalState.swalCloseEventFinishedCallback();\n        delete globalState.swalCloseEventFinishedCallback;\n    }\n    if (typeof innerParams.didDestroy === \"function\") {\n        innerParams.didDestroy();\n    }\n    globalState.eventEmitter.emit(\"didDestroy\");\n    disposeSwal(this);\n}\n/**\n * @param {SweetAlert} instance\n */ const disposeSwal = (instance)=>{\n    disposeWeakMaps(instance);\n    // Unset this.params so GC will dispose it (#1569)\n    delete instance.params;\n    // Unset globalState props so GC will dispose globalState (#1569)\n    delete globalState.keydownHandler;\n    delete globalState.keydownTarget;\n    // Unset currentInstance\n    delete globalState.currentInstance;\n};\n/**\n * @param {SweetAlert} instance\n */ const disposeWeakMaps = (instance)=>{\n    // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335\n    if (instance.isAwaitingPromise) {\n        unsetWeakMaps(privateProps, instance);\n        instance.isAwaitingPromise = true;\n    } else {\n        unsetWeakMaps(privateMethods, instance);\n        unsetWeakMaps(privateProps, instance);\n        delete instance.isAwaitingPromise;\n        // Unset instance methods\n        delete instance.disableButtons;\n        delete instance.enableButtons;\n        delete instance.getInput;\n        delete instance.disableInput;\n        delete instance.enableInput;\n        delete instance.hideLoading;\n        delete instance.disableLoading;\n        delete instance.showValidationMessage;\n        delete instance.resetValidationMessage;\n        delete instance.close;\n        delete instance.closePopup;\n        delete instance.closeModal;\n        delete instance.closeToast;\n        delete instance.rejectPromise;\n        delete instance.update;\n        delete instance._destroy;\n    }\n};\n/**\n * @param {object} obj\n * @param {SweetAlert} instance\n */ const unsetWeakMaps = (obj, instance)=>{\n    for(const i in obj){\n        obj[i].delete(instance);\n    }\n};\nvar instanceMethods = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    _destroy: _destroy,\n    close: close,\n    closeModal: close,\n    closePopup: close,\n    closeToast: close,\n    disableButtons: disableButtons,\n    disableInput: disableInput,\n    disableLoading: hideLoading,\n    enableButtons: enableButtons,\n    enableInput: enableInput,\n    getInput: getInput,\n    handleAwaitingPromise: handleAwaitingPromise,\n    hideLoading: hideLoading,\n    rejectPromise: rejectPromise,\n    resetValidationMessage: resetValidationMessage,\n    showValidationMessage: showValidationMessage,\n    update: update\n});\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {DomCache} domCache\n * @param {Function} dismissWith\n */ const handlePopupClick = (innerParams, domCache, dismissWith)=>{\n    if (innerParams.toast) {\n        handleToastClick(innerParams, domCache, dismissWith);\n    } else {\n        // Ignore click events that had mousedown on the popup but mouseup on the container\n        // This can happen when the user drags a slider\n        handleModalMousedown(domCache);\n        // Ignore click events that had mousedown on the container but mouseup on the popup\n        handleContainerMousedown(domCache);\n        handleModalClick(innerParams, domCache, dismissWith);\n    }\n};\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {DomCache} domCache\n * @param {Function} dismissWith\n */ const handleToastClick = (innerParams, domCache, dismissWith)=>{\n    // Closing toast by internal click\n    domCache.popup.onclick = ()=>{\n        if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {\n            return;\n        }\n        dismissWith(DismissReason.close);\n    };\n};\n/**\n * @param {SweetAlertOptions} innerParams\n * @returns {boolean}\n */ const isAnyButtonShown = (innerParams)=>{\n    return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);\n};\nlet ignoreOutsideClick = false;\n/**\n * @param {DomCache} domCache\n */ const handleModalMousedown = (domCache)=>{\n    domCache.popup.onmousedown = ()=>{\n        domCache.container.onmouseup = function(e) {\n            domCache.container.onmouseup = ()=>{};\n            // We only check if the mouseup target is the container because usually it doesn't\n            // have any other direct children aside of the popup\n            if (e.target === domCache.container) {\n                ignoreOutsideClick = true;\n            }\n        };\n    };\n};\n/**\n * @param {DomCache} domCache\n */ const handleContainerMousedown = (domCache)=>{\n    domCache.container.onmousedown = (e)=>{\n        // prevent the modal text from being selected on double click on the container (allowOutsideClick: false)\n        if (e.target === domCache.container) {\n            e.preventDefault();\n        }\n        domCache.popup.onmouseup = function(e) {\n            domCache.popup.onmouseup = ()=>{};\n            // We also need to check if the mouseup target is a child of the popup\n            if (e.target === domCache.popup || e.target instanceof HTMLElement && domCache.popup.contains(e.target)) {\n                ignoreOutsideClick = true;\n            }\n        };\n    };\n};\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {DomCache} domCache\n * @param {Function} dismissWith\n */ const handleModalClick = (innerParams, domCache, dismissWith)=>{\n    domCache.container.onclick = (e)=>{\n        if (ignoreOutsideClick) {\n            ignoreOutsideClick = false;\n            return;\n        }\n        if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {\n            dismissWith(DismissReason.backdrop);\n        }\n    };\n};\nconst isJqueryElement = (elem)=>typeof elem === \"object\" && elem.jquery;\nconst isElement = (elem)=>elem instanceof Element || isJqueryElement(elem);\nconst argsToParams = (args)=>{\n    const params = {};\n    if (typeof args[0] === \"object\" && !isElement(args[0])) {\n        Object.assign(params, args[0]);\n    } else {\n        [\n            \"title\",\n            \"html\",\n            \"icon\"\n        ].forEach((name, index)=>{\n            const arg = args[index];\n            if (typeof arg === \"string\" || isElement(arg)) {\n                params[name] = arg;\n            } else if (arg !== undefined) {\n                error(`Unexpected type of ${name}! Expected \"string\" or \"Element\", got ${typeof arg}`);\n            }\n        });\n    }\n    return params;\n};\n/**\n * Main method to create a new SweetAlert2 popup\n *\n * @param  {...SweetAlertOptions} args\n * @returns {Promise<SweetAlertResult>}\n */ function fire() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return new this(...args);\n}\n/**\n * Returns an extended version of `Swal` containing `params` as defaults.\n * Useful for reusing Swal configuration.\n *\n * For example:\n *\n * Before:\n * const textPromptOptions = { input: 'text', showCancelButton: true }\n * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })\n * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })\n *\n * After:\n * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })\n * const {value: firstName} = await TextPrompt('What is your first name?')\n * const {value: lastName} = await TextPrompt('What is your last name?')\n *\n * @param {SweetAlertOptions} mixinParams\n * @returns {SweetAlert}\n */ function mixin(mixinParams) {\n    class MixinSwal extends this {\n        _main(params, priorityMixinParams) {\n            return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));\n        }\n    }\n    // @ts-ignore\n    return MixinSwal;\n}\n/**\n * If `timer` parameter is set, returns number of milliseconds of timer remained.\n * Otherwise, returns undefined.\n *\n * @returns {number | undefined}\n */ const getTimerLeft = ()=>{\n    return globalState.timeout && globalState.timeout.getTimerLeft();\n};\n/**\n * Stop timer. Returns number of milliseconds of timer remained.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @returns {number | undefined}\n */ const stopTimer = ()=>{\n    if (globalState.timeout) {\n        stopTimerProgressBar();\n        return globalState.timeout.stop();\n    }\n};\n/**\n * Resume timer. Returns number of milliseconds of timer remained.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @returns {number | undefined}\n */ const resumeTimer = ()=>{\n    if (globalState.timeout) {\n        const remaining = globalState.timeout.start();\n        animateTimerProgressBar(remaining);\n        return remaining;\n    }\n};\n/**\n * Resume timer. Returns number of milliseconds of timer remained.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @returns {number | undefined}\n */ const toggleTimer = ()=>{\n    const timer = globalState.timeout;\n    return timer && (timer.running ? stopTimer() : resumeTimer());\n};\n/**\n * Increase timer. Returns number of milliseconds of an updated timer.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @param {number} ms\n * @returns {number | undefined}\n */ const increaseTimer = (ms)=>{\n    if (globalState.timeout) {\n        const remaining = globalState.timeout.increase(ms);\n        animateTimerProgressBar(remaining, true);\n        return remaining;\n    }\n};\n/**\n * Check if timer is running. Returns true if timer is running\n * or false if timer is paused or stopped.\n * If `timer` parameter isn't set, returns undefined\n *\n * @returns {boolean}\n */ const isTimerRunning = ()=>{\n    return !!(globalState.timeout && globalState.timeout.isRunning());\n};\nlet bodyClickListenerAdded = false;\nconst clickHandlers = {};\n/**\n * @param {string} attr\n */ function bindClickHandler() {\n    let attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"data-swal-template\";\n    clickHandlers[attr] = this;\n    if (!bodyClickListenerAdded) {\n        document.body.addEventListener(\"click\", bodyClickListener);\n        bodyClickListenerAdded = true;\n    }\n}\nconst bodyClickListener = (event)=>{\n    for(let el = event.target; el && el !== document; el = el.parentNode){\n        for(const attr in clickHandlers){\n            const template = el.getAttribute(attr);\n            if (template) {\n                clickHandlers[attr].fire({\n                    template\n                });\n                return;\n            }\n        }\n    }\n};\n// Source: https://gist.github.com/mudge/5830382?permalink_comment_id=2691957#gistcomment-2691957\nclass EventEmitter {\n    constructor(){\n        /** @type {Events} */ this.events = {};\n    }\n    /**\n   * @param {string} eventName\n   * @returns {EventHandlers}\n   */ _getHandlersByEventName(eventName) {\n        if (typeof this.events[eventName] === \"undefined\") {\n            // not Set because we need to keep the FIFO order\n            // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1748990334\n            this.events[eventName] = [];\n        }\n        return this.events[eventName];\n    }\n    /**\n   * @param {string} eventName\n   * @param {EventHandler} eventHandler\n   */ on(eventName, eventHandler) {\n        const currentHandlers = this._getHandlersByEventName(eventName);\n        if (!currentHandlers.includes(eventHandler)) {\n            currentHandlers.push(eventHandler);\n        }\n    }\n    /**\n   * @param {string} eventName\n   * @param {EventHandler} eventHandler\n   */ once(eventName, eventHandler) {\n        var _this = this;\n        /**\n     * @param {Array} args\n     */ const onceFn = function() {\n            _this.removeListener(eventName, onceFn);\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            eventHandler.apply(_this, args);\n        };\n        this.on(eventName, onceFn);\n    }\n    /**\n   * @param {string} eventName\n   * @param {Array} args\n   */ emit(eventName) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        this._getHandlersByEventName(eventName).forEach(/**\n     * @param {EventHandler} eventHandler\n     */ (eventHandler)=>{\n            try {\n                eventHandler.apply(this, args);\n            } catch (error) {\n                console.error(error);\n            }\n        });\n    }\n    /**\n   * @param {string} eventName\n   * @param {EventHandler} eventHandler\n   */ removeListener(eventName, eventHandler) {\n        const currentHandlers = this._getHandlersByEventName(eventName);\n        const index = currentHandlers.indexOf(eventHandler);\n        if (index > -1) {\n            currentHandlers.splice(index, 1);\n        }\n    }\n    /**\n   * @param {string} eventName\n   */ removeAllListeners(eventName) {\n        if (this.events[eventName] !== undefined) {\n            // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1749239222\n            this.events[eventName].length = 0;\n        }\n    }\n    reset() {\n        this.events = {};\n    }\n}\nglobalState.eventEmitter = new EventEmitter();\n/**\n * @param {string} eventName\n * @param {EventHandler} eventHandler\n */ const on = (eventName, eventHandler)=>{\n    globalState.eventEmitter.on(eventName, eventHandler);\n};\n/**\n * @param {string} eventName\n * @param {EventHandler} eventHandler\n */ const once = (eventName, eventHandler)=>{\n    globalState.eventEmitter.once(eventName, eventHandler);\n};\n/**\n * @param {string} [eventName]\n * @param {EventHandler} [eventHandler]\n */ const off = (eventName, eventHandler)=>{\n    // Remove all handlers for all events\n    if (!eventName) {\n        globalState.eventEmitter.reset();\n        return;\n    }\n    if (eventHandler) {\n        // Remove a specific handler\n        globalState.eventEmitter.removeListener(eventName, eventHandler);\n    } else {\n        // Remove all handlers for a specific event\n        globalState.eventEmitter.removeAllListeners(eventName);\n    }\n};\nvar staticMethods = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    argsToParams: argsToParams,\n    bindClickHandler: bindClickHandler,\n    clickCancel: clickCancel,\n    clickConfirm: clickConfirm,\n    clickDeny: clickDeny,\n    enableLoading: showLoading,\n    fire: fire,\n    getActions: getActions,\n    getCancelButton: getCancelButton,\n    getCloseButton: getCloseButton,\n    getConfirmButton: getConfirmButton,\n    getContainer: getContainer,\n    getDenyButton: getDenyButton,\n    getFocusableElements: getFocusableElements,\n    getFooter: getFooter,\n    getHtmlContainer: getHtmlContainer,\n    getIcon: getIcon,\n    getIconContent: getIconContent,\n    getImage: getImage,\n    getInputLabel: getInputLabel,\n    getLoader: getLoader,\n    getPopup: getPopup,\n    getProgressSteps: getProgressSteps,\n    getTimerLeft: getTimerLeft,\n    getTimerProgressBar: getTimerProgressBar,\n    getTitle: getTitle,\n    getValidationMessage: getValidationMessage,\n    increaseTimer: increaseTimer,\n    isDeprecatedParameter: isDeprecatedParameter,\n    isLoading: isLoading,\n    isTimerRunning: isTimerRunning,\n    isUpdatableParameter: isUpdatableParameter,\n    isValidParameter: isValidParameter,\n    isVisible: isVisible,\n    mixin: mixin,\n    off: off,\n    on: on,\n    once: once,\n    resumeTimer: resumeTimer,\n    showLoading: showLoading,\n    stopTimer: stopTimer,\n    toggleTimer: toggleTimer\n});\nclass Timer {\n    /**\n   * @param {Function} callback\n   * @param {number} delay\n   */ constructor(callback, delay){\n        this.callback = callback;\n        this.remaining = delay;\n        this.running = false;\n        this.start();\n    }\n    /**\n   * @returns {number}\n   */ start() {\n        if (!this.running) {\n            this.running = true;\n            this.started = new Date();\n            this.id = setTimeout(this.callback, this.remaining);\n        }\n        return this.remaining;\n    }\n    /**\n   * @returns {number}\n   */ stop() {\n        if (this.started && this.running) {\n            this.running = false;\n            clearTimeout(this.id);\n            this.remaining -= new Date().getTime() - this.started.getTime();\n        }\n        return this.remaining;\n    }\n    /**\n   * @param {number} n\n   * @returns {number}\n   */ increase(n) {\n        const running = this.running;\n        if (running) {\n            this.stop();\n        }\n        this.remaining += n;\n        if (running) {\n            this.start();\n        }\n        return this.remaining;\n    }\n    /**\n   * @returns {number}\n   */ getTimerLeft() {\n        if (this.running) {\n            this.stop();\n            this.start();\n        }\n        return this.remaining;\n    }\n    /**\n   * @returns {boolean}\n   */ isRunning() {\n        return this.running;\n    }\n}\nconst swalStringParams = [\n    \"swal-title\",\n    \"swal-html\",\n    \"swal-footer\"\n];\n/**\n * @param {SweetAlertOptions} params\n * @returns {SweetAlertOptions}\n */ const getTemplateParams = (params)=>{\n    const template = typeof params.template === \"string\" ? /** @type {HTMLTemplateElement} */ document.querySelector(params.template) : params.template;\n    if (!template) {\n        return {};\n    }\n    /** @type {DocumentFragment} */ const templateContent = template.content;\n    showWarningsForElements(templateContent);\n    const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, any>}\n */ const getSwalParams = (templateContent)=>{\n    /** @type {Record<string, any>} */ const result = {};\n    /** @type {HTMLElement[]} */ const swalParams = Array.from(templateContent.querySelectorAll(\"swal-param\"));\n    swalParams.forEach((param)=>{\n        showWarningsForAttributes(param, [\n            \"name\",\n            \"value\"\n        ]);\n        const paramName = /** @type {keyof SweetAlertOptions} */ param.getAttribute(\"name\");\n        const value = param.getAttribute(\"value\");\n        if (!paramName || !value) {\n            return;\n        }\n        if (typeof defaultParams[paramName] === \"boolean\") {\n            result[paramName] = value !== \"false\";\n        } else if (typeof defaultParams[paramName] === \"object\") {\n            result[paramName] = JSON.parse(value);\n        } else {\n            result[paramName] = value;\n        }\n    });\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, any>}\n */ const getSwalFunctionParams = (templateContent)=>{\n    /** @type {Record<string, any>} */ const result = {};\n    /** @type {HTMLElement[]} */ const swalFunctions = Array.from(templateContent.querySelectorAll(\"swal-function-param\"));\n    swalFunctions.forEach((param)=>{\n        const paramName = /** @type {keyof SweetAlertOptions} */ param.getAttribute(\"name\");\n        const value = param.getAttribute(\"value\");\n        if (!paramName || !value) {\n            return;\n        }\n        result[paramName] = new Function(`return ${value}`)();\n    });\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, any>}\n */ const getSwalButtons = (templateContent)=>{\n    /** @type {Record<string, any>} */ const result = {};\n    /** @type {HTMLElement[]} */ const swalButtons = Array.from(templateContent.querySelectorAll(\"swal-button\"));\n    swalButtons.forEach((button)=>{\n        showWarningsForAttributes(button, [\n            \"type\",\n            \"color\",\n            \"aria-label\"\n        ]);\n        const type = button.getAttribute(\"type\");\n        if (!type || ![\n            \"confirm\",\n            \"cancel\",\n            \"deny\"\n        ].includes(type)) {\n            return;\n        }\n        result[`${type}ButtonText`] = button.innerHTML;\n        result[`show${capitalizeFirstLetter(type)}Button`] = true;\n        if (button.hasAttribute(\"color\")) {\n            result[`${type}ButtonColor`] = button.getAttribute(\"color\");\n        }\n        if (button.hasAttribute(\"aria-label\")) {\n            result[`${type}ButtonAriaLabel`] = button.getAttribute(\"aria-label\");\n        }\n    });\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Pick<SweetAlertOptions, 'imageUrl' | 'imageWidth' | 'imageHeight' | 'imageAlt'>}\n */ const getSwalImage = (templateContent)=>{\n    const result = {};\n    /** @type {HTMLElement | null} */ const image = templateContent.querySelector(\"swal-image\");\n    if (image) {\n        showWarningsForAttributes(image, [\n            \"src\",\n            \"width\",\n            \"height\",\n            \"alt\"\n        ]);\n        if (image.hasAttribute(\"src\")) {\n            result.imageUrl = image.getAttribute(\"src\") || undefined;\n        }\n        if (image.hasAttribute(\"width\")) {\n            result.imageWidth = image.getAttribute(\"width\") || undefined;\n        }\n        if (image.hasAttribute(\"height\")) {\n            result.imageHeight = image.getAttribute(\"height\") || undefined;\n        }\n        if (image.hasAttribute(\"alt\")) {\n            result.imageAlt = image.getAttribute(\"alt\") || undefined;\n        }\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, any>}\n */ const getSwalIcon = (templateContent)=>{\n    const result = {};\n    /** @type {HTMLElement | null} */ const icon = templateContent.querySelector(\"swal-icon\");\n    if (icon) {\n        showWarningsForAttributes(icon, [\n            \"type\",\n            \"color\"\n        ]);\n        if (icon.hasAttribute(\"type\")) {\n            result.icon = icon.getAttribute(\"type\");\n        }\n        if (icon.hasAttribute(\"color\")) {\n            result.iconColor = icon.getAttribute(\"color\");\n        }\n        result.iconHtml = icon.innerHTML;\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, any>}\n */ const getSwalInput = (templateContent)=>{\n    /** @type {Record<string, any>} */ const result = {};\n    /** @type {HTMLElement | null} */ const input = templateContent.querySelector(\"swal-input\");\n    if (input) {\n        showWarningsForAttributes(input, [\n            \"type\",\n            \"label\",\n            \"placeholder\",\n            \"value\"\n        ]);\n        result.input = input.getAttribute(\"type\") || \"text\";\n        if (input.hasAttribute(\"label\")) {\n            result.inputLabel = input.getAttribute(\"label\");\n        }\n        if (input.hasAttribute(\"placeholder\")) {\n            result.inputPlaceholder = input.getAttribute(\"placeholder\");\n        }\n        if (input.hasAttribute(\"value\")) {\n            result.inputValue = input.getAttribute(\"value\");\n        }\n    }\n    /** @type {HTMLElement[]} */ const inputOptions = Array.from(templateContent.querySelectorAll(\"swal-input-option\"));\n    if (inputOptions.length) {\n        result.inputOptions = {};\n        inputOptions.forEach((option)=>{\n            showWarningsForAttributes(option, [\n                \"value\"\n            ]);\n            const optionValue = option.getAttribute(\"value\");\n            if (!optionValue) {\n                return;\n            }\n            const optionName = option.innerHTML;\n            result.inputOptions[optionValue] = optionName;\n        });\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @param {string[]} paramNames\n * @returns {Record<string, any>}\n */ const getSwalStringParams = (templateContent, paramNames)=>{\n    /** @type {Record<string, any>} */ const result = {};\n    for(const i in paramNames){\n        const paramName = paramNames[i];\n        /** @type {HTMLElement | null} */ const tag = templateContent.querySelector(paramName);\n        if (tag) {\n            showWarningsForAttributes(tag, []);\n            result[paramName.replace(/^swal-/, \"\")] = tag.innerHTML.trim();\n        }\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n */ const showWarningsForElements = (templateContent)=>{\n    const allowedElements = swalStringParams.concat([\n        \"swal-param\",\n        \"swal-function-param\",\n        \"swal-button\",\n        \"swal-image\",\n        \"swal-icon\",\n        \"swal-input\",\n        \"swal-input-option\"\n    ]);\n    Array.from(templateContent.children).forEach((el)=>{\n        const tagName = el.tagName.toLowerCase();\n        if (!allowedElements.includes(tagName)) {\n            warn(`Unrecognized element <${tagName}>`);\n        }\n    });\n};\n/**\n * @param {HTMLElement} el\n * @param {string[]} allowedAttributes\n */ const showWarningsForAttributes = (el, allowedAttributes)=>{\n    Array.from(el.attributes).forEach((attribute)=>{\n        if (allowedAttributes.indexOf(attribute.name) === -1) {\n            warn([\n                `Unrecognized attribute \"${attribute.name}\" on <${el.tagName.toLowerCase()}>.`,\n                `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(\", \")}` : \"To set the value, use HTML within the element.\"}`\n            ]);\n        }\n    });\n};\nconst SHOW_CLASS_TIMEOUT = 10;\n/**\n * Open popup, add necessary classes and styles, fix scrollbar\n *\n * @param {SweetAlertOptions} params\n */ const openPopup = (params)=>{\n    const container = getContainer();\n    const popup = getPopup();\n    if (typeof params.willOpen === \"function\") {\n        params.willOpen(popup);\n    }\n    globalState.eventEmitter.emit(\"willOpen\", popup);\n    const bodyStyles = window.getComputedStyle(document.body);\n    const initialBodyOverflow = bodyStyles.overflowY;\n    addClasses(container, popup, params);\n    // scrolling is 'hidden' until animation is done, after that 'auto'\n    setTimeout(()=>{\n        setScrollingVisibility(container, popup);\n    }, SHOW_CLASS_TIMEOUT);\n    if (isModal()) {\n        fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);\n        setAriaHidden();\n    }\n    if (!isToast() && !globalState.previousActiveElement) {\n        globalState.previousActiveElement = document.activeElement;\n    }\n    if (typeof params.didOpen === \"function\") {\n        setTimeout(()=>params.didOpen(popup));\n    }\n    globalState.eventEmitter.emit(\"didOpen\", popup);\n    removeClass(container, swalClasses[\"no-transition\"]);\n};\n/**\n * @param {AnimationEvent} event\n */ const swalOpenAnimationFinished = (event)=>{\n    const popup = getPopup();\n    if (event.target !== popup) {\n        return;\n    }\n    const container = getContainer();\n    popup.removeEventListener(\"animationend\", swalOpenAnimationFinished);\n    popup.removeEventListener(\"transitionend\", swalOpenAnimationFinished);\n    container.style.overflowY = \"auto\";\n};\n/**\n * @param {HTMLElement} container\n * @param {HTMLElement} popup\n */ const setScrollingVisibility = (container, popup)=>{\n    if (hasCssAnimation(popup)) {\n        container.style.overflowY = \"hidden\";\n        popup.addEventListener(\"animationend\", swalOpenAnimationFinished);\n        popup.addEventListener(\"transitionend\", swalOpenAnimationFinished);\n    } else {\n        container.style.overflowY = \"auto\";\n    }\n};\n/**\n * @param {HTMLElement} container\n * @param {boolean} scrollbarPadding\n * @param {string} initialBodyOverflow\n */ const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow)=>{\n    iOSfix();\n    if (scrollbarPadding && initialBodyOverflow !== \"hidden\") {\n        replaceScrollbarWithPadding(initialBodyOverflow);\n    }\n    // sweetalert2/issues/1247\n    setTimeout(()=>{\n        container.scrollTop = 0;\n    });\n};\n/**\n * @param {HTMLElement} container\n * @param {HTMLElement} popup\n * @param {SweetAlertOptions} params\n */ const addClasses = (container, popup, params)=>{\n    addClass(container, params.showClass.backdrop);\n    if (params.animation) {\n        // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059\n        popup.style.setProperty(\"opacity\", \"0\", \"important\");\n        show(popup, \"grid\");\n        setTimeout(()=>{\n            // Animate popup right after showing it\n            addClass(popup, params.showClass.popup);\n            // and remove the opacity workaround\n            popup.style.removeProperty(\"opacity\");\n        }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062\n    } else {\n        show(popup, \"grid\");\n    }\n    addClass([\n        document.documentElement,\n        document.body\n    ], swalClasses.shown);\n    if (params.heightAuto && params.backdrop && !params.toast) {\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses[\"height-auto\"]);\n    }\n};\nvar defaultInputValidators = {\n    /**\n   * @param {string} string\n   * @param {string} [validationMessage]\n   * @returns {Promise<string | void>}\n   */ email: (string, validationMessage)=>{\n        return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid email address\");\n    },\n    /**\n   * @param {string} string\n   * @param {string} [validationMessage]\n   * @returns {Promise<string | void>}\n   */ url: (string, validationMessage)=>{\n        // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013\n        return /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-z]{2,63}\\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid URL\");\n    }\n};\n/**\n * @param {SweetAlertOptions} params\n */ function setDefaultInputValidators(params) {\n    // Use default `inputValidator` for supported input types if not provided\n    if (params.inputValidator) {\n        return;\n    }\n    if (params.input === \"email\") {\n        params.inputValidator = defaultInputValidators[\"email\"];\n    }\n    if (params.input === \"url\") {\n        params.inputValidator = defaultInputValidators[\"url\"];\n    }\n}\n/**\n * @param {SweetAlertOptions} params\n */ function validateCustomTargetElement(params) {\n    // Determine if the custom target element is valid\n    if (!params.target || typeof params.target === \"string\" && !document.querySelector(params.target) || typeof params.target !== \"string\" && !params.target.appendChild) {\n        warn('Target parameter is not valid, defaulting to \"body\"');\n        params.target = \"body\";\n    }\n}\n/**\n * Set type, text and actions on popup\n *\n * @param {SweetAlertOptions} params\n */ function setParameters(params) {\n    setDefaultInputValidators(params);\n    // showLoaderOnConfirm && preConfirm\n    if (params.showLoaderOnConfirm && !params.preConfirm) {\n        warn(\"showLoaderOnConfirm is set to true, but preConfirm is not defined.\\n\" + \"showLoaderOnConfirm should be used together with preConfirm, see usage example:\\n\" + \"https://sweetalert2.github.io/#ajax-request\");\n    }\n    validateCustomTargetElement(params);\n    // Replace newlines with <br> in title\n    if (typeof params.title === \"string\") {\n        params.title = params.title.split(\"\\n\").join(\"<br />\");\n    }\n    init(params);\n}\n/** @type {SweetAlert} */ let currentInstance;\nvar _promise = /*#__PURE__*/ new WeakMap();\nclass SweetAlert {\n    /**\n   * @param {...any} args\n   * @this {SweetAlert}\n   */ constructor(){\n        /**\n     * @type {Promise<SweetAlertResult>}\n     */ _classPrivateFieldInitSpec(this, _promise, void 0);\n        // Prevent run in Node env\n        if (true) {\n            return;\n        }\n        currentInstance = this;\n        // @ts-ignore\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const outerParams = Object.freeze(this.constructor.argsToParams(args));\n        /** @type {Readonly<SweetAlertOptions>} */ this.params = outerParams;\n        /** @type {boolean} */ this.isAwaitingPromise = false;\n        _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));\n    }\n    _main(userParams) {\n        let mixinParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        showWarningsForParams(Object.assign({}, mixinParams, userParams));\n        if (globalState.currentInstance) {\n            const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);\n            const { isAwaitingPromise } = globalState.currentInstance;\n            globalState.currentInstance._destroy();\n            if (!isAwaitingPromise) {\n                swalPromiseResolve({\n                    isDismissed: true\n                });\n            }\n            if (isModal()) {\n                unsetAriaHidden();\n            }\n        }\n        globalState.currentInstance = currentInstance;\n        const innerParams = prepareParams(userParams, mixinParams);\n        setParameters(innerParams);\n        Object.freeze(innerParams);\n        // clear the previous timer\n        if (globalState.timeout) {\n            globalState.timeout.stop();\n            delete globalState.timeout;\n        }\n        // clear the restore focus timeout\n        clearTimeout(globalState.restoreFocusTimeout);\n        const domCache = populateDomCache(currentInstance);\n        render(currentInstance, innerParams);\n        privateProps.innerParams.set(currentInstance, innerParams);\n        return swalPromise(currentInstance, domCache, innerParams);\n    }\n    // `catch` cannot be the name of a module export, so we define our thenable methods here instead\n    then(onFulfilled) {\n        return _classPrivateFieldGet2(_promise, this).then(onFulfilled);\n    }\n    finally(onFinally) {\n        return _classPrivateFieldGet2(_promise, this).finally(onFinally);\n    }\n}\n/**\n * @param {SweetAlert} instance\n * @param {DomCache} domCache\n * @param {SweetAlertOptions} innerParams\n * @returns {Promise}\n */ const swalPromise = (instance, domCache, innerParams)=>{\n    return new Promise((resolve, reject)=>{\n        // functions to handle all closings/dismissals\n        /**\n     * @param {DismissReason} dismiss\n     */ const dismissWith = (dismiss)=>{\n            instance.close({\n                isDismissed: true,\n                dismiss\n            });\n        };\n        privateMethods.swalPromiseResolve.set(instance, resolve);\n        privateMethods.swalPromiseReject.set(instance, reject);\n        domCache.confirmButton.onclick = ()=>{\n            handleConfirmButtonClick(instance);\n        };\n        domCache.denyButton.onclick = ()=>{\n            handleDenyButtonClick(instance);\n        };\n        domCache.cancelButton.onclick = ()=>{\n            handleCancelButtonClick(instance, dismissWith);\n        };\n        domCache.closeButton.onclick = ()=>{\n            dismissWith(DismissReason.close);\n        };\n        handlePopupClick(innerParams, domCache, dismissWith);\n        addKeydownHandler(globalState, innerParams, dismissWith);\n        handleInputOptionsAndValue(instance, innerParams);\n        openPopup(innerParams);\n        setupTimer(globalState, innerParams, dismissWith);\n        initFocus(domCache, innerParams);\n        // Scroll container to top on open (#1247, #1946)\n        setTimeout(()=>{\n            domCache.container.scrollTop = 0;\n        });\n    });\n};\n/**\n * @param {SweetAlertOptions} userParams\n * @param {SweetAlertOptions} mixinParams\n * @returns {SweetAlertOptions}\n */ const prepareParams = (userParams, mixinParams)=>{\n    const templateParams = getTemplateParams(userParams);\n    const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131\n    params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);\n    params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);\n    if (params.animation === false) {\n        params.showClass = {\n            backdrop: \"swal2-noanimation\"\n        };\n        params.hideClass = {};\n    }\n    return params;\n};\n/**\n * @param {SweetAlert} instance\n * @returns {DomCache}\n */ const populateDomCache = (instance)=>{\n    const domCache = {\n        popup: getPopup(),\n        container: getContainer(),\n        actions: getActions(),\n        confirmButton: getConfirmButton(),\n        denyButton: getDenyButton(),\n        cancelButton: getCancelButton(),\n        loader: getLoader(),\n        closeButton: getCloseButton(),\n        validationMessage: getValidationMessage(),\n        progressSteps: getProgressSteps()\n    };\n    privateProps.domCache.set(instance, domCache);\n    return domCache;\n};\n/**\n * @param {GlobalState} globalState\n * @param {SweetAlertOptions} innerParams\n * @param {Function} dismissWith\n */ const setupTimer = (globalState, innerParams, dismissWith)=>{\n    const timerProgressBar = getTimerProgressBar();\n    hide(timerProgressBar);\n    if (innerParams.timer) {\n        globalState.timeout = new Timer(()=>{\n            dismissWith(\"timer\");\n            delete globalState.timeout;\n        }, innerParams.timer);\n        if (innerParams.timerProgressBar) {\n            show(timerProgressBar);\n            applyCustomClass(timerProgressBar, innerParams, \"timerProgressBar\");\n            setTimeout(()=>{\n                if (globalState.timeout && globalState.timeout.running) {\n                    // timer can be already stopped or unset at this point\n                    animateTimerProgressBar(innerParams.timer);\n                }\n            });\n        }\n    }\n};\n/**\n * Initialize focus in the popup:\n *\n * 1. If `toast` is `true`, don't steal focus from the document.\n * 2. Else if there is an [autofocus] element, focus it.\n * 3. Else if `focusConfirm` is `true` and confirm button is visible, focus it.\n * 4. Else if `focusDeny` is `true` and deny button is visible, focus it.\n * 5. Else if `focusCancel` is `true` and cancel button is visible, focus it.\n * 6. Else focus the first focusable element in a popup (if any).\n *\n * @param {DomCache} domCache\n * @param {SweetAlertOptions} innerParams\n */ const initFocus = (domCache, innerParams)=>{\n    if (innerParams.toast) {\n        return;\n    }\n    // TODO: this is dumb, remove `allowEnterKey` param in the next major version\n    if (!callIfFunction(innerParams.allowEnterKey)) {\n        warnAboutDeprecation(\"allowEnterKey\");\n        blurActiveElement();\n        return;\n    }\n    if (focusAutofocus(domCache)) {\n        return;\n    }\n    if (focusButton(domCache, innerParams)) {\n        return;\n    }\n    setFocus(-1, 1);\n};\n/**\n * @param {DomCache} domCache\n * @returns {boolean}\n */ const focusAutofocus = (domCache)=>{\n    const autofocusElements = Array.from(domCache.popup.querySelectorAll(\"[autofocus]\"));\n    for (const autofocusElement of autofocusElements){\n        if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {\n            autofocusElement.focus();\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * @param {DomCache} domCache\n * @param {SweetAlertOptions} innerParams\n * @returns {boolean}\n */ const focusButton = (domCache, innerParams)=>{\n    if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {\n        domCache.denyButton.focus();\n        return true;\n    }\n    if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {\n        domCache.cancelButton.focus();\n        return true;\n    }\n    if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {\n        domCache.confirmButton.focus();\n        return true;\n    }\n    return false;\n};\nconst blurActiveElement = ()=>{\n    if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === \"function\") {\n        document.activeElement.blur();\n    }\n};\n// Dear russian users visiting russian sites. Let's have fun.\nif (false) {}\n// Assign instance methods from src/instanceMethods/*.js to prototype\nSweetAlert.prototype.disableButtons = disableButtons;\nSweetAlert.prototype.enableButtons = enableButtons;\nSweetAlert.prototype.getInput = getInput;\nSweetAlert.prototype.disableInput = disableInput;\nSweetAlert.prototype.enableInput = enableInput;\nSweetAlert.prototype.hideLoading = hideLoading;\nSweetAlert.prototype.disableLoading = hideLoading;\nSweetAlert.prototype.showValidationMessage = showValidationMessage;\nSweetAlert.prototype.resetValidationMessage = resetValidationMessage;\nSweetAlert.prototype.close = close;\nSweetAlert.prototype.closePopup = close;\nSweetAlert.prototype.closeModal = close;\nSweetAlert.prototype.closeToast = close;\nSweetAlert.prototype.rejectPromise = rejectPromise;\nSweetAlert.prototype.update = update;\nSweetAlert.prototype._destroy = _destroy;\n// Assign static methods from src/staticMethods/*.js to constructor\nObject.assign(SweetAlert, staticMethods);\n// Proxy to instance methods to constructor, for now, for backwards compatibility\nObject.keys(instanceMethods).forEach((key)=>{\n    /**\n   * @param {...any} args\n   * @returns {any | undefined}\n   */ SweetAlert[key] = function() {\n        if (currentInstance && currentInstance[key]) {\n            return currentInstance[key](...arguments);\n        }\n        return null;\n    };\n});\nSweetAlert.DismissReason = DismissReason;\nSweetAlert.version = \"11.17.2\";\nconst Swal = SweetAlert;\n// @ts-ignore\nSwal.default = Swal;\n\n\"undefined\" != typeof document && function(e, t) {\n    var n = e.createElement(\"style\");\n    if (e.getElementsByTagName(\"head\")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);\n    else try {\n        n.innerHTML = t;\n    } catch (e) {\n        n.innerText = t;\n    }\n}(document, ':root{--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-footer-border-color: #eee;--swal2-show-animation: swal2-show 0.3s;--swal2-hide-animation: swal2-hide 0.15s forwards;--swal2-input-background: transparent;--swal2-progress-step-background: #add8e6;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666;--swal2-close-button-position: initial;--swal2-close-button-inset: auto;--swal2-close-button-font-size: 2.5em;--swal2-close-button-color: #ccc}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):focus-visible{box-shadow:0 0 0 3px rgba(112,102,224,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):focus-visible{box-shadow:0 0 0 3px rgba(220,55,65,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):focus-visible{box-shadow:0 0 0 3px rgba(110,120,129,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-default-outline:focus-visible{box-shadow:0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);color:inherit;font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){position:var(--swal2-close-button-position);inset:var(--swal2-close-button-inset);z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:var(--swal2-border-radius);background:rgba(0,0,0,0);color:var(--swal2-close-button-color);font-family:monospace;font-size:var(--swal2-close-button-font-size);cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:none;background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:1em 1.6em .3em;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:var(--swal2-input-background);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:var(--swal2-progress-step-background);color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:var(--swal2-progress-step-background)}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:var(--swal2-show-animation)}.swal2-hide{animation:var(--swal2-hide-animation)}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:var(--swal2-background);box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dlZXRhbGVydDIvZGlzdC9zd2VldGFsZXJ0Mi5lc20uYWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0FBR0EsR0FDQSxTQUFTQSxrQkFBa0JDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hDLElBQUksY0FBYyxPQUFPRixJQUFJQSxNQUFNQyxJQUFJRCxFQUFFRyxHQUFHLENBQUNGLElBQUksT0FBT0csVUFBVUMsTUFBTSxHQUFHLElBQUlKLElBQUlDO0lBQ25GLE1BQU0sSUFBSUksVUFBVTtBQUN0QjtBQUNBLFNBQVNDLDJCQUEyQlAsQ0FBQyxFQUFFQyxDQUFDO0lBQ3RDLElBQUlBLEVBQUVFLEdBQUcsQ0FBQ0gsSUFBSSxNQUFNLElBQUlNLFVBQVU7QUFDcEM7QUFDQSxTQUFTRSx1QkFBdUJDLENBQUMsRUFBRUMsQ0FBQztJQUNsQyxPQUFPRCxFQUFFRSxHQUFHLENBQUNaLGtCQUFrQlUsR0FBR0M7QUFDcEM7QUFDQSxTQUFTRSwyQkFBMkJaLENBQUMsRUFBRUMsQ0FBQyxFQUFFUyxDQUFDO0lBQ3pDSCwyQkFBMkJQLEdBQUdDLElBQUlBLEVBQUVZLEdBQUcsQ0FBQ2IsR0FBR1U7QUFDN0M7QUFDQSxTQUFTSSx1QkFBdUJMLENBQUMsRUFBRUMsQ0FBQyxFQUFFSyxDQUFDO0lBQ3JDLE9BQU9OLEVBQUVJLEdBQUcsQ0FBQ2Qsa0JBQWtCVSxHQUFHQyxJQUFJSyxJQUFJQTtBQUM1QztBQUVBLE1BQU1DLHdCQUF3QjtBQUU5Qix3QkFBd0IsR0FDeEIsTUFBTUMsY0FBYyxDQUFDO0FBQ3JCLE1BQU1DLDZCQUE2QjtJQUNqQyxJQUFJRCxZQUFZRSxxQkFBcUIsWUFBWUMsYUFBYTtRQUM1REgsWUFBWUUscUJBQXFCLENBQUNFLEtBQUs7UUFDdkNKLFlBQVlFLHFCQUFxQixHQUFHO0lBQ3RDLE9BQU8sSUFBSUcsU0FBU0MsSUFBSSxFQUFFO1FBQ3hCRCxTQUFTQyxJQUFJLENBQUNGLEtBQUs7SUFDckI7QUFD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R0FBQ3B5QixDQUFBQTtTQUFRLElBQUc7UUFBQ0MsRUFBRTJMLFNBQVMsR0FBQzVMO0lBQUMsRUFBQyxPQUFNRCxHQUFFO1FBQUNFLEVBQUUrVCxTQUFTLEdBQUNoVTtJQUFDO0FBQUMsRUFBRXFCLFVBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92cmlzdG8tbmV4dC8uL25vZGVfbW9kdWxlcy9zd2VldGFsZXJ0Mi9kaXN0L3N3ZWV0YWxlcnQyLmVzbS5hbGwuanM/NjExOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiogc3dlZXRhbGVydDIgdjExLjE3LjJcbiogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cbmZ1bmN0aW9uIF9hc3NlcnRDbGFzc0JyYW5kKGUsIHQsIG4pIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGUgPT09IHQgOiBlLmhhcyh0KSkgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdCA6IG47XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGVsZW1lbnQgaXMgbm90IHByZXNlbnQgb24gdGhpcyBvYmplY3RcIik7XG59XG5mdW5jdGlvbiBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCB0KSB7XG4gIGlmICh0LmhhcyhlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIHRoZSBzYW1lIHByaXZhdGUgZWxlbWVudHMgdHdpY2Ugb24gYW4gb2JqZWN0XCIpO1xufVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihzLCBhKSB7XG4gIHJldHVybiBzLmdldChfYXNzZXJ0Q2xhc3NCcmFuZChzLCBhKSk7XG59XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhlLCB0LCBhKSB7XG4gIF9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uKGUsIHQpLCB0LnNldChlLCBhKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIocywgYSwgcikge1xuICByZXR1cm4gcy5zZXQoX2Fzc2VydENsYXNzQnJhbmQocywgYSksIHIpLCByO1xufVxuXG5jb25zdCBSRVNUT1JFX0ZPQ1VTX1RJTUVPVVQgPSAxMDA7XG5cbi8qKiBAdHlwZSB7R2xvYmFsU3RhdGV9ICovXG5jb25zdCBnbG9iYWxTdGF0ZSA9IHt9O1xuY29uc3QgZm9jdXNQcmV2aW91c0FjdGl2ZUVsZW1lbnQgPSAoKSA9PiB7XG4gIGlmIChnbG9iYWxTdGF0ZS5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXN0b3JlIHByZXZpb3VzIGFjdGl2ZSAoZm9jdXNlZCkgZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0dXJuRm9jdXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5jb25zdCByZXN0b3JlQWN0aXZlRWxlbWVudCA9IHJldHVybkZvY3VzID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGlmICghcmV0dXJuRm9jdXMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHggPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICBjb25zdCB5ID0gd2luZG93LnNjcm9sbFk7XG4gICAgZ2xvYmFsU3RhdGUucmVzdG9yZUZvY3VzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZm9jdXNQcmV2aW91c0FjdGl2ZUVsZW1lbnQoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9LCBSRVNUT1JFX0ZPQ1VTX1RJTUVPVVQpOyAvLyBpc3N1ZXMvOTAwXG5cbiAgICB3aW5kb3cuc2Nyb2xsVG8oeCwgeSk7XG4gIH0pO1xufTtcblxuY29uc3Qgc3dhbFByZWZpeCA9ICdzd2FsMi0nO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8U3dhbENsYXNzLCBzdHJpbmc+fSBTd2FsQ2xhc3Nlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydzdWNjZXNzJyB8ICd3YXJuaW5nJyB8ICdpbmZvJyB8ICdxdWVzdGlvbicgfCAnZXJyb3InfSBTd2FsSWNvblxuICogQHR5cGVkZWYge1JlY29yZDxTd2FsSWNvbiwgc3RyaW5nPn0gU3dhbEljb25zXG4gKi9cblxuLyoqIEB0eXBlIHtTd2FsQ2xhc3NbXX0gKi9cbmNvbnN0IGNsYXNzTmFtZXMgPSBbJ2NvbnRhaW5lcicsICdzaG93bicsICdoZWlnaHQtYXV0bycsICdpb3NmaXgnLCAncG9wdXAnLCAnbW9kYWwnLCAnbm8tYmFja2Ryb3AnLCAnbm8tdHJhbnNpdGlvbicsICd0b2FzdCcsICd0b2FzdC1zaG93bicsICdzaG93JywgJ2hpZGUnLCAnY2xvc2UnLCAndGl0bGUnLCAnaHRtbC1jb250YWluZXInLCAnYWN0aW9ucycsICdjb25maXJtJywgJ2RlbnknLCAnY2FuY2VsJywgJ2RlZmF1bHQtb3V0bGluZScsICdmb290ZXInLCAnaWNvbicsICdpY29uLWNvbnRlbnQnLCAnaW1hZ2UnLCAnaW5wdXQnLCAnZmlsZScsICdyYW5nZScsICdzZWxlY3QnLCAncmFkaW8nLCAnY2hlY2tib3gnLCAnbGFiZWwnLCAndGV4dGFyZWEnLCAnaW5wdXRlcnJvcicsICdpbnB1dC1sYWJlbCcsICd2YWxpZGF0aW9uLW1lc3NhZ2UnLCAncHJvZ3Jlc3Mtc3RlcHMnLCAnYWN0aXZlLXByb2dyZXNzLXN0ZXAnLCAncHJvZ3Jlc3Mtc3RlcCcsICdwcm9ncmVzcy1zdGVwLWxpbmUnLCAnbG9hZGVyJywgJ2xvYWRpbmcnLCAnc3R5bGVkJywgJ3RvcCcsICd0b3Atc3RhcnQnLCAndG9wLWVuZCcsICd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAnY2VudGVyJywgJ2NlbnRlci1zdGFydCcsICdjZW50ZXItZW5kJywgJ2NlbnRlci1sZWZ0JywgJ2NlbnRlci1yaWdodCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0JywgJ2dyb3ctcm93JywgJ2dyb3ctY29sdW1uJywgJ2dyb3ctZnVsbHNjcmVlbicsICdydGwnLCAndGltZXItcHJvZ3Jlc3MtYmFyJywgJ3RpbWVyLXByb2dyZXNzLWJhci1jb250YWluZXInLCAnc2Nyb2xsYmFyLW1lYXN1cmUnLCAnaWNvbi1zdWNjZXNzJywgJ2ljb24td2FybmluZycsICdpY29uLWluZm8nLCAnaWNvbi1xdWVzdGlvbicsICdpY29uLWVycm9yJywgJ2RyYWdnYWJsZScsICdkcmFnZ2luZyddO1xuY29uc3Qgc3dhbENsYXNzZXMgPSBjbGFzc05hbWVzLnJlZHVjZSgoYWNjLCBjbGFzc05hbWUpID0+IHtcbiAgYWNjW2NsYXNzTmFtZV0gPSBzd2FsUHJlZml4ICsgY2xhc3NOYW1lO1xuICByZXR1cm4gYWNjO1xufSwgLyoqIEB0eXBlIHtTd2FsQ2xhc3Nlc30gKi97fSk7XG5cbi8qKiBAdHlwZSB7U3dhbEljb25bXX0gKi9cbmNvbnN0IGljb25zID0gWydzdWNjZXNzJywgJ3dhcm5pbmcnLCAnaW5mbycsICdxdWVzdGlvbicsICdlcnJvciddO1xuY29uc3QgaWNvblR5cGVzID0gaWNvbnMucmVkdWNlKChhY2MsIGljb24pID0+IHtcbiAgYWNjW2ljb25dID0gc3dhbFByZWZpeCArIGljb247XG4gIHJldHVybiBhY2M7XG59LCAvKiogQHR5cGUge1N3YWxJY29uc30gKi97fSk7XG5cbmNvbnN0IGNvbnNvbGVQcmVmaXggPSAnU3dlZXRBbGVydDI6JztcblxuLyoqXG4gKiBDYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBzdHIgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuXG4vKipcbiAqIFN0YW5kYXJkaXplIGNvbnNvbGUgd2FybmluZ3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBtZXNzYWdlXG4gKi9cbmNvbnN0IHdhcm4gPSBtZXNzYWdlID0+IHtcbiAgY29uc29sZS53YXJuKGAke2NvbnNvbGVQcmVmaXh9ICR7dHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnID8gbWVzc2FnZS5qb2luKCcgJykgOiBtZXNzYWdlfWApO1xufTtcblxuLyoqXG4gKiBTdGFuZGFyZGl6ZSBjb25zb2xlIGVycm9yc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmNvbnN0IGVycm9yID0gbWVzc2FnZSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoYCR7Y29uc29sZVByZWZpeH0gJHttZXNzYWdlfWApO1xufTtcblxuLyoqXG4gKiBQcml2YXRlIGdsb2JhbCBzdGF0ZSBmb3IgYHdhcm5PbmNlYFxuICpcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcyA9IFtdO1xuXG4vKipcbiAqIFNob3cgYSBjb25zb2xlIHdhcm5pbmcsIGJ1dCBvbmx5IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gc2hvd25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5jb25zdCB3YXJuT25jZSA9IG1lc3NhZ2UgPT4ge1xuICBpZiAoIXByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcy5pbmNsdWRlcyhtZXNzYWdlKSkge1xuICAgIHByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIHdhcm4obWVzc2FnZSk7XG4gIH1cbn07XG5cbi8qKlxuICogU2hvdyBhIG9uZS10aW1lIGNvbnNvbGUgd2FybmluZyBhYm91dCBkZXByZWNhdGVkIHBhcmFtcy9tZXRob2RzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRlcHJlY2F0ZWRQYXJhbVxuICogQHBhcmFtIHtzdHJpbmc/fSB1c2VJbnN0ZWFkXG4gKi9cbmNvbnN0IHdhcm5BYm91dERlcHJlY2F0aW9uID0gZnVuY3Rpb24gKGRlcHJlY2F0ZWRQYXJhbSkge1xuICBsZXQgdXNlSW5zdGVhZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgd2Fybk9uY2UoYFwiJHtkZXByZWNhdGVkUGFyYW19XCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuJHt1c2VJbnN0ZWFkID8gYCBVc2UgXCIke3VzZUluc3RlYWR9XCIgaW5zdGVhZC5gIDogJyd9YCk7XG59O1xuXG4vKipcbiAqIElmIGBhcmdgIGlzIGEgZnVuY3Rpb24sIGNhbGwgaXQgKHdpdGggbm8gYXJndW1lbnRzIG9yIGNvbnRleHQpIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAqIE90aGVyd2lzZSwganVzdCBwYXNzIHRoZSB2YWx1ZSB0aHJvdWdoXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbiB8IGFueX0gYXJnXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5jb25zdCBjYWxsSWZGdW5jdGlvbiA9IGFyZyA9PiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKCkgOiBhcmc7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFyZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGhhc1RvUHJvbWlzZUZuID0gYXJnID0+IGFyZyAmJiB0eXBlb2YgYXJnLnRvUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYXJnXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICovXG5jb25zdCBhc1Byb21pc2UgPSBhcmcgPT4gaGFzVG9Qcm9taXNlRm4oYXJnKSA/IGFyZy50b1Byb21pc2UoKSA6IFByb21pc2UucmVzb2x2ZShhcmcpO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhcmdcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1Byb21pc2UgPSBhcmcgPT4gYXJnICYmIFByb21pc2UucmVzb2x2ZShhcmcpID09PSBhcmc7XG5cbi8qKlxuICogR2V0cyB0aGUgcG9wdXAgY29udGFpbmVyIHdoaWNoIGNvbnRhaW5zIHRoZSBiYWNrZHJvcCBhbmQgdGhlIHBvcHVwIGl0c2VsZi5cbiAqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRDb250YWluZXIgPSAoKSA9PiBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLmNvbnRhaW5lcn1gKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JTdHJpbmdcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGVsZW1lbnRCeVNlbGVjdG9yID0gc2VsZWN0b3JTdHJpbmcgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgcmV0dXJuIGNvbnRhaW5lciA/IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yU3RyaW5nKSA6IG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGVsZW1lbnRCeUNsYXNzID0gY2xhc3NOYW1lID0+IHtcbiAgcmV0dXJuIGVsZW1lbnRCeVNlbGVjdG9yKGAuJHtjbGFzc05hbWV9YCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldFBvcHVwID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMucG9wdXApO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldEljb24gPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5pY29uKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRJY29uQ29udGVudCA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzWydpY29uLWNvbnRlbnQnXSk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0VGl0bGUgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy50aXRsZSk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0SHRtbENvbnRhaW5lciA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzWydodG1sLWNvbnRhaW5lciddKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRJbWFnZSA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmltYWdlKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRQcm9ncmVzc1N0ZXBzID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXBzJ10pO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldFZhbGlkYXRpb25NZXNzYWdlID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEJ1dHRvbkVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRDb25maXJtQnV0dG9uID0gKCkgPT4gKC8qKiBAdHlwZSB7SFRNTEJ1dHRvbkVsZW1lbnR9ICovZWxlbWVudEJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLmFjdGlvbnN9IC4ke3N3YWxDbGFzc2VzLmNvbmZpcm19YCkpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MQnV0dG9uRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldENhbmNlbEJ1dHRvbiA9ICgpID0+ICgvKiogQHR5cGUge0hUTUxCdXR0b25FbGVtZW50fSAqL2VsZW1lbnRCeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5hY3Rpb25zfSAuJHtzd2FsQ2xhc3Nlcy5jYW5jZWx9YCkpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MQnV0dG9uRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldERlbnlCdXR0b24gPSAoKSA9PiAoLyoqIEB0eXBlIHtIVE1MQnV0dG9uRWxlbWVudH0gKi9lbGVtZW50QnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMuYWN0aW9uc30gLiR7c3dhbENsYXNzZXMuZGVueX1gKSk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0SW5wdXRMYWJlbCA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzWydpbnB1dC1sYWJlbCddKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRMb2FkZXIgPSAoKSA9PiBlbGVtZW50QnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMubG9hZGVyfWApO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldEFjdGlvbnMgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5hY3Rpb25zKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRGb290ZXIgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5mb290ZXIpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldFRpbWVyUHJvZ3Jlc3NCYXIgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyJ10pO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldENsb3NlQnV0dG9uID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMuY2xvc2UpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vamt1cC9mb2N1c2FibGUvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmNvbnN0IGZvY3VzYWJsZSA9IGBcbiAgYVtocmVmXSxcbiAgYXJlYVtocmVmXSxcbiAgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLFxuICBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLFxuICB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksXG4gIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksXG4gIGlmcmFtZSxcbiAgb2JqZWN0LFxuICBlbWJlZCxcbiAgW3RhYmluZGV4PVwiMFwiXSxcbiAgW2NvbnRlbnRlZGl0YWJsZV0sXG4gIGF1ZGlvW2NvbnRyb2xzXSxcbiAgdmlkZW9bY29udHJvbHNdLFxuICBzdW1tYXJ5XG5gO1xuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRbXX1cbiAqL1xuY29uc3QgZ2V0Rm9jdXNhYmxlRWxlbWVudHMgPSAoKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKiogQHR5cGUge05vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+fSAqL1xuICBjb25zdCBmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleCA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3JBbGwoJ1t0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKTpub3QoW3RhYmluZGV4PVwiMFwiXSknKTtcbiAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHNXaXRoVGFiaW5kZXhTb3J0ZWQgPSBBcnJheS5mcm9tKGZvY3VzYWJsZUVsZW1lbnRzV2l0aFRhYmluZGV4KVxuICAvLyBzb3J0IGFjY29yZGluZyB0byB0YWJpbmRleFxuICAuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHRhYmluZGV4QSA9IHBhcnNlSW50KGEuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpIHx8ICcwJyk7XG4gICAgY29uc3QgdGFiaW5kZXhCID0gcGFyc2VJbnQoYi5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgJzAnKTtcbiAgICBpZiAodGFiaW5kZXhBID4gdGFiaW5kZXhCKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHRhYmluZGV4QSA8IHRhYmluZGV4Qikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSk7XG5cbiAgLyoqIEB0eXBlIHtOb2RlTGlzdE9mPEhUTUxFbGVtZW50Pn0gKi9cbiAgY29uc3Qgb3RoZXJGb2N1c2FibGVFbGVtZW50cyA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlKTtcbiAgY29uc3Qgb3RoZXJGb2N1c2FibGVFbGVtZW50c0ZpbHRlcmVkID0gQXJyYXkuZnJvbShvdGhlckZvY3VzYWJsZUVsZW1lbnRzKS5maWx0ZXIoZWwgPT4gZWwuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICE9PSAnLTEnKTtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGZvY3VzYWJsZUVsZW1lbnRzV2l0aFRhYmluZGV4U29ydGVkLmNvbmNhdChvdGhlckZvY3VzYWJsZUVsZW1lbnRzRmlsdGVyZWQpKV0uZmlsdGVyKGVsID0+IGlzVmlzaWJsZSQxKGVsKSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc01vZGFsID0gKCkgPT4ge1xuICByZXR1cm4gaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXMuc2hvd24pICYmICFoYXNDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSkgJiYgIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzVG9hc3QgPSAoKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaGFzQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnRvYXN0KTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzTG9hZGluZyA9ICgpID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBwb3B1cC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbG9hZGluZycpO1xufTtcblxuLyoqXG4gKiBTZWN1cmVseSBzZXQgaW5uZXJIVE1MIG9mIGFuIGVsZW1lbnRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTkyNlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKi9cbmNvbnN0IHNldElubmVySHRtbCA9IChlbGVtLCBodG1sKSA9PiB7XG4gIGVsZW0udGV4dENvbnRlbnQgPSAnJztcbiAgaWYgKGh0bWwpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sLCBgdGV4dC9odG1sYCk7XG4gICAgY29uc3QgaGVhZCA9IHBhcnNlZC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG4gICAgaWYgKGhlYWQpIHtcbiAgICAgIEFycmF5LmZyb20oaGVhZC5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHBhcnNlZC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIEFycmF5LmZyb20oYm9keS5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIEhUTUxBdWRpb0VsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGNoaWxkLmNsb25lTm9kZSh0cnVlKSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjUwN1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGhhc0NsYXNzID0gKGVsZW0sIGNsYXNzTmFtZSkgPT4ge1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGFzc0xpc3QgPSBjbGFzc05hbWUuc3BsaXQoL1xccysvKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTGlzdFtpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW1vdmVDdXN0b21DbGFzc2VzID0gKGVsZW0sIHBhcmFtcykgPT4ge1xuICBBcnJheS5mcm9tKGVsZW0uY2xhc3NMaXN0KS5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgaWYgKCFPYmplY3QudmFsdWVzKHN3YWxDbGFzc2VzKS5pbmNsdWRlcyhjbGFzc05hbWUpICYmICFPYmplY3QudmFsdWVzKGljb25UeXBlcykuaW5jbHVkZXMoY2xhc3NOYW1lKSAmJiAhT2JqZWN0LnZhbHVlcyhwYXJhbXMuc2hvd0NsYXNzIHx8IHt9KS5pbmNsdWRlcyhjbGFzc05hbWUpKSB7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqL1xuY29uc3QgYXBwbHlDdXN0b21DbGFzcyA9IChlbGVtLCBwYXJhbXMsIGNsYXNzTmFtZSkgPT4ge1xuICByZW1vdmVDdXN0b21DbGFzc2VzKGVsZW0sIHBhcmFtcyk7XG4gIGlmICghcGFyYW1zLmN1c3RvbUNsYXNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGN1c3RvbUNsYXNzID0gcGFyYW1zLmN1c3RvbUNsYXNzWygvKiogQHR5cGUge2tleW9mIFN3ZWV0QWxlcnRDdXN0b21DbGFzc30gKi9jbGFzc05hbWUpXTtcbiAgaWYgKCFjdXN0b21DbGFzcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGN1c3RvbUNsYXNzICE9PSAnc3RyaW5nJyAmJiAhY3VzdG9tQ2xhc3MuZm9yRWFjaCkge1xuICAgIHdhcm4oYEludmFsaWQgdHlwZSBvZiBjdXN0b21DbGFzcy4ke2NsYXNzTmFtZX0hIEV4cGVjdGVkIHN0cmluZyBvciBpdGVyYWJsZSBvYmplY3QsIGdvdCBcIiR7dHlwZW9mIGN1c3RvbUNsYXNzfVwiYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkZENsYXNzKGVsZW0sIGN1c3RvbUNsYXNzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3JlbmRlcmVycy9yZW5kZXJJbnB1dCcpLklucHV0Q2xhc3MgfCBTd2VldEFsZXJ0SW5wdXR9IGlucHV0Q2xhc3NcbiAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0SW5wdXQkMSA9IChwb3B1cCwgaW5wdXRDbGFzcykgPT4ge1xuICBpZiAoIWlucHV0Q2xhc3MpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzd2l0Y2ggKGlucHV0Q2xhc3MpIHtcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIHJldHVybiBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5wb3B1cH0gPiAuJHtzd2FsQ2xhc3Nlc1tpbnB1dENsYXNzXX1gKTtcbiAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMuY2hlY2tib3h9IGlucHV0YCk7XG4gICAgY2FzZSAncmFkaW8nOlxuICAgICAgcmV0dXJuIHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnBvcHVwfSA+IC4ke3N3YWxDbGFzc2VzLnJhZGlvfSBpbnB1dDpjaGVja2VkYCkgfHwgcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMucmFkaW99IGlucHV0OmZpcnN0LWNoaWxkYCk7XG4gICAgY2FzZSAncmFuZ2UnOlxuICAgICAgcmV0dXJuIHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnBvcHVwfSA+IC4ke3N3YWxDbGFzc2VzLnJhbmdlfSBpbnB1dGApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMuaW5wdXR9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudCB8IEhUTUxTZWxlY3RFbGVtZW50fSBpbnB1dFxuICovXG5jb25zdCBmb2N1c0lucHV0ID0gaW5wdXQgPT4ge1xuICBpbnB1dC5mb2N1cygpO1xuXG4gIC8vIHBsYWNlIGN1cnNvciBhdCBlbmQgb2YgdGV4dCBpbiB0ZXh0IGlucHV0XG4gIGlmIChpbnB1dC50eXBlICE9PSAnZmlsZScpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzQ1OTE1XG4gICAgY29uc3QgdmFsID0gaW5wdXQudmFsdWU7XG4gICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICBpbnB1dC52YWx1ZSA9IHZhbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgSFRNTEVsZW1lbnRbXSB8IG51bGx9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgdW5kZWZpbmVkfSBjbGFzc0xpc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uXG4gKi9cbmNvbnN0IHRvZ2dsZUNsYXNzID0gKHRhcmdldCwgY2xhc3NMaXN0LCBjb25kaXRpb24pID0+IHtcbiAgaWYgKCF0YXJnZXQgfHwgIWNsYXNzTGlzdCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGNsYXNzTGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBjbGFzc0xpc3QgPSBjbGFzc0xpc3Quc3BsaXQoL1xccysvKS5maWx0ZXIoQm9vbGVhbik7XG4gIH1cbiAgY2xhc3NMaXN0LmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQuZm9yRWFjaChlbGVtID0+IHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgSFRNTEVsZW1lbnRbXSB8IG51bGx9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgdW5kZWZpbmVkfSBjbGFzc0xpc3RcbiAqL1xuY29uc3QgYWRkQ2xhc3MgPSAodGFyZ2V0LCBjbGFzc0xpc3QpID0+IHtcbiAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBjbGFzc0xpc3QsIHRydWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgSFRNTEVsZW1lbnRbXSB8IG51bGx9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgdW5kZWZpbmVkfSBjbGFzc0xpc3RcbiAqL1xuY29uc3QgcmVtb3ZlQ2xhc3MgPSAodGFyZ2V0LCBjbGFzc0xpc3QpID0+IHtcbiAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBjbGFzc0xpc3QsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogR2V0IGRpcmVjdCBjaGlsZCBvZiBhbiBlbGVtZW50IGJ5IGNsYXNzIG5hbWVcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9XG4gKi9cbmNvbnN0IGdldERpcmVjdENoaWxkQnlDbGFzcyA9IChlbGVtLCBjbGFzc05hbWUpID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsZW0uY2hpbGRyZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBoYXNDbGFzcyhjaGlsZCwgY2xhc3NOYW1lKSkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuY29uc3QgYXBwbHlOdW1lcmljYWxTdHlsZSA9IChlbGVtLCBwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgaWYgKHZhbHVlID09PSBgJHtwYXJzZUludCh2YWx1ZSl9YCkge1xuICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSB8fCBwYXJzZUludCh2YWx1ZSkgPT09IDApIHtcbiAgICBlbGVtLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gYCR7dmFsdWV9cHhgIDogdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBudWxsfSBlbGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGxheVxuICovXG5jb25zdCBzaG93ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgbGV0IGRpc3BsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdmbGV4JztcbiAgaWYgKCFlbGVtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBudWxsfSBlbGVtXG4gKi9cbmNvbnN0IGhpZGUgPSBlbGVtID0+IHtcbiAgaWYgKCFlbGVtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IG51bGx9IGVsZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwbGF5XG4gKi9cbmNvbnN0IHNob3dXaGVuSW5uZXJIdG1sUHJlc2VudCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gIGxldCBkaXNwbGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnYmxvY2snO1xuICBpZiAoIWVsZW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgIHRvZ2dsZShlbGVtLCBlbGVtLmlubmVySFRNTCwgZGlzcGxheSk7XG4gIH0pLm9ic2VydmUoZWxlbSwge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuY29uc3Qgc2V0U3R5bGUgPSAocGFyZW50LCBzZWxlY3RvciwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuICBjb25zdCBlbCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgaWYgKGVsKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge2FueX0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGxheVxuICovXG5jb25zdCB0b2dnbGUgPSBmdW5jdGlvbiAoZWxlbSwgY29uZGl0aW9uKSB7XG4gIGxldCBkaXNwbGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnZmxleCc7XG4gIGlmIChjb25kaXRpb24pIHtcbiAgICBzaG93KGVsZW0sIGRpc3BsYXkpO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoZWxlbSk7XG4gIH1cbn07XG5cbi8qKlxuICogYm9ycm93ZWQgZnJvbSBqcXVlcnkgJChlbGVtKS5pcygnOnZpc2libGUnKSBpbXBsZW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBudWxsfSBlbGVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNWaXNpYmxlJDEgPSBlbGVtID0+ICEhKGVsZW0gJiYgKGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBhbGxCdXR0b25zQXJlSGlkZGVuID0gKCkgPT4gIWlzVmlzaWJsZSQxKGdldENvbmZpcm1CdXR0b24oKSkgJiYgIWlzVmlzaWJsZSQxKGdldERlbnlCdXR0b24oKSkgJiYgIWlzVmlzaWJsZSQxKGdldENhbmNlbEJ1dHRvbigpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNTY3JvbGxhYmxlID0gZWxlbSA9PiAhIShlbGVtLnNjcm9sbEhlaWdodCA+IGVsZW0uY2xpZW50SGVpZ2h0KTtcblxuLyoqXG4gKiBib3Jyb3dlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NjM1MjExOVxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBoYXNDc3NBbmltYXRpb24gPSBlbGVtID0+IHtcbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgY29uc3QgYW5pbUR1cmF0aW9uID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdhbmltYXRpb24tZHVyYXRpb24nKSB8fCAnMCcpO1xuICBjb25zdCB0cmFuc0R1cmF0aW9uID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd0cmFuc2l0aW9uLWR1cmF0aW9uJykgfHwgJzAnKTtcbiAgcmV0dXJuIGFuaW1EdXJhdGlvbiA+IDAgfHwgdHJhbnNEdXJhdGlvbiA+IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lclxuICogQHBhcmFtIHtib29sZWFufSByZXNldFxuICovXG5jb25zdCBhbmltYXRlVGltZXJQcm9ncmVzc0JhciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICBsZXQgcmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICBjb25zdCB0aW1lclByb2dyZXNzQmFyID0gZ2V0VGltZXJQcm9ncmVzc0JhcigpO1xuICBpZiAoIXRpbWVyUHJvZ3Jlc3NCYXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzVmlzaWJsZSQxKHRpbWVyUHJvZ3Jlc3NCYXIpKSB7XG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUudHJhbnNpdGlvbiA9IGB3aWR0aCAke3RpbWVyIC8gMTAwMH1zIGxpbmVhcmA7XG4gICAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gJzAlJztcbiAgICB9LCAxMCk7XG4gIH1cbn07XG5jb25zdCBzdG9wVGltZXJQcm9ncmVzc0JhciA9ICgpID0+IHtcbiAgY29uc3QgdGltZXJQcm9ncmVzc0JhciA9IGdldFRpbWVyUHJvZ3Jlc3NCYXIoKTtcbiAgaWYgKCF0aW1lclByb2dyZXNzQmFyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXJXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpbWVyUHJvZ3Jlc3NCYXIpLndpZHRoKTtcbiAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbicpO1xuICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICBjb25zdCB0aW1lclByb2dyZXNzQmFyRnVsbFdpZHRoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGltZXJQcm9ncmVzc0Jhcikud2lkdGgpO1xuICBjb25zdCB0aW1lclByb2dyZXNzQmFyUGVyY2VudCA9IHRpbWVyUHJvZ3Jlc3NCYXJXaWR0aCAvIHRpbWVyUHJvZ3Jlc3NCYXJGdWxsV2lkdGggKiAxMDA7XG4gIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSBgJHt0aW1lclByb2dyZXNzQmFyUGVyY2VudH0lYDtcbn07XG5cbi8qKlxuICogRGV0ZWN0IE5vZGUgZW52XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzTm9kZUVudiA9ICgpID0+IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IHN3ZWV0SFRNTCA9IGBcbiA8ZGl2IGFyaWEtbGFiZWxsZWRieT1cIiR7c3dhbENsYXNzZXMudGl0bGV9XCIgYXJpYS1kZXNjcmliZWRieT1cIiR7c3dhbENsYXNzZXNbJ2h0bWwtY29udGFpbmVyJ119XCIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLnBvcHVwfVwiIHRhYmluZGV4PVwiLTFcIj5cbiAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5jbG9zZX1cIj48L2J1dHRvbj5cbiAgIDx1bCBjbGFzcz1cIiR7c3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXBzJ119XCI+PC91bD5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmljb259XCI+PC9kaXY+XG4gICA8aW1nIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5pbWFnZX1cIiAvPlxuICAgPGgyIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy50aXRsZX1cIiBpZD1cIiR7c3dhbENsYXNzZXMudGl0bGV9XCI+PC9oMj5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzWydodG1sLWNvbnRhaW5lciddfVwiIGlkPVwiJHtzd2FsQ2xhc3Nlc1snaHRtbC1jb250YWluZXInXX1cIj48L2Rpdj5cbiAgIDxpbnB1dCBjbGFzcz1cIiR7c3dhbENsYXNzZXMuaW5wdXR9XCIgaWQ9XCIke3N3YWxDbGFzc2VzLmlucHV0fVwiIC8+XG4gICA8aW5wdXQgdHlwZT1cImZpbGVcIiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuZmlsZX1cIiAvPlxuICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXMucmFuZ2V9XCI+XG4gICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiAvPlxuICAgICA8b3V0cHV0Pjwvb3V0cHV0PlxuICAgPC9kaXY+XG4gICA8c2VsZWN0IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5zZWxlY3R9XCIgaWQ9XCIke3N3YWxDbGFzc2VzLnNlbGVjdH1cIj48L3NlbGVjdD5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLnJhZGlvfVwiPjwvZGl2PlxuICAgPGxhYmVsIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5jaGVja2JveH1cIj5cbiAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwiJHtzd2FsQ2xhc3Nlcy5jaGVja2JveH1cIiAvPlxuICAgICA8c3BhbiBjbGFzcz1cIiR7c3dhbENsYXNzZXMubGFiZWx9XCI+PC9zcGFuPlxuICAgPC9sYWJlbD5cbiAgIDx0ZXh0YXJlYSBjbGFzcz1cIiR7c3dhbENsYXNzZXMudGV4dGFyZWF9XCIgaWQ9XCIke3N3YWxDbGFzc2VzLnRleHRhcmVhfVwiPjwvdGV4dGFyZWE+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1sndmFsaWRhdGlvbi1tZXNzYWdlJ119XCIgaWQ9XCIke3N3YWxDbGFzc2VzWyd2YWxpZGF0aW9uLW1lc3NhZ2UnXX1cIj48L2Rpdj5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmFjdGlvbnN9XCI+XG4gICAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmxvYWRlcn1cIj48L2Rpdj5cbiAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmNvbmZpcm19XCI+PC9idXR0b24+XG4gICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5kZW55fVwiPjwvYnV0dG9uPlxuICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuY2FuY2VsfVwiPjwvYnV0dG9uPlxuICAgPC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5mb290ZXJ9XCI+PC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lciddfVwiPlxuICAgICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyJ119XCI+PC9kaXY+XG4gICA8L2Rpdj5cbiA8L2Rpdj5cbmAucmVwbGFjZSgvKF58XFxuKVxccyovZywgJycpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCByZXNldE9sZENvbnRhaW5lciA9ICgpID0+IHtcbiAgY29uc3Qgb2xkQ29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gIGlmICghb2xkQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG9sZENvbnRhaW5lci5yZW1vdmUoKTtcbiAgcmVtb3ZlQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIFtzd2FsQ2xhc3Nlc1snbm8tYmFja2Ryb3AnXSwgc3dhbENsYXNzZXNbJ3RvYXN0LXNob3duJ10sIHN3YWxDbGFzc2VzWydoYXMtY29sdW1uJ11dKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxID0gKCkgPT4ge1xuICBnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UucmVzZXRWYWxpZGF0aW9uTWVzc2FnZSgpO1xufTtcbmNvbnN0IGFkZElucHV0Q2hhbmdlTGlzdGVuZXJzID0gKCkgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGNvbnN0IGlucHV0ID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5pbnB1dCk7XG4gIGNvbnN0IGZpbGUgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLmZpbGUpO1xuICAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICovXG4gIGNvbnN0IHJhbmdlID0gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucmFuZ2V9IGlucHV0YCk7XG4gIC8qKiBAdHlwZSB7SFRNTE91dHB1dEVsZW1lbnR9ICovXG4gIGNvbnN0IHJhbmdlT3V0cHV0ID0gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucmFuZ2V9IG91dHB1dGApO1xuICBjb25zdCBzZWxlY3QgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnNlbGVjdCk7XG4gIC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudH0gKi9cbiAgY29uc3QgY2hlY2tib3ggPSBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5jaGVja2JveH0gaW5wdXRgKTtcbiAgY29uc3QgdGV4dGFyZWEgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnRleHRhcmVhKTtcbiAgaW5wdXQub25pbnB1dCA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgZmlsZS5vbmNoYW5nZSA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgc2VsZWN0Lm9uY2hhbmdlID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICBjaGVja2JveC5vbmNoYW5nZSA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgdGV4dGFyZWEub25pbnB1dCA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgcmFuZ2Uub25pbnB1dCA9ICgpID0+IHtcbiAgICByZXNldFZhbGlkYXRpb25NZXNzYWdlJDEoKTtcbiAgICByYW5nZU91dHB1dC52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuICB9O1xuICByYW5nZS5vbmNoYW5nZSA9ICgpID0+IHtcbiAgICByZXNldFZhbGlkYXRpb25NZXNzYWdlJDEoKTtcbiAgICByYW5nZU91dHB1dC52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IEhUTUxFbGVtZW50fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAqL1xuY29uc3QgZ2V0VGFyZ2V0ID0gdGFyZ2V0ID0+IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpIDogdGFyZ2V0O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBzZXR1cEFjY2Vzc2liaWxpdHkgPSBwYXJhbXMgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIHBvcHVwLnNldEF0dHJpYnV0ZSgncm9sZScsIHBhcmFtcy50b2FzdCA/ICdhbGVydCcgOiAnZGlhbG9nJyk7XG4gIHBvcHVwLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgcGFyYW1zLnRvYXN0ID8gJ3BvbGl0ZScgOiAnYXNzZXJ0aXZlJyk7XG4gIGlmICghcGFyYW1zLnRvYXN0KSB7XG4gICAgcG9wdXAuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgJ3RydWUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG4gKi9cbmNvbnN0IHNldHVwUlRMID0gdGFyZ2V0RWxlbWVudCA9PiB7XG4gIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXRFbGVtZW50KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgYWRkQ2xhc3MoZ2V0Q29udGFpbmVyKCksIHN3YWxDbGFzc2VzLnJ0bCk7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIG1vZGFsICsgYmFja2Ryb3AgKyBuby13YXIgbWVzc2FnZSBmb3IgUnVzc2lhbnMgdG8gRE9NXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGluaXQgPSBwYXJhbXMgPT4ge1xuICAvLyBDbGVhbiB1cCB0aGUgb2xkIHBvcHVwIGNvbnRhaW5lciBpZiBpdCBleGlzdHNcbiAgY29uc3Qgb2xkQ29udGFpbmVyRXhpc3RlZCA9IHJlc2V0T2xkQ29udGFpbmVyKCk7XG4gIGlmIChpc05vZGVFbnYoKSkge1xuICAgIGVycm9yKCdTd2VldEFsZXJ0MiByZXF1aXJlcyBkb2N1bWVudCB0byBpbml0aWFsaXplJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250YWluZXIuY2xhc3NOYW1lID0gc3dhbENsYXNzZXMuY29udGFpbmVyO1xuICBpZiAob2xkQ29udGFpbmVyRXhpc3RlZCkge1xuICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbJ25vLXRyYW5zaXRpb24nXSk7XG4gIH1cbiAgc2V0SW5uZXJIdG1sKGNvbnRhaW5lciwgc3dlZXRIVE1MKTtcbiAgY29udGFpbmVyLmRhdGFzZXRbJ3N3YWwyVGhlbWUnXSA9IHBhcmFtcy50aGVtZTtcbiAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGdldFRhcmdldChwYXJhbXMudGFyZ2V0KTtcbiAgdGFyZ2V0RWxlbWVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICBzZXR1cEFjY2Vzc2liaWxpdHkocGFyYW1zKTtcbiAgc2V0dXBSVEwodGFyZ2V0RWxlbWVudCk7XG4gIGFkZElucHV0Q2hhbmdlTGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBvYmplY3QgfCBzdHJpbmd9IHBhcmFtXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAqL1xuY29uc3QgcGFyc2VIdG1sVG9Db250YWluZXIgPSAocGFyYW0sIHRhcmdldCkgPT4ge1xuICAvLyBET00gZWxlbWVudFxuICBpZiAocGFyYW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChwYXJhbSk7XG4gIH1cblxuICAvLyBPYmplY3RcbiAgZWxzZSBpZiAodHlwZW9mIHBhcmFtID09PSAnb2JqZWN0Jykge1xuICAgIGhhbmRsZU9iamVjdChwYXJhbSwgdGFyZ2V0KTtcbiAgfVxuXG4gIC8vIFBsYWluIHN0cmluZ1xuICBlbHNlIGlmIChwYXJhbSkge1xuICAgIHNldElubmVySHRtbCh0YXJnZXQsIHBhcmFtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuICovXG5jb25zdCBoYW5kbGVPYmplY3QgPSAocGFyYW0sIHRhcmdldCkgPT4ge1xuICAvLyBKUXVlcnkgZWxlbWVudChzKVxuICBpZiAocGFyYW0uanF1ZXJ5KSB7XG4gICAgaGFuZGxlSnF1ZXJ5RWxlbSh0YXJnZXQsIHBhcmFtKTtcbiAgfVxuXG4gIC8vIEZvciBvdGhlciBvYmplY3RzIHVzZSB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgZWxzZSB7XG4gICAgc2V0SW5uZXJIdG1sKHRhcmdldCwgcGFyYW0udG9TdHJpbmcoKSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge2FueX0gZWxlbVxuICovXG5jb25zdCBoYW5kbGVKcXVlcnlFbGVtID0gKHRhcmdldCwgZWxlbSkgPT4ge1xuICB0YXJnZXQudGV4dENvbnRlbnQgPSAnJztcbiAgaWYgKDAgaW4gZWxlbSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIGluIGVsZW07IGkrKykge1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1baV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW0uY2xvbmVOb2RlKHRydWUpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyQWN0aW9ucyA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGFjdGlvbnMgPSBnZXRBY3Rpb25zKCk7XG4gIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcigpO1xuICBpZiAoIWFjdGlvbnMgfHwgIWxvYWRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEFjdGlvbnMgKGJ1dHRvbnMpIHdyYXBwZXJcbiAgaWYgKCFwYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24gJiYgIXBhcmFtcy5zaG93RGVueUJ1dHRvbiAmJiAhcGFyYW1zLnNob3dDYW5jZWxCdXR0b24pIHtcbiAgICBoaWRlKGFjdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHNob3coYWN0aW9ucyk7XG4gIH1cblxuICAvLyBDdXN0b20gY2xhc3NcbiAgYXBwbHlDdXN0b21DbGFzcyhhY3Rpb25zLCBwYXJhbXMsICdhY3Rpb25zJyk7XG5cbiAgLy8gUmVuZGVyIGFsbCB0aGUgYnV0dG9uc1xuICByZW5kZXJCdXR0b25zKGFjdGlvbnMsIGxvYWRlciwgcGFyYW1zKTtcblxuICAvLyBMb2FkZXJcbiAgc2V0SW5uZXJIdG1sKGxvYWRlciwgcGFyYW1zLmxvYWRlckh0bWwgfHwgJycpO1xuICBhcHBseUN1c3RvbUNsYXNzKGxvYWRlciwgcGFyYW1zLCAnbG9hZGVyJyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGFjdGlvbnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxvYWRlclxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckJ1dHRvbnMoYWN0aW9ucywgbG9hZGVyLCBwYXJhbXMpIHtcbiAgY29uc3QgY29uZmlybUJ1dHRvbiA9IGdldENvbmZpcm1CdXR0b24oKTtcbiAgY29uc3QgZGVueUJ1dHRvbiA9IGdldERlbnlCdXR0b24oKTtcbiAgY29uc3QgY2FuY2VsQnV0dG9uID0gZ2V0Q2FuY2VsQnV0dG9uKCk7XG4gIGlmICghY29uZmlybUJ1dHRvbiB8fCAhZGVueUJ1dHRvbiB8fCAhY2FuY2VsQnV0dG9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVuZGVyIGJ1dHRvbnNcbiAgcmVuZGVyQnV0dG9uKGNvbmZpcm1CdXR0b24sICdjb25maXJtJywgcGFyYW1zKTtcbiAgcmVuZGVyQnV0dG9uKGRlbnlCdXR0b24sICdkZW55JywgcGFyYW1zKTtcbiAgcmVuZGVyQnV0dG9uKGNhbmNlbEJ1dHRvbiwgJ2NhbmNlbCcsIHBhcmFtcyk7XG4gIGhhbmRsZUJ1dHRvbnNTdHlsaW5nKGNvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbiwgcGFyYW1zKTtcbiAgaWYgKHBhcmFtcy5yZXZlcnNlQnV0dG9ucykge1xuICAgIGlmIChwYXJhbXMudG9hc3QpIHtcbiAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGNhbmNlbEJ1dHRvbiwgY29uZmlybUJ1dHRvbik7XG4gICAgICBhY3Rpb25zLmluc2VydEJlZm9yZShkZW55QnV0dG9uLCBjb25maXJtQnV0dG9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9ucy5pbnNlcnRCZWZvcmUoY2FuY2VsQnV0dG9uLCBsb2FkZXIpO1xuICAgICAgYWN0aW9ucy5pbnNlcnRCZWZvcmUoZGVueUJ1dHRvbiwgbG9hZGVyKTtcbiAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGNvbmZpcm1CdXR0b24sIGxvYWRlcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29uZmlybUJ1dHRvblxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGVueUJ1dHRvblxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2FuY2VsQnV0dG9uXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQnV0dG9uc1N0eWxpbmcoY29uZmlybUJ1dHRvbiwgZGVueUJ1dHRvbiwgY2FuY2VsQnV0dG9uLCBwYXJhbXMpIHtcbiAgaWYgKCFwYXJhbXMuYnV0dG9uc1N0eWxpbmcpIHtcbiAgICByZW1vdmVDbGFzcyhbY29uZmlybUJ1dHRvbiwgZGVueUJ1dHRvbiwgY2FuY2VsQnV0dG9uXSwgc3dhbENsYXNzZXMuc3R5bGVkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYWRkQ2xhc3MoW2NvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbl0sIHN3YWxDbGFzc2VzLnN0eWxlZCk7XG5cbiAgLy8gQnV0dG9ucyBiYWNrZ3JvdW5kIGNvbG9yc1xuICBpZiAocGFyYW1zLmNvbmZpcm1CdXR0b25Db2xvcikge1xuICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcGFyYW1zLmNvbmZpcm1CdXR0b25Db2xvcjtcbiAgICBhZGRDbGFzcyhjb25maXJtQnV0dG9uLCBzd2FsQ2xhc3Nlc1snZGVmYXVsdC1vdXRsaW5lJ10pO1xuICB9XG4gIGlmIChwYXJhbXMuZGVueUJ1dHRvbkNvbG9yKSB7XG4gICAgZGVueUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwYXJhbXMuZGVueUJ1dHRvbkNvbG9yO1xuICAgIGFkZENsYXNzKGRlbnlCdXR0b24sIHN3YWxDbGFzc2VzWydkZWZhdWx0LW91dGxpbmUnXSk7XG4gIH1cbiAgaWYgKHBhcmFtcy5jYW5jZWxCdXR0b25Db2xvcikge1xuICAgIGNhbmNlbEJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwYXJhbXMuY2FuY2VsQnV0dG9uQ29sb3I7XG4gICAgYWRkQ2xhc3MoY2FuY2VsQnV0dG9uLCBzd2FsQ2xhc3Nlc1snZGVmYXVsdC1vdXRsaW5lJ10pO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYnV0dG9uXG4gKiBAcGFyYW0geydjb25maXJtJyB8ICdkZW55JyB8ICdjYW5jZWwnfSBidXR0b25UeXBlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQnV0dG9uKGJ1dHRvbiwgYnV0dG9uVHlwZSwgcGFyYW1zKSB7XG4gIGNvbnN0IGJ1dHRvbk5hbWUgPSAvKiogQHR5cGUgeydDb25maXJtJyB8ICdEZW55JyB8ICdDYW5jZWwnfSAqL2NhcGl0YWxpemVGaXJzdExldHRlcihidXR0b25UeXBlKTtcbiAgdG9nZ2xlKGJ1dHRvbiwgcGFyYW1zW2BzaG93JHtidXR0b25OYW1lfUJ1dHRvbmBdLCAnaW5saW5lLWJsb2NrJyk7XG4gIHNldElubmVySHRtbChidXR0b24sIHBhcmFtc1tgJHtidXR0b25UeXBlfUJ1dHRvblRleHRgXSB8fCAnJyk7IC8vIFNldCBjYXB0aW9uIHRleHRcbiAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHBhcmFtc1tgJHtidXR0b25UeXBlfUJ1dHRvbkFyaWFMYWJlbGBdIHx8ICcnKTsgLy8gQVJJQSBsYWJlbFxuXG4gIC8vIEFkZCBidXR0b25zIGN1c3RvbSBjbGFzc2VzXG4gIGJ1dHRvbi5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlc1tidXR0b25UeXBlXTtcbiAgYXBwbHlDdXN0b21DbGFzcyhidXR0b24sIHBhcmFtcywgYCR7YnV0dG9uVHlwZX1CdXR0b25gKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyQ2xvc2VCdXR0b24gPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBjbG9zZUJ1dHRvbiA9IGdldENsb3NlQnV0dG9uKCk7XG4gIGlmICghY2xvc2VCdXR0b24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2V0SW5uZXJIdG1sKGNsb3NlQnV0dG9uLCBwYXJhbXMuY2xvc2VCdXR0b25IdG1sIHx8ICcnKTtcblxuICAvLyBDdXN0b20gY2xhc3NcbiAgYXBwbHlDdXN0b21DbGFzcyhjbG9zZUJ1dHRvbiwgcGFyYW1zLCAnY2xvc2VCdXR0b24nKTtcbiAgdG9nZ2xlKGNsb3NlQnV0dG9uLCBwYXJhbXMuc2hvd0Nsb3NlQnV0dG9uKTtcbiAgY2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgcGFyYW1zLmNsb3NlQnV0dG9uQXJpYUxhYmVsIHx8ICcnKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlckNvbnRhaW5lciA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBoYW5kbGVCYWNrZHJvcFBhcmFtKGNvbnRhaW5lciwgcGFyYW1zLmJhY2tkcm9wKTtcbiAgaGFuZGxlUG9zaXRpb25QYXJhbShjb250YWluZXIsIHBhcmFtcy5wb3NpdGlvbik7XG4gIGhhbmRsZUdyb3dQYXJhbShjb250YWluZXIsIHBhcmFtcy5ncm93KTtcblxuICAvLyBDdXN0b20gY2xhc3NcbiAgYXBwbHlDdXN0b21DbGFzcyhjb250YWluZXIsIHBhcmFtcywgJ2NvbnRhaW5lcicpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ2JhY2tkcm9wJ119IGJhY2tkcm9wXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUJhY2tkcm9wUGFyYW0oY29udGFpbmVyLCBiYWNrZHJvcCkge1xuICBpZiAodHlwZW9mIGJhY2tkcm9wID09PSAnc3RyaW5nJykge1xuICAgIGNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2Ryb3A7XG4gIH0gZWxzZSBpZiAoIWJhY2tkcm9wKSB7XG4gICAgYWRkQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIHN3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc1sncG9zaXRpb24nXX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUG9zaXRpb25QYXJhbShjb250YWluZXIsIHBvc2l0aW9uKSB7XG4gIGlmICghcG9zaXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBvc2l0aW9uIGluIHN3YWxDbGFzc2VzKSB7XG4gICAgYWRkQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlc1twb3NpdGlvbl0pO1xuICB9IGVsc2Uge1xuICAgIHdhcm4oJ1RoZSBcInBvc2l0aW9uXCIgcGFyYW1ldGVyIGlzIG5vdCB2YWxpZCwgZGVmYXVsdGluZyB0byBcImNlbnRlclwiJyk7XG4gICAgYWRkQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlcy5jZW50ZXIpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydncm93J119IGdyb3dcbiAqL1xuZnVuY3Rpb24gaGFuZGxlR3Jvd1BhcmFtKGNvbnRhaW5lciwgZ3Jvdykge1xuICBpZiAoIWdyb3cpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWRkQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlc1tgZ3Jvdy0ke2dyb3d9YF0pO1xufVxuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGBXZWFrTWFwYHMgZm9yIGVhY2ggZWZmZWN0aXZlbHktXCJwcml2YXRlICBwcm9wZXJ0eVwiIHRoYXQgYSBgU3dhbGAgaGFzLlxuICogRm9yIGV4YW1wbGUsIHRvIHNldCB0aGUgcHJpdmF0ZSBwcm9wZXJ0eSBcImZvb1wiIG9mIGB0aGlzYCB0byBcImJhclwiLCB5b3UgY2FuIGBwcml2YXRlUHJvcHMuZm9vLnNldCh0aGlzLCAnYmFyJylgXG4gKiBUaGlzIGlzIHRoZSBhcHByb2FjaCB0aGF0IEJhYmVsIHdpbGwgcHJvYmFibHkgdGFrZSB0byBpbXBsZW1lbnQgcHJpdmF0ZSBtZXRob2RzL2ZpZWxkc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcml2YXRlLW1ldGhvZHNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL3B1bGwvNzU1NVxuICogT25jZSB3ZSBoYXZlIHRoZSBjaGFuZ2VzIGZyb20gdGhhdCBQUiBpbiBCYWJlbCwgYW5kIG91ciBjb3JlIGNsYXNzIGZpdHMgcmVhc29uYWJsZSBpbiAqb25lIG1vZHVsZSpcbiAqICAgdGhlbiB3ZSBjYW4gdXNlIHRoYXQgbGFuZ3VhZ2UgZmVhdHVyZS5cbiAqL1xuXG52YXIgcHJpdmF0ZVByb3BzID0ge1xuICBpbm5lclBhcmFtczogbmV3IFdlYWtNYXAoKSxcbiAgZG9tQ2FjaGU6IG5ldyBXZWFrTWFwKClcbn07XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi8uLi9zd2VldGFsZXJ0Mi5kLnRzXCIvPlxuXG5cbi8qKiBAdHlwZSB7SW5wdXRDbGFzc1tdfSAqL1xuY29uc3QgaW5wdXRDbGFzc2VzID0gWydpbnB1dCcsICdmaWxlJywgJ3JhbmdlJywgJ3NlbGVjdCcsICdyYWRpbycsICdjaGVja2JveCcsICd0ZXh0YXJlYSddO1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJJbnB1dCA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCByZXJlbmRlciA9ICFpbm5lclBhcmFtcyB8fCBwYXJhbXMuaW5wdXQgIT09IGlubmVyUGFyYW1zLmlucHV0O1xuICBpbnB1dENsYXNzZXMuZm9yRWFjaChpbnB1dENsYXNzID0+IHtcbiAgICBjb25zdCBpbnB1dENvbnRhaW5lciA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXNbaW5wdXRDbGFzc10pO1xuICAgIGlmICghaW5wdXRDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgYXR0cmlidXRlc1xuICAgIHNldEF0dHJpYnV0ZXMoaW5wdXRDbGFzcywgcGFyYW1zLmlucHV0QXR0cmlidXRlcyk7XG5cbiAgICAvLyBzZXQgY2xhc3NcbiAgICBpbnB1dENvbnRhaW5lci5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlc1tpbnB1dENsYXNzXTtcbiAgICBpZiAocmVyZW5kZXIpIHtcbiAgICAgIGhpZGUoaW5wdXRDb250YWluZXIpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChwYXJhbXMuaW5wdXQpIHtcbiAgICBpZiAocmVyZW5kZXIpIHtcbiAgICAgIHNob3dJbnB1dChwYXJhbXMpO1xuICAgIH1cbiAgICAvLyBzZXQgY3VzdG9tIGNsYXNzXG4gICAgc2V0Q3VzdG9tQ2xhc3MocGFyYW1zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3Qgc2hvd0lucHV0ID0gcGFyYW1zID0+IHtcbiAgaWYgKCFwYXJhbXMuaW5wdXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFyZW5kZXJJbnB1dFR5cGVbcGFyYW1zLmlucHV0XSkge1xuICAgIGVycm9yKGBVbmV4cGVjdGVkIHR5cGUgb2YgaW5wdXQhIEV4cGVjdGVkICR7T2JqZWN0LmtleXMocmVuZGVySW5wdXRUeXBlKS5qb2luKCcgfCAnKX0sIGdvdCBcIiR7cGFyYW1zLmlucHV0fVwiYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0Q29udGFpbmVyID0gZ2V0SW5wdXRDb250YWluZXIocGFyYW1zLmlucHV0KTtcbiAgaWYgKCFpbnB1dENvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dCA9IHJlbmRlcklucHV0VHlwZVtwYXJhbXMuaW5wdXRdKGlucHV0Q29udGFpbmVyLCBwYXJhbXMpO1xuICBzaG93KGlucHV0Q29udGFpbmVyKTtcblxuICAvLyBpbnB1dCBhdXRvZm9jdXNcbiAgaWYgKHBhcmFtcy5pbnB1dEF1dG9Gb2N1cykge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZm9jdXNJbnB1dChpbnB1dCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICovXG5jb25zdCByZW1vdmVBdHRyaWJ1dGVzID0gaW5wdXQgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0LmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhdHRyTmFtZSA9IGlucHV0LmF0dHJpYnV0ZXNbaV0ubmFtZTtcbiAgICBpZiAoIVsnaWQnLCAndHlwZScsICd2YWx1ZScsICdzdHlsZSddLmluY2x1ZGVzKGF0dHJOYW1lKSkge1xuICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtJbnB1dENsYXNzfSBpbnB1dENsYXNzXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF0dHJpYnV0ZXMnXX0gaW5wdXRBdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IHNldEF0dHJpYnV0ZXMgPSAoaW5wdXRDbGFzcywgaW5wdXRBdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dCA9IGdldElucHV0JDEocG9wdXAsIGlucHV0Q2xhc3MpO1xuICBpZiAoIWlucHV0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlbW92ZUF0dHJpYnV0ZXMoaW5wdXQpO1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gaW5wdXRBdHRyaWJ1dGVzKSB7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIGlucHV0QXR0cmlidXRlc1thdHRyXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHNldEN1c3RvbUNsYXNzID0gcGFyYW1zID0+IHtcbiAgaWYgKCFwYXJhbXMuaW5wdXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXRDb250YWluZXIgPSBnZXRJbnB1dENvbnRhaW5lcihwYXJhbXMuaW5wdXQpO1xuICBpZiAoaW5wdXRDb250YWluZXIpIHtcbiAgICBhcHBseUN1c3RvbUNsYXNzKGlucHV0Q29udGFpbmVyLCBwYXJhbXMsICdpbnB1dCcpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3Qgc2V0SW5wdXRQbGFjZWhvbGRlciA9IChpbnB1dCwgcGFyYW1zKSA9PiB7XG4gIGlmICghaW5wdXQucGxhY2Vob2xkZXIgJiYgcGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpIHtcbiAgICBpbnB1dC5wbGFjZWhvbGRlciA9IHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SW5wdXR9IGlucHV0XG4gKiBAcGFyYW0ge0lucHV0fSBwcmVwZW5kVG9cbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBzZXRJbnB1dExhYmVsID0gKGlucHV0LCBwcmVwZW5kVG8sIHBhcmFtcykgPT4ge1xuICBpZiAocGFyYW1zLmlucHV0TGFiZWwpIHtcbiAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgbGFiZWxDbGFzcyA9IHN3YWxDbGFzc2VzWydpbnB1dC1sYWJlbCddO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgaW5wdXQuaWQpO1xuICAgIGxhYmVsLmNsYXNzTmFtZSA9IGxhYmVsQ2xhc3M7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuY3VzdG9tQ2xhc3MgPT09ICdvYmplY3QnKSB7XG4gICAgICBhZGRDbGFzcyhsYWJlbCwgcGFyYW1zLmN1c3RvbUNsYXNzLmlucHV0TGFiZWwpO1xuICAgIH1cbiAgICBsYWJlbC5pbm5lclRleHQgPSBwYXJhbXMuaW5wdXRMYWJlbDtcbiAgICBwcmVwZW5kVG8uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdiZWZvcmViZWdpbicsIGxhYmVsKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRJbnB1dH0gaW5wdXRUeXBlXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9XG4gKi9cbmNvbnN0IGdldElucHV0Q29udGFpbmVyID0gaW5wdXRUeXBlID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzWygvKiogQHR5cGUge1N3YWxDbGFzc30gKi9pbnB1dFR5cGUpXSB8fCBzd2FsQ2xhc3Nlcy5pbnB1dCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudCB8IEhUTUxPdXRwdXRFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsdWUnXX0gaW5wdXRWYWx1ZVxuICovXG5jb25zdCBjaGVja0FuZFNldElucHV0VmFsdWUgPSAoaW5wdXQsIGlucHV0VmFsdWUpID0+IHtcbiAgaWYgKFsnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZiBpbnB1dFZhbHVlKSkge1xuICAgIGlucHV0LnZhbHVlID0gYCR7aW5wdXRWYWx1ZX1gO1xuICB9IGVsc2UgaWYgKCFpc1Byb21pc2UoaW5wdXRWYWx1ZSkpIHtcbiAgICB3YXJuKGBVbmV4cGVjdGVkIHR5cGUgb2YgaW5wdXRWYWx1ZSEgRXhwZWN0ZWQgXCJzdHJpbmdcIiwgXCJudW1iZXJcIiBvciBcIlByb21pc2VcIiwgZ290IFwiJHt0eXBlb2YgaW5wdXRWYWx1ZX1cImApO1xuICB9XG59O1xuXG4vKiogQHR5cGUge1JlY29yZDxTd2VldEFsZXJ0SW5wdXQsIChpbnB1dDogSW5wdXQgfCBIVE1MRWxlbWVudCwgcGFyYW1zOiBTd2VldEFsZXJ0T3B0aW9ucykgPT4gSW5wdXQ+fSAqL1xuY29uc3QgcmVuZGVySW5wdXRUeXBlID0ge307XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAqL1xucmVuZGVySW5wdXRUeXBlLnRleHQgPSByZW5kZXJJbnB1dFR5cGUuZW1haWwgPSByZW5kZXJJbnB1dFR5cGUucGFzc3dvcmQgPSByZW5kZXJJbnB1dFR5cGUubnVtYmVyID0gcmVuZGVySW5wdXRUeXBlLnRlbCA9IHJlbmRlcklucHV0VHlwZS51cmwgPSByZW5kZXJJbnB1dFR5cGUuc2VhcmNoID0gcmVuZGVySW5wdXRUeXBlLmRhdGUgPSByZW5kZXJJbnB1dFR5cGVbJ2RhdGV0aW1lLWxvY2FsJ10gPSByZW5kZXJJbnB1dFR5cGUudGltZSA9IHJlbmRlcklucHV0VHlwZS53ZWVrID0gcmVuZGVySW5wdXRUeXBlLm1vbnRoID0gLyoqIEB0eXBlIHsoaW5wdXQ6IElucHV0IHwgSFRNTEVsZW1lbnQsIHBhcmFtczogU3dlZXRBbGVydE9wdGlvbnMpID0+IElucHV0fSAqL1xuKGlucHV0LCBwYXJhbXMpID0+IHtcbiAgY2hlY2tBbmRTZXRJbnB1dFZhbHVlKGlucHV0LCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gIHNldElucHV0TGFiZWwoaW5wdXQsIGlucHV0LCBwYXJhbXMpO1xuICBzZXRJbnB1dFBsYWNlaG9sZGVyKGlucHV0LCBwYXJhbXMpO1xuICBpbnB1dC50eXBlID0gcGFyYW1zLmlucHV0O1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gKi9cbnJlbmRlcklucHV0VHlwZS5maWxlID0gKGlucHV0LCBwYXJhbXMpID0+IHtcbiAgc2V0SW5wdXRMYWJlbChpbnB1dCwgaW5wdXQsIHBhcmFtcyk7XG4gIHNldElucHV0UGxhY2Vob2xkZXIoaW5wdXQsIHBhcmFtcyk7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSByYW5nZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAqL1xucmVuZGVySW5wdXRUeXBlLnJhbmdlID0gKHJhbmdlLCBwYXJhbXMpID0+IHtcbiAgY29uc3QgcmFuZ2VJbnB1dCA9IHJhbmdlLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gIGNvbnN0IHJhbmdlT3V0cHV0ID0gcmFuZ2UucXVlcnlTZWxlY3Rvcignb3V0cHV0Jyk7XG4gIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZShyYW5nZUlucHV0LCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gIHJhbmdlSW5wdXQudHlwZSA9IHBhcmFtcy5pbnB1dDtcbiAgY2hlY2tBbmRTZXRJbnB1dFZhbHVlKHJhbmdlT3V0cHV0LCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gIHNldElucHV0TGFiZWwocmFuZ2VJbnB1dCwgcmFuZ2UsIHBhcmFtcyk7XG4gIHJldHVybiByYW5nZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqIEByZXR1cm5zIHtIVE1MU2VsZWN0RWxlbWVudH1cbiAqL1xucmVuZGVySW5wdXRUeXBlLnNlbGVjdCA9IChzZWxlY3QsIHBhcmFtcykgPT4ge1xuICBzZWxlY3QudGV4dENvbnRlbnQgPSAnJztcbiAgaWYgKHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBzZXRJbm5lckh0bWwocGxhY2Vob2xkZXIsIHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyKTtcbiAgICBwbGFjZWhvbGRlci52YWx1ZSA9ICcnO1xuICAgIHBsYWNlaG9sZGVyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICBwbGFjZWhvbGRlci5zZWxlY3RlZCA9IHRydWU7XG4gICAgc2VsZWN0LmFwcGVuZENoaWxkKHBsYWNlaG9sZGVyKTtcbiAgfVxuICBzZXRJbnB1dExhYmVsKHNlbGVjdCwgc2VsZWN0LCBwYXJhbXMpO1xuICByZXR1cm4gc2VsZWN0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IHJhZGlvXG4gKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAqL1xucmVuZGVySW5wdXRUeXBlLnJhZGlvID0gcmFkaW8gPT4ge1xuICByYWRpby50ZXh0Q29udGVudCA9ICcnO1xuICByZXR1cm4gcmFkaW87XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTExhYmVsRWxlbWVudH0gY2hlY2tib3hDb250YWluZXJcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gKi9cbnJlbmRlcklucHV0VHlwZS5jaGVja2JveCA9IChjaGVja2JveENvbnRhaW5lciwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGNoZWNrYm94ID0gZ2V0SW5wdXQkMShnZXRQb3B1cCgpLCAnY2hlY2tib3gnKTtcbiAgY2hlY2tib3gudmFsdWUgPSAnMSc7XG4gIGNoZWNrYm94LmNoZWNrZWQgPSBCb29sZWFuKHBhcmFtcy5pbnB1dFZhbHVlKTtcbiAgY29uc3QgbGFiZWwgPSBjaGVja2JveENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gIHNldElubmVySHRtbChsYWJlbCwgcGFyYW1zLmlucHV0UGxhY2Vob2xkZXIgfHwgcGFyYW1zLmlucHV0TGFiZWwpO1xuICByZXR1cm4gY2hlY2tib3g7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFRleHRBcmVhRWxlbWVudH0gdGV4dGFyZWFcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHJldHVybnMge0hUTUxUZXh0QXJlYUVsZW1lbnR9XG4gKi9cbnJlbmRlcklucHV0VHlwZS50ZXh0YXJlYSA9ICh0ZXh0YXJlYSwgcGFyYW1zKSA9PiB7XG4gIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZSh0ZXh0YXJlYSwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICBzZXRJbnB1dFBsYWNlaG9sZGVyKHRleHRhcmVhLCBwYXJhbXMpO1xuICBzZXRJbnB1dExhYmVsKHRleHRhcmVhLCB0ZXh0YXJlYSwgcGFyYW1zKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGNvbnN0IGdldE1hcmdpbiA9IGVsID0+IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5tYXJnaW5SaWdodCk7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yMjkxXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTY5OVxuICAgIGlmICgnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICBjb25zdCBpbml0aWFsUG9wdXBXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGdldFBvcHVwKCkpLndpZHRoKTtcbiAgICAgIGNvbnN0IHRleHRhcmVhUmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGV4YXJlYSBpcyBzdGlsbCBpbiBkb2N1bWVudCAoaS5lLiBwb3B1cCB3YXNuJ3QgY2xvc2VkIGluIHRoZSBtZWFudGltZSlcbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRleHRhcmVhKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0YXJlYVdpZHRoID0gdGV4dGFyZWEub2Zmc2V0V2lkdGggKyBnZXRNYXJnaW4odGV4dGFyZWEpO1xuICAgICAgICBpZiAodGV4dGFyZWFXaWR0aCA+IGluaXRpYWxQb3B1cFdpZHRoKSB7XG4gICAgICAgICAgZ2V0UG9wdXAoKS5zdHlsZS53aWR0aCA9IGAke3RleHRhcmVhV2lkdGh9cHhgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUoZ2V0UG9wdXAoKSwgJ3dpZHRoJywgcGFyYW1zLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKHRleHRhcmVhUmVzaXplSGFuZGxlcikub2JzZXJ2ZSh0ZXh0YXJlYSwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnc3R5bGUnXVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRleHRhcmVhO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyQ29udGVudCA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGh0bWxDb250YWluZXIgPSBnZXRIdG1sQ29udGFpbmVyKCk7XG4gIGlmICghaHRtbENvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBzaG93V2hlbklubmVySHRtbFByZXNlbnQoaHRtbENvbnRhaW5lcik7XG4gIGFwcGx5Q3VzdG9tQ2xhc3MoaHRtbENvbnRhaW5lciwgcGFyYW1zLCAnaHRtbENvbnRhaW5lcicpO1xuXG4gIC8vIENvbnRlbnQgYXMgSFRNTFxuICBpZiAocGFyYW1zLmh0bWwpIHtcbiAgICBwYXJzZUh0bWxUb0NvbnRhaW5lcihwYXJhbXMuaHRtbCwgaHRtbENvbnRhaW5lcik7XG4gICAgc2hvdyhodG1sQ29udGFpbmVyLCAnYmxvY2snKTtcbiAgfVxuXG4gIC8vIENvbnRlbnQgYXMgcGxhaW4gdGV4dFxuICBlbHNlIGlmIChwYXJhbXMudGV4dCkge1xuICAgIGh0bWxDb250YWluZXIudGV4dENvbnRlbnQgPSBwYXJhbXMudGV4dDtcbiAgICBzaG93KGh0bWxDb250YWluZXIsICdibG9jaycpO1xuICB9XG5cbiAgLy8gTm8gY29udGVudFxuICBlbHNlIHtcbiAgICBoaWRlKGh0bWxDb250YWluZXIpO1xuICB9XG4gIHJlbmRlcklucHV0KGluc3RhbmNlLCBwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyRm9vdGVyID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgY29uc3QgZm9vdGVyID0gZ2V0Rm9vdGVyKCk7XG4gIGlmICghZm9vdGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNob3dXaGVuSW5uZXJIdG1sUHJlc2VudChmb290ZXIpO1xuICB0b2dnbGUoZm9vdGVyLCBwYXJhbXMuZm9vdGVyLCAnYmxvY2snKTtcbiAgaWYgKHBhcmFtcy5mb290ZXIpIHtcbiAgICBwYXJzZUh0bWxUb0NvbnRhaW5lcihwYXJhbXMuZm9vdGVyLCBmb290ZXIpO1xuICB9XG5cbiAgLy8gQ3VzdG9tIGNsYXNzXG4gIGFwcGx5Q3VzdG9tQ2xhc3MoZm9vdGVyLCBwYXJhbXMsICdmb290ZXInKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlckljb24gPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCBpY29uID0gZ2V0SWNvbigpO1xuICBpZiAoIWljb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiB0aGUgZ2l2ZW4gaWNvbiBhbHJlYWR5IHJlbmRlcmVkLCBhcHBseSB0aGUgc3R5bGluZyB3aXRob3V0IHJlLXJlbmRlcmluZyB0aGUgaWNvblxuICBpZiAoaW5uZXJQYXJhbXMgJiYgcGFyYW1zLmljb24gPT09IGlubmVyUGFyYW1zLmljb24pIHtcbiAgICAvLyBDdXN0b20gb3IgZGVmYXVsdCBjb250ZW50XG4gICAgc2V0Q29udGVudChpY29uLCBwYXJhbXMpO1xuICAgIGFwcGx5U3R5bGVzKGljb24sIHBhcmFtcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghcGFyYW1zLmljb24gJiYgIXBhcmFtcy5pY29uSHRtbCkge1xuICAgIGhpZGUoaWNvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJhbXMuaWNvbiAmJiBPYmplY3Qua2V5cyhpY29uVHlwZXMpLmluZGV4T2YocGFyYW1zLmljb24pID09PSAtMSkge1xuICAgIGVycm9yKGBVbmtub3duIGljb24hIEV4cGVjdGVkIFwic3VjY2Vzc1wiLCBcImVycm9yXCIsIFwid2FybmluZ1wiLCBcImluZm9cIiBvciBcInF1ZXN0aW9uXCIsIGdvdCBcIiR7cGFyYW1zLmljb259XCJgKTtcbiAgICBoaWRlKGljb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBzaG93KGljb24pO1xuXG4gIC8vIEN1c3RvbSBvciBkZWZhdWx0IGNvbnRlbnRcbiAgc2V0Q29udGVudChpY29uLCBwYXJhbXMpO1xuICBhcHBseVN0eWxlcyhpY29uLCBwYXJhbXMpO1xuXG4gIC8vIEFuaW1hdGUgaWNvblxuICBhZGRDbGFzcyhpY29uLCBwYXJhbXMuc2hvd0NsYXNzICYmIHBhcmFtcy5zaG93Q2xhc3MuaWNvbik7XG5cbiAgLy8gUmUtYWRqdXN0IHRoZSBzdWNjZXNzIGljb24gb24gc3lzdGVtIHRoZW1lIGNoYW5nZVxuICBjb25zdCBjb2xvclNjaGVtZVF1ZXJ5TGlzdCA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyk7XG4gIGNvbG9yU2NoZW1lUXVlcnlMaXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGFkanVzdFN1Y2Nlc3NJY29uQmFja2dyb3VuZENvbG9yKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaWNvblxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGFwcGx5U3R5bGVzID0gKGljb24sIHBhcmFtcykgPT4ge1xuICBmb3IgKGNvbnN0IFtpY29uVHlwZSwgaWNvbkNsYXNzTmFtZV0gb2YgT2JqZWN0LmVudHJpZXMoaWNvblR5cGVzKSkge1xuICAgIGlmIChwYXJhbXMuaWNvbiAhPT0gaWNvblR5cGUpIHtcbiAgICAgIHJlbW92ZUNsYXNzKGljb24sIGljb25DbGFzc05hbWUpO1xuICAgIH1cbiAgfVxuICBhZGRDbGFzcyhpY29uLCBwYXJhbXMuaWNvbiAmJiBpY29uVHlwZXNbcGFyYW1zLmljb25dKTtcblxuICAvLyBJY29uIGNvbG9yXG4gIHNldENvbG9yKGljb24sIHBhcmFtcyk7XG5cbiAgLy8gU3VjY2VzcyBpY29uIGJhY2tncm91bmQgY29sb3JcbiAgYWRqdXN0U3VjY2Vzc0ljb25CYWNrZ3JvdW5kQ29sb3IoKTtcblxuICAvLyBDdXN0b20gY2xhc3NcbiAgYXBwbHlDdXN0b21DbGFzcyhpY29uLCBwYXJhbXMsICdpY29uJyk7XG59O1xuXG4vLyBBZGp1c3Qgc3VjY2VzcyBpY29uIGJhY2tncm91bmQgY29sb3IgdG8gbWF0Y2ggdGhlIHBvcHVwIGJhY2tncm91bmQgY29sb3JcbmNvbnN0IGFkanVzdFN1Y2Nlc3NJY29uQmFja2dyb3VuZENvbG9yID0gKCkgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghcG9wdXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcG9wdXBCYWNrZ3JvdW5kQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwb3B1cCkuZ2V0UHJvcGVydHlWYWx1ZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAvKiogQHR5cGUge05vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+fSAqL1xuICBjb25zdCBzdWNjZXNzSWNvblBhcnRzID0gcG9wdXAucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVdLCAuc3dhbDItc3VjY2Vzcy1maXgnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWNjZXNzSWNvblBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3VjY2Vzc0ljb25QYXJ0c1tpXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwb3B1cEJhY2tncm91bmRDb2xvcjtcbiAgfVxufTtcbmNvbnN0IHN1Y2Nlc3NJY29uSHRtbCA9IGBcbiAgPGRpdiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZS1sZWZ0XCI+PC9kaXY+XG4gIDxzcGFuIGNsYXNzPVwic3dhbDItc3VjY2Vzcy1saW5lLXRpcFwiPjwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJzd2FsMi1zdWNjZXNzLWxpbmUtbG9uZ1wiPjwvc3Bhbj5cbiAgPGRpdiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtcmluZ1wiPjwvZGl2PiA8ZGl2IGNsYXNzPVwic3dhbDItc3VjY2Vzcy1maXhcIj48L2Rpdj5cbiAgPGRpdiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZS1yaWdodFwiPjwvZGl2PlxuYDtcbmNvbnN0IGVycm9ySWNvbkh0bWwgPSBgXG4gIDxzcGFuIGNsYXNzPVwic3dhbDIteC1tYXJrXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJzd2FsMi14LW1hcmstbGluZS1sZWZ0XCI+PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwic3dhbDIteC1tYXJrLWxpbmUtcmlnaHRcIj48L3NwYW4+XG4gIDwvc3Bhbj5cbmA7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaWNvblxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHNldENvbnRlbnQgPSAoaWNvbiwgcGFyYW1zKSA9PiB7XG4gIGlmICghcGFyYW1zLmljb24gJiYgIXBhcmFtcy5pY29uSHRtbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb2xkQ29udGVudCA9IGljb24uaW5uZXJIVE1MO1xuICBsZXQgbmV3Q29udGVudCA9ICcnO1xuICBpZiAocGFyYW1zLmljb25IdG1sKSB7XG4gICAgbmV3Q29udGVudCA9IGljb25Db250ZW50KHBhcmFtcy5pY29uSHRtbCk7XG4gIH0gZWxzZSBpZiAocGFyYW1zLmljb24gPT09ICdzdWNjZXNzJykge1xuICAgIG5ld0NvbnRlbnQgPSBzdWNjZXNzSWNvbkh0bWw7XG4gICAgb2xkQ29udGVudCA9IG9sZENvbnRlbnQucmVwbGFjZSgvIHN0eWxlPVwiLio/XCIvZywgJycpOyAvLyB1bmRvIGFkanVzdFN1Y2Nlc3NJY29uQmFja2dyb3VuZENvbG9yKClcbiAgfSBlbHNlIGlmIChwYXJhbXMuaWNvbiA9PT0gJ2Vycm9yJykge1xuICAgIG5ld0NvbnRlbnQgPSBlcnJvckljb25IdG1sO1xuICB9IGVsc2UgaWYgKHBhcmFtcy5pY29uKSB7XG4gICAgY29uc3QgZGVmYXVsdEljb25IdG1sID0ge1xuICAgICAgcXVlc3Rpb246ICc/JyxcbiAgICAgIHdhcm5pbmc6ICchJyxcbiAgICAgIGluZm86ICdpJ1xuICAgIH07XG4gICAgbmV3Q29udGVudCA9IGljb25Db250ZW50KGRlZmF1bHRJY29uSHRtbFtwYXJhbXMuaWNvbl0pO1xuICB9XG4gIGlmIChvbGRDb250ZW50LnRyaW0oKSAhPT0gbmV3Q29udGVudC50cmltKCkpIHtcbiAgICBzZXRJbm5lckh0bWwoaWNvbiwgbmV3Q29udGVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaWNvblxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHNldENvbG9yID0gKGljb24sIHBhcmFtcykgPT4ge1xuICBpZiAoIXBhcmFtcy5pY29uQ29sb3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWNvbi5zdHlsZS5jb2xvciA9IHBhcmFtcy5pY29uQ29sb3I7XG4gIGljb24uc3R5bGUuYm9yZGVyQ29sb3IgPSBwYXJhbXMuaWNvbkNvbG9yO1xuICBmb3IgKGNvbnN0IHNlbCBvZiBbJy5zd2FsMi1zdWNjZXNzLWxpbmUtdGlwJywgJy5zd2FsMi1zdWNjZXNzLWxpbmUtbG9uZycsICcuc3dhbDIteC1tYXJrLWxpbmUtbGVmdCcsICcuc3dhbDIteC1tYXJrLWxpbmUtcmlnaHQnXSkge1xuICAgIHNldFN0eWxlKGljb24sIHNlbCwgJ2JhY2tncm91bmQtY29sb3InLCBwYXJhbXMuaWNvbkNvbG9yKTtcbiAgfVxuICBzZXRTdHlsZShpY29uLCAnLnN3YWwyLXN1Y2Nlc3MtcmluZycsICdib3JkZXItY29sb3InLCBwYXJhbXMuaWNvbkNvbG9yKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGljb25Db250ZW50ID0gY29udGVudCA9PiBgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXNbJ2ljb24tY29udGVudCddfVwiPiR7Y29udGVudH08L2Rpdj5gO1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJJbWFnZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGltYWdlID0gZ2V0SW1hZ2UoKTtcbiAgaWYgKCFpbWFnZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXBhcmFtcy5pbWFnZVVybCkge1xuICAgIGhpZGUoaW1hZ2UpO1xuICAgIHJldHVybjtcbiAgfVxuICBzaG93KGltYWdlLCAnJyk7XG5cbiAgLy8gU3JjLCBhbHRcbiAgaW1hZ2Uuc2V0QXR0cmlidXRlKCdzcmMnLCBwYXJhbXMuaW1hZ2VVcmwpO1xuICBpbWFnZS5zZXRBdHRyaWJ1dGUoJ2FsdCcsIHBhcmFtcy5pbWFnZUFsdCB8fCAnJyk7XG5cbiAgLy8gV2lkdGgsIGhlaWdodFxuICBhcHBseU51bWVyaWNhbFN0eWxlKGltYWdlLCAnd2lkdGgnLCBwYXJhbXMuaW1hZ2VXaWR0aCk7XG4gIGFwcGx5TnVtZXJpY2FsU3R5bGUoaW1hZ2UsICdoZWlnaHQnLCBwYXJhbXMuaW1hZ2VIZWlnaHQpO1xuXG4gIC8vIENsYXNzXG4gIGltYWdlLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzLmltYWdlO1xuICBhcHBseUN1c3RvbUNsYXNzKGltYWdlLCBwYXJhbXMsICdpbWFnZScpO1xufTtcblxubGV0IGRyYWdnaW5nID0gZmFsc2U7XG5sZXQgbW91c2Vkb3duWCA9IDA7XG5sZXQgbW91c2Vkb3duWSA9IDA7XG5sZXQgaW5pdGlhbFggPSAwO1xubGV0IGluaXRpYWxZID0gMDtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICovXG5jb25zdCBhZGREcmFnZ2FibGVMaXN0ZW5lcnMgPSBwb3B1cCA9PiB7XG4gIHBvcHVwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGRvd24pO1xuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmUpO1xuICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdXApO1xuICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZG93bik7XG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgbW92ZSk7XG4gIHBvcHVwLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdXApO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICovXG5jb25zdCByZW1vdmVEcmFnZ2FibGVMaXN0ZW5lcnMgPSBwb3B1cCA9PiB7XG4gIHBvcHVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGRvd24pO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmUpO1xuICBwb3B1cC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdXApO1xuICBwb3B1cC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZG93bik7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgbW92ZSk7XG4gIHBvcHVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdXApO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge01vdXNlRXZlbnQgfCBUb3VjaEV2ZW50fSBldmVudFxuICovXG5jb25zdCBkb3duID0gZXZlbnQgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmIChldmVudC50YXJnZXQgPT09IHBvcHVwIHx8IGdldEljb24oKS5jb250YWlucygvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL2V2ZW50LnRhcmdldCkpIHtcbiAgICBkcmFnZ2luZyA9IHRydWU7XG4gICAgY29uc3QgY2xpZW50WFkgPSBnZXRDbGllbnRYWShldmVudCk7XG4gICAgbW91c2Vkb3duWCA9IGNsaWVudFhZLmNsaWVudFg7XG4gICAgbW91c2Vkb3duWSA9IGNsaWVudFhZLmNsaWVudFk7XG4gICAgaW5pdGlhbFggPSBwYXJzZUludChwb3B1cC5zdHlsZS5pbnNldElubGluZVN0YXJ0KSB8fCAwO1xuICAgIGluaXRpYWxZID0gcGFyc2VJbnQocG9wdXAuc3R5bGUuaW5zZXRCbG9ja1N0YXJ0KSB8fCAwO1xuICAgIGFkZENsYXNzKHBvcHVwLCAnc3dhbDItZHJhZ2dpbmcnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge01vdXNlRXZlbnQgfCBUb3VjaEV2ZW50fSBldmVudFxuICovXG5jb25zdCBtb3ZlID0gZXZlbnQgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmIChkcmFnZ2luZykge1xuICAgIGxldCB7XG4gICAgICBjbGllbnRYLFxuICAgICAgY2xpZW50WVxuICAgIH0gPSBnZXRDbGllbnRYWShldmVudCk7XG4gICAgcG9wdXAuc3R5bGUuaW5zZXRJbmxpbmVTdGFydCA9IGAke2luaXRpYWxYICsgKGNsaWVudFggLSBtb3VzZWRvd25YKX1weGA7XG4gICAgcG9wdXAuc3R5bGUuaW5zZXRCbG9ja1N0YXJ0ID0gYCR7aW5pdGlhbFkgKyAoY2xpZW50WSAtIG1vdXNlZG93blkpfXB4YDtcbiAgfVxufTtcbmNvbnN0IHVwID0gKCkgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGRyYWdnaW5nID0gZmFsc2U7XG4gIHJlbW92ZUNsYXNzKHBvcHVwLCAnc3dhbDItZHJhZ2dpbmcnKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgVG91Y2hFdmVudH0gZXZlbnRcbiAqIEByZXR1cm5zIHt7IGNsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyIH19XG4gKi9cbmNvbnN0IGdldENsaWVudFhZID0gZXZlbnQgPT4ge1xuICBsZXQgY2xpZW50WCA9IDAsXG4gICAgY2xpZW50WSA9IDA7XG4gIGlmIChldmVudC50eXBlLnN0YXJ0c1dpdGgoJ21vdXNlJykpIHtcbiAgICBjbGllbnRYID0gLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqL2V2ZW50LmNsaWVudFg7XG4gICAgY2xpZW50WSA9IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi9ldmVudC5jbGllbnRZO1xuICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgndG91Y2gnKSkge1xuICAgIGNsaWVudFggPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovZXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgIGNsaWVudFkgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovZXZlbnQudG91Y2hlc1swXS5jbGllbnRZO1xuICB9XG4gIHJldHVybiB7XG4gICAgY2xpZW50WCxcbiAgICBjbGllbnRZXG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJQb3B1cCA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghY29udGFpbmVyIHx8ICFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdpZHRoXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjE3MFxuICBpZiAocGFyYW1zLnRvYXN0KSB7XG4gICAgYXBwbHlOdW1lcmljYWxTdHlsZShjb250YWluZXIsICd3aWR0aCcsIHBhcmFtcy53aWR0aCk7XG4gICAgcG9wdXAuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKCk7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgcG9wdXAuaW5zZXJ0QmVmb3JlKGxvYWRlciwgZ2V0SWNvbigpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXBwbHlOdW1lcmljYWxTdHlsZShwb3B1cCwgJ3dpZHRoJywgcGFyYW1zLndpZHRoKTtcbiAgfVxuXG4gIC8vIFBhZGRpbmdcbiAgYXBwbHlOdW1lcmljYWxTdHlsZShwb3B1cCwgJ3BhZGRpbmcnLCBwYXJhbXMucGFkZGluZyk7XG5cbiAgLy8gQ29sb3JcbiAgaWYgKHBhcmFtcy5jb2xvcikge1xuICAgIHBvcHVwLnN0eWxlLmNvbG9yID0gcGFyYW1zLmNvbG9yO1xuICB9XG5cbiAgLy8gQmFja2dyb3VuZFxuICBpZiAocGFyYW1zLmJhY2tncm91bmQpIHtcbiAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kID0gcGFyYW1zLmJhY2tncm91bmQ7XG4gIH1cbiAgaGlkZShnZXRWYWxpZGF0aW9uTWVzc2FnZSgpKTtcblxuICAvLyBDbGFzc2VzXG4gIGFkZENsYXNzZXMkMShwb3B1cCwgcGFyYW1zKTtcbiAgaWYgKHBhcmFtcy5kcmFnZ2FibGUgJiYgIXBhcmFtcy50b2FzdCkge1xuICAgIGFkZENsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5kcmFnZ2FibGUpO1xuICAgIGFkZERyYWdnYWJsZUxpc3RlbmVycyhwb3B1cCk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLmRyYWdnYWJsZSk7XG4gICAgcmVtb3ZlRHJhZ2dhYmxlTGlzdGVuZXJzKHBvcHVwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGFkZENsYXNzZXMkMSA9IChwb3B1cCwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHNob3dDbGFzcyA9IHBhcmFtcy5zaG93Q2xhc3MgfHwge307XG4gIC8vIERlZmF1bHQgQ2xhc3MgKyBzaG93Q2xhc3Mgd2hlbiB1cGRhdGluZyBTd2FsLnVwZGF0ZSh7fSlcbiAgcG9wdXAuY2xhc3NOYW1lID0gYCR7c3dhbENsYXNzZXMucG9wdXB9ICR7aXNWaXNpYmxlJDEocG9wdXApID8gc2hvd0NsYXNzLnBvcHVwIDogJyd9YDtcbiAgaWYgKHBhcmFtcy50b2FzdCkge1xuICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSk7XG4gICAgYWRkQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnRvYXN0KTtcbiAgfSBlbHNlIHtcbiAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMubW9kYWwpO1xuICB9XG5cbiAgLy8gQ3VzdG9tIGNsYXNzXG4gIGFwcGx5Q3VzdG9tQ2xhc3MocG9wdXAsIHBhcmFtcywgJ3BvcHVwJyk7XG4gIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgbmV4dCBtYWpvclxuICBpZiAodHlwZW9mIHBhcmFtcy5jdXN0b21DbGFzcyA9PT0gJ3N0cmluZycpIHtcbiAgICBhZGRDbGFzcyhwb3B1cCwgcGFyYW1zLmN1c3RvbUNsYXNzKTtcbiAgfVxuXG4gIC8vIEljb24gY2xhc3MgKCMxODQyKVxuICBpZiAocGFyYW1zLmljb24pIHtcbiAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXNbYGljb24tJHtwYXJhbXMuaWNvbn1gXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlclByb2dyZXNzU3RlcHMgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyID0gZ2V0UHJvZ3Jlc3NTdGVwcygpO1xuICBpZiAoIXByb2dyZXNzU3RlcHNDb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge1xuICAgIHByb2dyZXNzU3RlcHMsXG4gICAgY3VycmVudFByb2dyZXNzU3RlcFxuICB9ID0gcGFyYW1zO1xuICBpZiAoIXByb2dyZXNzU3RlcHMgfHwgcHJvZ3Jlc3NTdGVwcy5sZW5ndGggPT09IDAgfHwgY3VycmVudFByb2dyZXNzU3RlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGlkZShwcm9ncmVzc1N0ZXBzQ29udGFpbmVyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2hvdyhwcm9ncmVzc1N0ZXBzQ29udGFpbmVyKTtcbiAgcHJvZ3Jlc3NTdGVwc0NvbnRhaW5lci50ZXh0Q29udGVudCA9ICcnO1xuICBpZiAoY3VycmVudFByb2dyZXNzU3RlcCA+PSBwcm9ncmVzc1N0ZXBzLmxlbmd0aCkge1xuICAgIHdhcm4oJ0ludmFsaWQgY3VycmVudFByb2dyZXNzU3RlcCBwYXJhbWV0ZXIsIGl0IHNob3VsZCBiZSBsZXNzIHRoYW4gcHJvZ3Jlc3NTdGVwcy5sZW5ndGggJyArICcoY3VycmVudFByb2dyZXNzU3RlcCBsaWtlIEpTIGFycmF5cyBzdGFydHMgZnJvbSAwKScpO1xuICB9XG4gIHByb2dyZXNzU3RlcHMuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBzdGVwRWwgPSBjcmVhdGVTdGVwRWxlbWVudChzdGVwKTtcbiAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLmFwcGVuZENoaWxkKHN0ZXBFbCk7XG4gICAgaWYgKGluZGV4ID09PSBjdXJyZW50UHJvZ3Jlc3NTdGVwKSB7XG4gICAgICBhZGRDbGFzcyhzdGVwRWwsIHN3YWxDbGFzc2VzWydhY3RpdmUtcHJvZ3Jlc3Mtc3RlcCddKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSBwcm9ncmVzc1N0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGNvbnN0IGxpbmVFbCA9IGNyZWF0ZUxpbmVFbGVtZW50KHBhcmFtcyk7XG4gICAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLmFwcGVuZENoaWxkKGxpbmVFbCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ZXBcbiAqIEByZXR1cm5zIHtIVE1MTElFbGVtZW50fVxuICovXG5jb25zdCBjcmVhdGVTdGVwRWxlbWVudCA9IHN0ZXAgPT4ge1xuICBjb25zdCBzdGVwRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBhZGRDbGFzcyhzdGVwRWwsIHN3YWxDbGFzc2VzWydwcm9ncmVzcy1zdGVwJ10pO1xuICBzZXRJbm5lckh0bWwoc3RlcEVsLCBzdGVwKTtcbiAgcmV0dXJuIHN0ZXBFbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7SFRNTExJRWxlbWVudH1cbiAqL1xuY29uc3QgY3JlYXRlTGluZUVsZW1lbnQgPSBwYXJhbXMgPT4ge1xuICBjb25zdCBsaW5lRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBhZGRDbGFzcyhsaW5lRWwsIHN3YWxDbGFzc2VzWydwcm9ncmVzcy1zdGVwLWxpbmUnXSk7XG4gIGlmIChwYXJhbXMucHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlKSB7XG4gICAgYXBwbHlOdW1lcmljYWxTdHlsZShsaW5lRWwsICd3aWR0aCcsIHBhcmFtcy5wcm9ncmVzc1N0ZXBzRGlzdGFuY2UpO1xuICB9XG4gIHJldHVybiBsaW5lRWw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJUaXRsZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHRpdGxlID0gZ2V0VGl0bGUoKTtcbiAgaWYgKCF0aXRsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzaG93V2hlbklubmVySHRtbFByZXNlbnQodGl0bGUpO1xuICB0b2dnbGUodGl0bGUsIHBhcmFtcy50aXRsZSB8fCBwYXJhbXMudGl0bGVUZXh0LCAnYmxvY2snKTtcbiAgaWYgKHBhcmFtcy50aXRsZSkge1xuICAgIHBhcnNlSHRtbFRvQ29udGFpbmVyKHBhcmFtcy50aXRsZSwgdGl0bGUpO1xuICB9XG4gIGlmIChwYXJhbXMudGl0bGVUZXh0KSB7XG4gICAgdGl0bGUuaW5uZXJUZXh0ID0gcGFyYW1zLnRpdGxlVGV4dDtcbiAgfVxuXG4gIC8vIEN1c3RvbSBjbGFzc1xuICBhcHBseUN1c3RvbUNsYXNzKHRpdGxlLCBwYXJhbXMsICd0aXRsZScpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgcmVuZGVyUG9wdXAoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIHJlbmRlckNvbnRhaW5lcihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVyUHJvZ3Jlc3NTdGVwcyhpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVySWNvbihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVySW1hZ2UoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIHJlbmRlclRpdGxlKGluc3RhbmNlLCBwYXJhbXMpO1xuICByZW5kZXJDbG9zZUJ1dHRvbihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVyQ29udGVudChpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVyQWN0aW9ucyhpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVyRm9vdGVyKGluc3RhbmNlLCBwYXJhbXMpO1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpZFJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiBwb3B1cCkge1xuICAgIHBhcmFtcy5kaWRSZW5kZXIocG9wdXApO1xuICB9XG4gIGdsb2JhbFN0YXRlLmV2ZW50RW1pdHRlci5lbWl0KCdkaWRSZW5kZXInLCBwb3B1cCk7XG59O1xuXG4vKlxuICogR2xvYmFsIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBTd2VldEFsZXJ0MiBwb3B1cCBpcyBzaG93blxuICovXG5jb25zdCBpc1Zpc2libGUgPSAoKSA9PiB7XG4gIHJldHVybiBpc1Zpc2libGUkMShnZXRQb3B1cCgpKTtcbn07XG5cbi8qXG4gKiBHbG9iYWwgZnVuY3Rpb24gdG8gY2xpY2sgJ0NvbmZpcm0nIGJ1dHRvblxuICovXG5jb25zdCBjbGlja0NvbmZpcm0gPSAoKSA9PiB7XG4gIHZhciBfZG9tJGdldENvbmZpcm1CdXR0b247XG4gIHJldHVybiAoX2RvbSRnZXRDb25maXJtQnV0dG9uID0gZ2V0Q29uZmlybUJ1dHRvbigpKSA9PT0gbnVsbCB8fCBfZG9tJGdldENvbmZpcm1CdXR0b24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kb20kZ2V0Q29uZmlybUJ1dHRvbi5jbGljaygpO1xufTtcblxuLypcbiAqIEdsb2JhbCBmdW5jdGlvbiB0byBjbGljayAnRGVueScgYnV0dG9uXG4gKi9cbmNvbnN0IGNsaWNrRGVueSA9ICgpID0+IHtcbiAgdmFyIF9kb20kZ2V0RGVueUJ1dHRvbjtcbiAgcmV0dXJuIChfZG9tJGdldERlbnlCdXR0b24gPSBnZXREZW55QnV0dG9uKCkpID09PSBudWxsIHx8IF9kb20kZ2V0RGVueUJ1dHRvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RvbSRnZXREZW55QnV0dG9uLmNsaWNrKCk7XG59O1xuXG4vKlxuICogR2xvYmFsIGZ1bmN0aW9uIHRvIGNsaWNrICdDYW5jZWwnIGJ1dHRvblxuICovXG5jb25zdCBjbGlja0NhbmNlbCA9ICgpID0+IHtcbiAgdmFyIF9kb20kZ2V0Q2FuY2VsQnV0dG9uO1xuICByZXR1cm4gKF9kb20kZ2V0Q2FuY2VsQnV0dG9uID0gZ2V0Q2FuY2VsQnV0dG9uKCkpID09PSBudWxsIHx8IF9kb20kZ2V0Q2FuY2VsQnV0dG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZG9tJGdldENhbmNlbEJ1dHRvbi5jbGljaygpO1xufTtcblxuLyoqIEB0eXBlZGVmIHsnY2FuY2VsJyB8ICdiYWNrZHJvcCcgfCAnY2xvc2UnIHwgJ2VzYycgfCAndGltZXInfSBEaXNtaXNzUmVhc29uICovXG5cbi8qKiBAdHlwZSB7UmVjb3JkPERpc21pc3NSZWFzb24sIERpc21pc3NSZWFzb24+fSAqL1xuY29uc3QgRGlzbWlzc1JlYXNvbiA9IE9iamVjdC5mcmVlemUoe1xuICBjYW5jZWw6ICdjYW5jZWwnLFxuICBiYWNrZHJvcDogJ2JhY2tkcm9wJyxcbiAgY2xvc2U6ICdjbG9zZScsXG4gIGVzYzogJ2VzYycsXG4gIHRpbWVyOiAndGltZXInXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0dsb2JhbFN0YXRlfSBnbG9iYWxTdGF0ZVxuICovXG5jb25zdCByZW1vdmVLZXlkb3duSGFuZGxlciA9IGdsb2JhbFN0YXRlID0+IHtcbiAgaWYgKGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQgJiYgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXJBZGRlZCkge1xuICAgIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyLCB7XG4gICAgICBjYXB0dXJlOiBnbG9iYWxTdGF0ZS5rZXlkb3duTGlzdGVuZXJDYXB0dXJlXG4gICAgfSk7XG4gICAgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXJBZGRlZCA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7R2xvYmFsU3RhdGV9IGdsb2JhbFN0YXRlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICogQHBhcmFtIHsqfSBkaXNtaXNzV2l0aFxuICovXG5jb25zdCBhZGRLZXlkb3duSGFuZGxlciA9IChnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKSA9PiB7XG4gIHJlbW92ZUtleWRvd25IYW5kbGVyKGdsb2JhbFN0YXRlKTtcbiAgaWYgKCFpbm5lclBhcmFtcy50b2FzdCkge1xuICAgIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyID0gZSA9PiBrZXlkb3duSGFuZGxlcihpbm5lclBhcmFtcywgZSwgZGlzbWlzc1dpdGgpO1xuICAgIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQgPSBpbm5lclBhcmFtcy5rZXlkb3duTGlzdGVuZXJDYXB0dXJlID8gd2luZG93IDogZ2V0UG9wdXAoKTtcbiAgICBnbG9iYWxTdGF0ZS5rZXlkb3duTGlzdGVuZXJDYXB0dXJlID0gaW5uZXJQYXJhbXMua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZTtcbiAgICBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlciwge1xuICAgICAgY2FwdHVyZTogZ2xvYmFsU3RhdGUua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZVxuICAgIH0pO1xuICAgIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyQWRkZWQgPSB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGluY3JlbWVudFxuICovXG5jb25zdCBzZXRGb2N1cyA9IChpbmRleCwgaW5jcmVtZW50KSA9PiB7XG4gIHZhciBfZG9tJGdldFBvcHVwO1xuICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gIC8vIHNlYXJjaCBmb3IgdmlzaWJsZSBlbGVtZW50cyBhbmQgc2VsZWN0IHRoZSBuZXh0IHBvc3NpYmxlIG1hdGNoXG4gIGlmIChmb2N1c2FibGVFbGVtZW50cy5sZW5ndGgpIHtcbiAgICBpbmRleCA9IGluZGV4ICsgaW5jcmVtZW50O1xuXG4gICAgLy8gcm9sbG92ZXIgdG8gZmlyc3QgaXRlbVxuICAgIGlmIChpbmRleCA9PT0gZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICBpbmRleCA9IDA7XG5cbiAgICAgIC8vIGdvIHRvIGxhc3QgaXRlbVxuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBpbmRleCA9IGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGZvY3VzYWJsZUVsZW1lbnRzW2luZGV4XS5mb2N1cygpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBubyB2aXNpYmxlIGZvY3VzYWJsZSBlbGVtZW50cywgZm9jdXMgdGhlIHBvcHVwXG4gIChfZG9tJGdldFBvcHVwID0gZ2V0UG9wdXAoKSkgPT09IG51bGwgfHwgX2RvbSRnZXRQb3B1cCA9PT0gdm9pZCAwIHx8IF9kb20kZ2V0UG9wdXAuZm9jdXMoKTtcbn07XG5jb25zdCBhcnJvd0tleXNOZXh0QnV0dG9uID0gWydBcnJvd1JpZ2h0JywgJ0Fycm93RG93biddO1xuY29uc3QgYXJyb3dLZXlzUHJldmlvdXNCdXR0b24gPSBbJ0Fycm93TGVmdCcsICdBcnJvd1VwJ107XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc21pc3NXaXRoXG4gKi9cbmNvbnN0IGtleWRvd25IYW5kbGVyID0gKGlubmVyUGFyYW1zLCBldmVudCwgZGlzbWlzc1dpdGgpID0+IHtcbiAgaWYgKCFpbm5lclBhcmFtcykge1xuICAgIHJldHVybjsgLy8gVGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZFxuICB9XG5cbiAgLy8gSWdub3JlIGtleWRvd24gZHVyaW5nIElNRSBjb21wb3NpdGlvblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQva2V5ZG93bl9ldmVudCNpZ25vcmluZ19rZXlkb3duX2R1cmluZ19pbWVfY29tcG9zaXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy83MjBcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yNDA2XG4gIGlmIChldmVudC5pc0NvbXBvc2luZyB8fCBldmVudC5rZXlDb2RlID09PSAyMjkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlubmVyUGFyYW1zLnN0b3BLZXlkb3duUHJvcGFnYXRpb24pIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIC8vIEVOVEVSXG4gIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICBoYW5kbGVFbnRlcihldmVudCwgaW5uZXJQYXJhbXMpO1xuICB9XG5cbiAgLy8gVEFCXG4gIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicpIHtcbiAgICBoYW5kbGVUYWIoZXZlbnQpO1xuICB9XG5cbiAgLy8gQVJST1dTIC0gc3dpdGNoIGZvY3VzIGJldHdlZW4gYnV0dG9uc1xuICBlbHNlIGlmIChbLi4uYXJyb3dLZXlzTmV4dEJ1dHRvbiwgLi4uYXJyb3dLZXlzUHJldmlvdXNCdXR0b25dLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICBoYW5kbGVBcnJvd3MoZXZlbnQua2V5KTtcbiAgfVxuXG4gIC8vIEVTQ1xuICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgaGFuZGxlRXNjKGV2ZW50LCBpbm5lclBhcmFtcywgZGlzbWlzc1dpdGgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKi9cbmNvbnN0IGhhbmRsZUVudGVyID0gKGV2ZW50LCBpbm5lclBhcmFtcykgPT4ge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzIzODZcbiAgaWYgKCFjYWxsSWZGdW5jdGlvbihpbm5lclBhcmFtcy5hbGxvd0VudGVyS2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dCA9IGdldElucHV0JDEoZ2V0UG9wdXAoKSwgaW5uZXJQYXJhbXMuaW5wdXQpO1xuICBpZiAoZXZlbnQudGFyZ2V0ICYmIGlucHV0ICYmIGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGV2ZW50LnRhcmdldC5vdXRlckhUTUwgPT09IGlucHV0Lm91dGVySFRNTCkge1xuICAgIGlmIChbJ3RleHRhcmVhJywgJ2ZpbGUnXS5pbmNsdWRlcyhpbm5lclBhcmFtcy5pbnB1dCkpIHtcbiAgICAgIHJldHVybjsgLy8gZG8gbm90IHN1Ym1pdFxuICAgIH1cbiAgICBjbGlja0NvbmZpcm0oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAqL1xuY29uc3QgaGFuZGxlVGFiID0gZXZlbnQgPT4ge1xuICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gIGxldCBidG5JbmRleCA9IC0xO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRhcmdldEVsZW1lbnQgPT09IGZvY3VzYWJsZUVsZW1lbnRzW2ldKSB7XG4gICAgICBidG5JbmRleCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBDeWNsZSB0byB0aGUgbmV4dCBidXR0b25cbiAgaWYgKCFldmVudC5zaGlmdEtleSkge1xuICAgIHNldEZvY3VzKGJ0bkluZGV4LCAxKTtcbiAgfVxuXG4gIC8vIEN5Y2xlIHRvIHRoZSBwcmV2IGJ1dHRvblxuICBlbHNlIHtcbiAgICBzZXRGb2N1cyhidG5JbmRleCwgLTEpO1xuICB9XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cbmNvbnN0IGhhbmRsZUFycm93cyA9IGtleSA9PiB7XG4gIGNvbnN0IGFjdGlvbnMgPSBnZXRBY3Rpb25zKCk7XG4gIGNvbnN0IGNvbmZpcm1CdXR0b24gPSBnZXRDb25maXJtQnV0dG9uKCk7XG4gIGNvbnN0IGRlbnlCdXR0b24gPSBnZXREZW55QnV0dG9uKCk7XG4gIGNvbnN0IGNhbmNlbEJ1dHRvbiA9IGdldENhbmNlbEJ1dHRvbigpO1xuICBpZiAoIWFjdGlvbnMgfHwgIWNvbmZpcm1CdXR0b24gfHwgIWRlbnlCdXR0b24gfHwgIWNhbmNlbEJ1dHRvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQHR5cGUgSFRNTEVsZW1lbnRbXSAqL1xuICBjb25zdCBidXR0b25zID0gW2NvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbl07XG4gIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgIWJ1dHRvbnMuaW5jbHVkZXMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2libGluZyA9IGFycm93S2V5c05leHRCdXR0b24uaW5jbHVkZXMoa2V5KSA/ICduZXh0RWxlbWVudFNpYmxpbmcnIDogJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnO1xuICBsZXQgYnV0dG9uVG9Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIGlmICghYnV0dG9uVG9Gb2N1cykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBidXR0b25Ub0ZvY3VzID0gYnV0dG9uVG9Gb2N1c1tzaWJsaW5nXTtcbiAgICBpZiAoIWJ1dHRvblRvRm9jdXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblRvRm9jdXMgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCAmJiBpc1Zpc2libGUkMShidXR0b25Ub0ZvY3VzKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChidXR0b25Ub0ZvY3VzIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpIHtcbiAgICBidXR0b25Ub0ZvY3VzLmZvY3VzKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc21pc3NXaXRoXG4gKi9cbmNvbnN0IGhhbmRsZUVzYyA9IChldmVudCwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKSA9PiB7XG4gIGlmIChjYWxsSWZGdW5jdGlvbihpbm5lclBhcmFtcy5hbGxvd0VzY2FwZUtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uZXNjKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyBgV2Vha01hcGBzIGZvciBlYWNoIGVmZmVjdGl2ZWx5LVwicHJpdmF0ZSAgcHJvcGVydHlcIiB0aGF0IGEgYFN3YWxgIGhhcy5cbiAqIEZvciBleGFtcGxlLCB0byBzZXQgdGhlIHByaXZhdGUgcHJvcGVydHkgXCJmb29cIiBvZiBgdGhpc2AgdG8gXCJiYXJcIiwgeW91IGNhbiBgcHJpdmF0ZVByb3BzLmZvby5zZXQodGhpcywgJ2JhcicpYFxuICogVGhpcyBpcyB0aGUgYXBwcm9hY2ggdGhhdCBCYWJlbCB3aWxsIHByb2JhYmx5IHRha2UgdG8gaW1wbGVtZW50IHByaXZhdGUgbWV0aG9kcy9maWVsZHNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJpdmF0ZS1tZXRob2RzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9wdWxsLzc1NTVcbiAqIE9uY2Ugd2UgaGF2ZSB0aGUgY2hhbmdlcyBmcm9tIHRoYXQgUFIgaW4gQmFiZWwsIGFuZCBvdXIgY29yZSBjbGFzcyBmaXRzIHJlYXNvbmFibGUgaW4gKm9uZSBtb2R1bGUqXG4gKiAgIHRoZW4gd2UgY2FuIHVzZSB0aGF0IGxhbmd1YWdlIGZlYXR1cmUuXG4gKi9cblxudmFyIHByaXZhdGVNZXRob2RzID0ge1xuICBzd2FsUHJvbWlzZVJlc29sdmU6IG5ldyBXZWFrTWFwKCksXG4gIHN3YWxQcm9taXNlUmVqZWN0OiBuZXcgV2Vha01hcCgpXG59O1xuXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLnBhY2llbGxvZ3JvdXAuY29tL2Jsb2cvMjAxOC8wNi90aGUtY3VycmVudC1zdGF0ZS1vZi1tb2RhbC1kaWFsb2ctYWNjZXNzaWJpbGl0eS9cbi8vIEFkZGluZyBhcmlhLWhpZGRlbj1cInRydWVcIiB0byBlbGVtZW50cyBvdXRzaWRlIG9mIHRoZSBhY3RpdmUgbW9kYWwgZGlhbG9nIGVuc3VyZXMgdGhhdFxuLy8gZWxlbWVudHMgbm90IHdpdGhpbiB0aGUgYWN0aXZlIG1vZGFsIGRpYWxvZyB3aWxsIG5vdCBiZSBzdXJmYWNlZCBpZiBhIHVzZXIgb3BlbnMgYSBzY3JlZW5cbi8vIHJlYWRlcuKAmXMgbGlzdCBvZiBlbGVtZW50cyAoaGVhZGluZ3MsIGZvcm0gY29udHJvbHMsIGxhbmRtYXJrcywgZXRjLikgaW4gdGhlIGRvY3VtZW50LlxuXG5jb25zdCBzZXRBcmlhSGlkZGVuID0gKCkgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgY29uc3QgYm9keUNoaWxkcmVuID0gQXJyYXkuZnJvbShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgYm9keUNoaWxkcmVuLmZvckVhY2goZWwgPT4ge1xuICAgIGlmIChlbC5jb250YWlucyhjb250YWluZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1wcmV2aW91cy1hcmlhLWhpZGRlbicsIGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSB8fCAnJyk7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICB9KTtcbn07XG5jb25zdCB1bnNldEFyaWFIaWRkZW4gPSAoKSA9PiB7XG4gIGNvbnN0IGJvZHlDaGlsZHJlbiA9IEFycmF5LmZyb20oZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gIGJvZHlDaGlsZHJlbi5mb3JFYWNoKGVsID0+IHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdkYXRhLXByZXZpb3VzLWFyaWEtaGlkZGVuJykpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcHJldmlvdXMtYXJpYS1oaWRkZW4nKSB8fCAnJyk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtcHJldmlvdXMtYXJpYS1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBpc1NhZmFyaU9ySU9TID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cuR2VzdHVyZUV2ZW50OyAvLyB0cnVlIGZvciBTYWZhcmkgZGVza3RvcCArIGFsbCBpT1MgYnJvd3NlcnMgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcwNTg1Mzk0XG5cbi8qKlxuICogRml4IGlPUyBzY3JvbGxpbmdcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5NjI2MzAyXG4gKi9cbmNvbnN0IGlPU2ZpeCA9ICgpID0+IHtcbiAgaWYgKGlzU2FmYXJpT3JJT1MgJiYgIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCkpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCA9IGAke29mZnNldCAqIC0xfXB4YDtcbiAgICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5pb3NmaXgpO1xuICAgIGxvY2tCb2R5U2Nyb2xsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xMjQ2XG4gKi9cbmNvbnN0IGxvY2tCb2R5U2Nyb2xsID0gKCkgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBsZXQgcHJldmVudFRvdWNoTW92ZTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnRcbiAgICovXG4gIGNvbnRhaW5lci5vbnRvdWNoc3RhcnQgPSBldmVudCA9PiB7XG4gICAgcHJldmVudFRvdWNoTW92ZSA9IHNob3VsZFByZXZlbnRUb3VjaE1vdmUoZXZlbnQpO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldmVudFxuICAgKi9cbiAgY29udGFpbmVyLm9udG91Y2htb3ZlID0gZXZlbnQgPT4ge1xuICAgIGlmIChwcmV2ZW50VG91Y2hNb3ZlKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3Qgc2hvdWxkUHJldmVudFRvdWNoTW92ZSA9IGV2ZW50ID0+IHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgY29uc3QgaHRtbENvbnRhaW5lciA9IGdldEh0bWxDb250YWluZXIoKTtcbiAgaWYgKCFjb250YWluZXIgfHwgIWh0bWxDb250YWluZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU3R5bHVzKGV2ZW50KSB8fCBpc1pvb20oZXZlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0YXJnZXQgPT09IGNvbnRhaW5lcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaXNTY3JvbGxhYmxlKGNvbnRhaW5lcikgJiYgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0LnRhZ05hbWUgIT09ICdJTlBVVCcgJiZcbiAgLy8gIzE2MDNcbiAgdGFyZ2V0LnRhZ05hbWUgIT09ICdURVhUQVJFQScgJiZcbiAgLy8gIzIyNjZcbiAgIShpc1Njcm9sbGFibGUoaHRtbENvbnRhaW5lcikgJiZcbiAgLy8gIzE5NDRcbiAgaHRtbENvbnRhaW5lci5jb250YWlucyh0YXJnZXQpKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xNzg2XG4gKlxuICogQHBhcmFtIHsqfSBldmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzU3R5bHVzID0gZXZlbnQgPT4ge1xuICByZXR1cm4gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCAmJiBldmVudC50b3VjaGVzWzBdLnRvdWNoVHlwZSA9PT0gJ3N0eWx1cyc7XG59O1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTg5MVxuICpcbiAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1pvb20gPSBldmVudCA9PiB7XG4gIHJldHVybiBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMTtcbn07XG5jb25zdCB1bmRvSU9TZml4ID0gKCkgPT4ge1xuICBpZiAoaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXMuaW9zZml4KSkge1xuICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KGRvY3VtZW50LmJvZHkuc3R5bGUudG9wLCAxMCk7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXMuaW9zZml4KTtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCA9ICcnO1xuICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gb2Zmc2V0ICogLTE7XG4gIH1cbn07XG5cbi8qKlxuICogTWVhc3VyZSBzY3JvbGxiYXIgd2lkdGggZm9yIHBhZGRpbmcgYm9keSBkdXJpbmcgbW9kYWwgc2hvdy9oaWRlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvanMvc3JjL21vZGFsLmpzXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuY29uc3QgbWVhc3VyZVNjcm9sbGJhciA9ICgpID0+IHtcbiAgY29uc3Qgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNjcm9sbERpdi5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlc1snc2Nyb2xsYmFyLW1lYXN1cmUnXTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICByZXR1cm4gc2Nyb2xsYmFyV2lkdGg7XG59O1xuXG4vKipcbiAqIFJlbWVtYmVyIHN0YXRlIGluIGNhc2VzIHdoZXJlIG9wZW5pbmcgYW5kIGhhbmRsaW5nIGEgbW9kYWwgd2lsbCBmaWRkbGUgd2l0aCBpdC5cbiAqIEB0eXBlIHtudW1iZXIgfCBudWxsfVxuICovXG5sZXQgcHJldmlvdXNCb2R5UGFkZGluZyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGluaXRpYWxCb2R5T3ZlcmZsb3dcbiAqL1xuY29uc3QgcmVwbGFjZVNjcm9sbGJhcldpdGhQYWRkaW5nID0gaW5pdGlhbEJvZHlPdmVyZmxvdyA9PiB7XG4gIC8vIGZvciBxdWV1ZXMsIGRvIG5vdCBkbyB0aGlzIG1vcmUgdGhhbiBvbmNlXG4gIGlmIChwcmV2aW91c0JvZHlQYWRkaW5nICE9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGlmIHRoZSBib2R5IGhhcyBvdmVyZmxvd1xuICBpZiAoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgaW5pdGlhbEJvZHlPdmVyZmxvdyA9PT0gJ3Njcm9sbCcgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yNjYzXG4gICkge1xuICAgIC8vIGFkZCBwYWRkaW5nIHNvIHRoZSBjb250ZW50IGRvZXNuJ3Qgc2hpZnQgYWZ0ZXIgcmVtb3ZhbCBvZiBzY3JvbGxiYXJcbiAgICBwcmV2aW91c0JvZHlQYWRkaW5nID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpKTtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3ByZXZpb3VzQm9keVBhZGRpbmcgKyBtZWFzdXJlU2Nyb2xsYmFyKCl9cHhgO1xuICB9XG59O1xuY29uc3QgdW5kb1JlcGxhY2VTY3JvbGxiYXJXaXRoUGFkZGluZyA9ICgpID0+IHtcbiAgaWYgKHByZXZpb3VzQm9keVBhZGRpbmcgIT09IG51bGwpIHtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3ByZXZpb3VzQm9keVBhZGRpbmd9cHhgO1xuICAgIHByZXZpb3VzQm9keVBhZGRpbmcgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHtib29sZWFufSByZXR1cm5Gb2N1c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlkQ2xvc2VcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlUG9wdXBBbmRSZXNldFN0YXRlKGluc3RhbmNlLCBjb250YWluZXIsIHJldHVybkZvY3VzLCBkaWRDbG9zZSkge1xuICBpZiAoaXNUb2FzdCgpKSB7XG4gICAgdHJpZ2dlckRpZENsb3NlQW5kRGlzcG9zZShpbnN0YW5jZSwgZGlkQ2xvc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlc3RvcmVBY3RpdmVFbGVtZW50KHJldHVybkZvY3VzKS50aGVuKCgpID0+IHRyaWdnZXJEaWRDbG9zZUFuZERpc3Bvc2UoaW5zdGFuY2UsIGRpZENsb3NlKSk7XG4gICAgcmVtb3ZlS2V5ZG93bkhhbmRsZXIoZ2xvYmFsU3RhdGUpO1xuICB9XG5cbiAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yMDg4XG4gIC8vIGZvciBzb21lIHJlYXNvbiByZW1vdmluZyB0aGUgY29udGFpbmVyIGluIFNhZmFyaSB3aWxsIHNjcm9sbCB0aGUgZG9jdW1lbnQgdG8gYm90dG9tXG4gIGlmIChpc1NhZmFyaU9ySU9TKSB7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpub25lICFpbXBvcnRhbnQnKTtcbiAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucmVtb3ZlKCk7XG4gIH1cbiAgaWYgKGlzTW9kYWwoKSkge1xuICAgIHVuZG9SZXBsYWNlU2Nyb2xsYmFyV2l0aFBhZGRpbmcoKTtcbiAgICB1bmRvSU9TZml4KCk7XG4gICAgdW5zZXRBcmlhSGlkZGVuKCk7XG4gIH1cbiAgcmVtb3ZlQm9keUNsYXNzZXMoKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgU3dlZXRBbGVydDIgY2xhc3NlcyBmcm9tIGJvZHlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQm9keUNsYXNzZXMoKSB7XG4gIHJlbW92ZUNsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBbc3dhbENsYXNzZXMuc2hvd24sIHN3YWxDbGFzc2VzWydoZWlnaHQtYXV0byddLCBzd2FsQ2xhc3Nlc1snbm8tYmFja2Ryb3AnXSwgc3dhbENsYXNzZXNbJ3RvYXN0LXNob3duJ11dKTtcbn1cblxuLyoqXG4gKiBJbnN0YW5jZSBtZXRob2QgdG8gY2xvc2Ugc3dlZXRBbGVydFxuICpcbiAqIEBwYXJhbSB7YW55fSByZXNvbHZlVmFsdWVcbiAqL1xuZnVuY3Rpb24gY2xvc2UocmVzb2x2ZVZhbHVlKSB7XG4gIHJlc29sdmVWYWx1ZSA9IHByZXBhcmVSZXNvbHZlVmFsdWUocmVzb2x2ZVZhbHVlKTtcbiAgY29uc3Qgc3dhbFByb21pc2VSZXNvbHZlID0gcHJpdmF0ZU1ldGhvZHMuc3dhbFByb21pc2VSZXNvbHZlLmdldCh0aGlzKTtcbiAgY29uc3QgZGlkQ2xvc2UgPSB0cmlnZ2VyQ2xvc2VQb3B1cCh0aGlzKTtcbiAgaWYgKHRoaXMuaXNBd2FpdGluZ1Byb21pc2UpIHtcbiAgICAvLyBBIHN3YWwgYXdhaXRpbmcgZm9yIGEgcHJvbWlzZSAoYWZ0ZXIgYSBjbGljayBvbiBDb25maXJtIG9yIERlbnkpIGNhbm5vdCBiZSBkaXNtaXNzZWQgYW55bW9yZSAjMjMzNVxuICAgIGlmICghcmVzb2x2ZVZhbHVlLmlzRGlzbWlzc2VkKSB7XG4gICAgICBoYW5kbGVBd2FpdGluZ1Byb21pc2UodGhpcyk7XG4gICAgICBzd2FsUHJvbWlzZVJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlkQ2xvc2UpIHtcbiAgICAvLyBSZXNvbHZlIFN3YWwgcHJvbWlzZVxuICAgIHN3YWxQcm9taXNlUmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xuICB9XG59XG5jb25zdCB0cmlnZ2VyQ2xvc2VQb3B1cCA9IGluc3RhbmNlID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gIGlmICghaW5uZXJQYXJhbXMgfHwgaGFzQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5wb3B1cCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7XG4gIGFkZENsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApO1xuICBjb25zdCBiYWNrZHJvcCA9IGdldENvbnRhaW5lcigpO1xuICByZW1vdmVDbGFzcyhiYWNrZHJvcCwgaW5uZXJQYXJhbXMuc2hvd0NsYXNzLmJhY2tkcm9wKTtcbiAgYWRkQ2xhc3MoYmFja2Ryb3AsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5iYWNrZHJvcCk7XG4gIGhhbmRsZVBvcHVwQW5pbWF0aW9uKGluc3RhbmNlLCBwb3B1cCwgaW5uZXJQYXJhbXMpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGVycm9yXG4gKi9cbmZ1bmN0aW9uIHJlamVjdFByb21pc2UoZXJyb3IpIHtcbiAgY29uc3QgcmVqZWN0UHJvbWlzZSA9IHByaXZhdGVNZXRob2RzLnN3YWxQcm9taXNlUmVqZWN0LmdldCh0aGlzKTtcbiAgaGFuZGxlQXdhaXRpbmdQcm9taXNlKHRoaXMpO1xuICBpZiAocmVqZWN0UHJvbWlzZSkge1xuICAgIC8vIFJlamVjdCBTd2FsIHByb21pc2VcbiAgICByZWplY3RQcm9taXNlKGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqL1xuY29uc3QgaGFuZGxlQXdhaXRpbmdQcm9taXNlID0gaW5zdGFuY2UgPT4ge1xuICBpZiAoaW5zdGFuY2UuaXNBd2FpdGluZ1Byb21pc2UpIHtcbiAgICBkZWxldGUgaW5zdGFuY2UuaXNBd2FpdGluZ1Byb21pc2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG1pZ2h0IGhhdmUgYmVlbiBwcmV2aW91c2x5IHBhcnRseSBkZXN0cm95ZWQsIHdlIG11c3QgcmVzdW1lIHRoZSBkZXN0cm95IHByb2Nlc3MgaW4gdGhpcyBjYXNlICMyMzM1XG4gICAgaWYgKCFwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKSkge1xuICAgICAgaW5zdGFuY2UuX2Rlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHJlc29sdmVWYWx1ZVxuICogQHJldHVybnMge1N3ZWV0QWxlcnRSZXN1bHR9XG4gKi9cbmNvbnN0IHByZXBhcmVSZXNvbHZlVmFsdWUgPSByZXNvbHZlVmFsdWUgPT4ge1xuICAvLyBXaGVuIHVzZXIgY2FsbHMgU3dhbC5jbG9zZSgpXG4gIGlmICh0eXBlb2YgcmVzb2x2ZVZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7XG4gICAgICBpc0NvbmZpcm1lZDogZmFsc2UsXG4gICAgICBpc0RlbmllZDogZmFsc2UsXG4gICAgICBpc0Rpc21pc3NlZDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgIGlzQ29uZmlybWVkOiBmYWxzZSxcbiAgICBpc0RlbmllZDogZmFsc2UsXG4gICAgaXNEaXNtaXNzZWQ6IGZhbHNlXG4gIH0sIHJlc29sdmVWYWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICovXG5jb25zdCBoYW5kbGVQb3B1cEFuaW1hdGlvbiA9IChpbnN0YW5jZSwgcG9wdXAsIGlubmVyUGFyYW1zKSA9PiB7XG4gIHZhciBfZ2xvYmFsU3RhdGUkZXZlbnRFbWk7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAvLyBJZiBhbmltYXRpb24gaXMgc3VwcG9ydGVkLCBhbmltYXRlXG4gIGNvbnN0IGFuaW1hdGlvbklzU3VwcG9ydGVkID0gaGFzQ3NzQW5pbWF0aW9uKHBvcHVwKTtcbiAgaWYgKHR5cGVvZiBpbm5lclBhcmFtcy53aWxsQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbm5lclBhcmFtcy53aWxsQ2xvc2UocG9wdXApO1xuICB9XG4gIChfZ2xvYmFsU3RhdGUkZXZlbnRFbWkgPSBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIpID09PSBudWxsIHx8IF9nbG9iYWxTdGF0ZSRldmVudEVtaSA9PT0gdm9pZCAwIHx8IF9nbG9iYWxTdGF0ZSRldmVudEVtaS5lbWl0KCd3aWxsQ2xvc2UnLCBwb3B1cCk7XG4gIGlmIChhbmltYXRpb25Jc1N1cHBvcnRlZCkge1xuICAgIGFuaW1hdGVQb3B1cChpbnN0YW5jZSwgcG9wdXAsIGNvbnRhaW5lciwgaW5uZXJQYXJhbXMucmV0dXJuRm9jdXMsIGlubmVyUGFyYW1zLmRpZENsb3NlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UsIHJlbW92ZSBpbW1lZGlhdGVseVxuICAgIHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZShpbnN0YW5jZSwgY29udGFpbmVyLCBpbm5lclBhcmFtcy5yZXR1cm5Gb2N1cywgaW5uZXJQYXJhbXMuZGlkQ2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0dXJuRm9jdXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpZENsb3NlXG4gKi9cbmNvbnN0IGFuaW1hdGVQb3B1cCA9IChpbnN0YW5jZSwgcG9wdXAsIGNvbnRhaW5lciwgcmV0dXJuRm9jdXMsIGRpZENsb3NlKSA9PiB7XG4gIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjayA9IHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZS5iaW5kKG51bGwsIGluc3RhbmNlLCBjb250YWluZXIsIHJldHVybkZvY3VzLCBkaWRDbG9zZSk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FuaW1hdGlvbkV2ZW50IHwgVHJhbnNpdGlvbkV2ZW50fSBlXG4gICAqL1xuICBjb25zdCBzd2FsQ2xvc2VBbmltYXRpb25GaW5pc2hlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBwb3B1cCkge1xuICAgICAgdmFyIF9nbG9iYWxTdGF0ZSRzd2FsQ2xvcztcbiAgICAgIChfZ2xvYmFsU3RhdGUkc3dhbENsb3MgPSBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2spID09PSBudWxsIHx8IF9nbG9iYWxTdGF0ZSRzd2FsQ2xvcyA9PT0gdm9pZCAwIHx8IF9nbG9iYWxTdGF0ZSRzd2FsQ2xvcy5jYWxsKGdsb2JhbFN0YXRlKTtcbiAgICAgIGRlbGV0ZSBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2s7XG4gICAgICBwb3B1cC5yZW1vdmVFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBzd2FsQ2xvc2VBbmltYXRpb25GaW5pc2hlZCk7XG4gICAgICBwb3B1cC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dhbENsb3NlQW5pbWF0aW9uRmluaXNoZWQpO1xuICAgIH1cbiAgfTtcbiAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgc3dhbENsb3NlQW5pbWF0aW9uRmluaXNoZWQpO1xuICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dhbENsb3NlQW5pbWF0aW9uRmluaXNoZWQpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaWRDbG9zZVxuICovXG5jb25zdCB0cmlnZ2VyRGlkQ2xvc2VBbmREaXNwb3NlID0gKGluc3RhbmNlLCBkaWRDbG9zZSkgPT4ge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB2YXIgX2dsb2JhbFN0YXRlJGV2ZW50RW1pMjtcbiAgICBpZiAodHlwZW9mIGRpZENsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkaWRDbG9zZS5iaW5kKGluc3RhbmNlLnBhcmFtcykoKTtcbiAgICB9XG4gICAgKF9nbG9iYWxTdGF0ZSRldmVudEVtaTIgPSBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIpID09PSBudWxsIHx8IF9nbG9iYWxTdGF0ZSRldmVudEVtaTIgPT09IHZvaWQgMCB8fCBfZ2xvYmFsU3RhdGUkZXZlbnRFbWkyLmVtaXQoJ2RpZENsb3NlJyk7XG4gICAgLy8gaW5zdGFuY2UgbWlnaHQgaGF2ZSBiZWVuIGRlc3Ryb3llZCBhbHJlYWR5XG4gICAgaWYgKGluc3RhbmNlLl9kZXN0cm95KSB7XG4gICAgICBpbnN0YW5jZS5fZGVzdHJveSgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFNob3dzIGxvYWRlciAoc3Bpbm5lciksIHRoaXMgaXMgdXNlZnVsIHdpdGggQUpBWCByZXF1ZXN0cy5cbiAqIEJ5IGRlZmF1bHQgdGhlIGxvYWRlciBiZSBzaG93biBpbnN0ZWFkIG9mIHRoZSBcIkNvbmZpcm1cIiBidXR0b24uXG4gKlxuICogQHBhcmFtIHtIVE1MQnV0dG9uRWxlbWVudCB8IG51bGx9IFtidXR0b25Ub1JlcGxhY2VdXG4gKi9cbmNvbnN0IHNob3dMb2FkaW5nID0gYnV0dG9uVG9SZXBsYWNlID0+IHtcbiAgbGV0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIG5ldyBTd2FsKCk7XG4gIH1cbiAgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcigpO1xuICBpZiAoaXNUb2FzdCgpKSB7XG4gICAgaGlkZShnZXRJY29uKCkpO1xuICB9IGVsc2Uge1xuICAgIHJlcGxhY2VCdXR0b24ocG9wdXAsIGJ1dHRvblRvUmVwbGFjZSk7XG4gIH1cbiAgc2hvdyhsb2FkZXIpO1xuICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbG9hZGluZycsICd0cnVlJyk7XG4gIHBvcHVwLnNldEF0dHJpYnV0ZSgnYXJpYS1idXN5JywgJ3RydWUnKTtcbiAgcG9wdXAuZm9jdXMoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAqIEBwYXJhbSB7SFRNTEJ1dHRvbkVsZW1lbnQgfCBudWxsfSBbYnV0dG9uVG9SZXBsYWNlXVxuICovXG5jb25zdCByZXBsYWNlQnV0dG9uID0gKHBvcHVwLCBidXR0b25Ub1JlcGxhY2UpID0+IHtcbiAgY29uc3QgYWN0aW9ucyA9IGdldEFjdGlvbnMoKTtcbiAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKCk7XG4gIGlmICghYWN0aW9ucyB8fCAhbG9hZGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghYnV0dG9uVG9SZXBsYWNlICYmIGlzVmlzaWJsZSQxKGdldENvbmZpcm1CdXR0b24oKSkpIHtcbiAgICBidXR0b25Ub1JlcGxhY2UgPSBnZXRDb25maXJtQnV0dG9uKCk7XG4gIH1cbiAgc2hvdyhhY3Rpb25zKTtcbiAgaWYgKGJ1dHRvblRvUmVwbGFjZSkge1xuICAgIGhpZGUoYnV0dG9uVG9SZXBsYWNlKTtcbiAgICBsb2FkZXIuc2V0QXR0cmlidXRlKCdkYXRhLWJ1dHRvbi10by1yZXBsYWNlJywgYnV0dG9uVG9SZXBsYWNlLmNsYXNzTmFtZSk7XG4gICAgYWN0aW9ucy5pbnNlcnRCZWZvcmUobG9hZGVyLCBidXR0b25Ub1JlcGxhY2UpO1xuICB9XG4gIGFkZENsYXNzKFtwb3B1cCwgYWN0aW9uc10sIHN3YWxDbGFzc2VzLmxvYWRpbmcpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgaGFuZGxlSW5wdXRPcHRpb25zQW5kVmFsdWUgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBpZiAocGFyYW1zLmlucHV0ID09PSAnc2VsZWN0JyB8fCBwYXJhbXMuaW5wdXQgPT09ICdyYWRpbycpIHtcbiAgICBoYW5kbGVJbnB1dE9wdGlvbnMoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAoWyd0ZXh0JywgJ2VtYWlsJywgJ251bWJlcicsICd0ZWwnLCAndGV4dGFyZWEnXS5zb21lKGkgPT4gaSA9PT0gcGFyYW1zLmlucHV0KSAmJiAoaGFzVG9Qcm9taXNlRm4ocGFyYW1zLmlucHV0VmFsdWUpIHx8IGlzUHJvbWlzZShwYXJhbXMuaW5wdXRWYWx1ZSkpKSB7XG4gICAgc2hvd0xvYWRpbmcoZ2V0Q29uZmlybUJ1dHRvbigpKTtcbiAgICBoYW5kbGVJbnB1dFZhbHVlKGluc3RhbmNlLCBwYXJhbXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcmV0dXJucyB7U3dlZXRBbGVydElucHV0VmFsdWV9XG4gKi9cbmNvbnN0IGdldElucHV0VmFsdWUgPSAoaW5zdGFuY2UsIGlubmVyUGFyYW1zKSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gaW5zdGFuY2UuZ2V0SW5wdXQoKTtcbiAgaWYgKCFpbnB1dCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAoaW5uZXJQYXJhbXMuaW5wdXQpIHtcbiAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShpbnB1dCk7XG4gICAgY2FzZSAncmFkaW8nOlxuICAgICAgcmV0dXJuIGdldFJhZGlvVmFsdWUoaW5wdXQpO1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgcmV0dXJuIGdldEZpbGVWYWx1ZShpbnB1dCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBpbm5lclBhcmFtcy5pbnB1dEF1dG9UcmltID8gaW5wdXQudmFsdWUudHJpbSgpIDogaW5wdXQudmFsdWU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuY29uc3QgZ2V0Q2hlY2tib3hWYWx1ZSA9IGlucHV0ID0+IGlucHV0LmNoZWNrZWQgPyAxIDogMDtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0UmFkaW9WYWx1ZSA9IGlucHV0ID0+IGlucHV0LmNoZWNrZWQgPyBpbnB1dC52YWx1ZSA6IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHJldHVybnMge0ZpbGVMaXN0IHwgRmlsZSB8IG51bGx9XG4gKi9cbmNvbnN0IGdldEZpbGVWYWx1ZSA9IGlucHV0ID0+IGlucHV0LmZpbGVzICYmIGlucHV0LmZpbGVzLmxlbmd0aCA/IGlucHV0LmdldEF0dHJpYnV0ZSgnbXVsdGlwbGUnKSAhPT0gbnVsbCA/IGlucHV0LmZpbGVzIDogaW5wdXQuZmlsZXNbMF0gOiBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBoYW5kbGVJbnB1dE9wdGlvbnMgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghcG9wdXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gaW5wdXRPcHRpb25zXG4gICAqL1xuICBjb25zdCBwcm9jZXNzSW5wdXRPcHRpb25zID0gaW5wdXRPcHRpb25zID0+IHtcbiAgICBpZiAocGFyYW1zLmlucHV0ID09PSAnc2VsZWN0Jykge1xuICAgICAgcG9wdWxhdGVTZWxlY3RPcHRpb25zKHBvcHVwLCBmb3JtYXRJbnB1dE9wdGlvbnMoaW5wdXRPcHRpb25zKSwgcGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5pbnB1dCA9PT0gJ3JhZGlvJykge1xuICAgICAgcG9wdWxhdGVSYWRpb09wdGlvbnMocG9wdXAsIGZvcm1hdElucHV0T3B0aW9ucyhpbnB1dE9wdGlvbnMpLCBwYXJhbXMpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGhhc1RvUHJvbWlzZUZuKHBhcmFtcy5pbnB1dE9wdGlvbnMpIHx8IGlzUHJvbWlzZShwYXJhbXMuaW5wdXRPcHRpb25zKSkge1xuICAgIHNob3dMb2FkaW5nKGdldENvbmZpcm1CdXR0b24oKSk7XG4gICAgYXNQcm9taXNlKHBhcmFtcy5pbnB1dE9wdGlvbnMpLnRoZW4oaW5wdXRPcHRpb25zID0+IHtcbiAgICAgIGluc3RhbmNlLmhpZGVMb2FkaW5nKCk7XG4gICAgICBwcm9jZXNzSW5wdXRPcHRpb25zKGlucHV0T3B0aW9ucyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5pbnB1dE9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgcHJvY2Vzc0lucHV0T3B0aW9ucyhwYXJhbXMuaW5wdXRPcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvcihgVW5leHBlY3RlZCB0eXBlIG9mIGlucHV0T3B0aW9ucyEgRXhwZWN0ZWQgb2JqZWN0LCBNYXAgb3IgUHJvbWlzZSwgZ290ICR7dHlwZW9mIHBhcmFtcy5pbnB1dE9wdGlvbnN9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGhhbmRsZUlucHV0VmFsdWUgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBpbnB1dCA9IGluc3RhbmNlLmdldElucHV0KCk7XG4gIGlmICghaW5wdXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaGlkZShpbnB1dCk7XG4gIGFzUHJvbWlzZShwYXJhbXMuaW5wdXRWYWx1ZSkudGhlbihpbnB1dFZhbHVlID0+IHtcbiAgICBpbnB1dC52YWx1ZSA9IHBhcmFtcy5pbnB1dCA9PT0gJ251bWJlcicgPyBgJHtwYXJzZUZsb2F0KGlucHV0VmFsdWUpIHx8IDB9YCA6IGAke2lucHV0VmFsdWV9YDtcbiAgICBzaG93KGlucHV0KTtcbiAgICBpbnB1dC5mb2N1cygpO1xuICAgIGluc3RhbmNlLmhpZGVMb2FkaW5nKCk7XG4gIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgZXJyb3IoYEVycm9yIGluIGlucHV0VmFsdWUgcHJvbWlzZTogJHtlcnJ9YCk7XG4gICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICBzaG93KGlucHV0KTtcbiAgICBpbnB1dC5mb2N1cygpO1xuICAgIGluc3RhbmNlLmhpZGVMb2FkaW5nKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICogQHBhcmFtIHtJbnB1dE9wdGlvbkZsYXR0ZW5lZFtdfSBpbnB1dE9wdGlvbnNcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5mdW5jdGlvbiBwb3B1bGF0ZVNlbGVjdE9wdGlvbnMocG9wdXAsIGlucHV0T3B0aW9ucywgcGFyYW1zKSB7XG4gIGNvbnN0IHNlbGVjdCA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMuc2VsZWN0KTtcbiAgaWYgKCFzZWxlY3QpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uTGFiZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblZhbHVlXG4gICAqL1xuICBjb25zdCByZW5kZXJPcHRpb24gPSAocGFyZW50LCBvcHRpb25MYWJlbCwgb3B0aW9uVmFsdWUpID0+IHtcbiAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBvcHRpb24udmFsdWUgPSBvcHRpb25WYWx1ZTtcbiAgICBzZXRJbm5lckh0bWwob3B0aW9uLCBvcHRpb25MYWJlbCk7XG4gICAgb3B0aW9uLnNlbGVjdGVkID0gaXNTZWxlY3RlZChvcHRpb25WYWx1ZSwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICB9O1xuICBpbnB1dE9wdGlvbnMuZm9yRWFjaChpbnB1dE9wdGlvbiA9PiB7XG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBpbnB1dE9wdGlvblswXTtcbiAgICBjb25zdCBvcHRpb25MYWJlbCA9IGlucHV0T3B0aW9uWzFdO1xuICAgIC8vIDxvcHRncm91cD4gc3BlYzpcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDQwMS9pbnRlcmFjdC9mb3Jtcy5odG1sI2gtMTcuNlxuICAgIC8vIFwiLi4uYWxsIE9QVEdST1VQIGVsZW1lbnRzIG11c3QgYmUgc3BlY2lmaWVkIGRpcmVjdGx5IHdpdGhpbiBhIFNFTEVDVCBlbGVtZW50IChpLmUuLCBncm91cHMgbWF5IG5vdCBiZSBuZXN0ZWQpLi4uXCJcbiAgICAvLyBjaGVjayB3aGV0aGVyIHRoaXMgaXMgYSA8b3B0Z3JvdXA+XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9uTGFiZWwpKSB7XG4gICAgICAvLyBpZiBpdCBpcyBhbiBhcnJheSwgdGhlbiBpdCBpcyBhbiA8b3B0Z3JvdXA+XG4gICAgICBjb25zdCBvcHRncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJyk7XG4gICAgICBvcHRncm91cC5sYWJlbCA9IG9wdGlvblZhbHVlO1xuICAgICAgb3B0Z3JvdXAuZGlzYWJsZWQgPSBmYWxzZTsgLy8gbm90IGNvbmZpZ3VyYWJsZSBmb3Igbm93XG4gICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0Z3JvdXApO1xuICAgICAgb3B0aW9uTGFiZWwuZm9yRWFjaChvID0+IHJlbmRlck9wdGlvbihvcHRncm91cCwgb1sxXSwgb1swXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjYXNlIG9mIDxvcHRpb24+XG4gICAgICByZW5kZXJPcHRpb24oc2VsZWN0LCBvcHRpb25MYWJlbCwgb3B0aW9uVmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHNlbGVjdC5mb2N1cygpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gKiBAcGFyYW0ge0lucHV0T3B0aW9uRmxhdHRlbmVkW119IGlucHV0T3B0aW9uc1xuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIHBvcHVsYXRlUmFkaW9PcHRpb25zKHBvcHVwLCBpbnB1dE9wdGlvbnMsIHBhcmFtcykge1xuICBjb25zdCByYWRpbyA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMucmFkaW8pO1xuICBpZiAoIXJhZGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlucHV0T3B0aW9ucy5mb3JFYWNoKGlucHV0T3B0aW9uID0+IHtcbiAgICBjb25zdCByYWRpb1ZhbHVlID0gaW5wdXRPcHRpb25bMF07XG4gICAgY29uc3QgcmFkaW9MYWJlbCA9IGlucHV0T3B0aW9uWzFdO1xuICAgIGNvbnN0IHJhZGlvSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGNvbnN0IHJhZGlvTGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICByYWRpb0lucHV0LnR5cGUgPSAncmFkaW8nO1xuICAgIHJhZGlvSW5wdXQubmFtZSA9IHN3YWxDbGFzc2VzLnJhZGlvO1xuICAgIHJhZGlvSW5wdXQudmFsdWUgPSByYWRpb1ZhbHVlO1xuICAgIGlmIChpc1NlbGVjdGVkKHJhZGlvVmFsdWUsIHBhcmFtcy5pbnB1dFZhbHVlKSkge1xuICAgICAgcmFkaW9JbnB1dC5jaGVja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgc2V0SW5uZXJIdG1sKGxhYmVsLCByYWRpb0xhYmVsKTtcbiAgICBsYWJlbC5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlcy5sYWJlbDtcbiAgICByYWRpb0xhYmVsRWxlbWVudC5hcHBlbmRDaGlsZChyYWRpb0lucHV0KTtcbiAgICByYWRpb0xhYmVsRWxlbWVudC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgcmFkaW8uYXBwZW5kQ2hpbGQocmFkaW9MYWJlbEVsZW1lbnQpO1xuICB9KTtcbiAgY29uc3QgcmFkaW9zID0gcmFkaW8ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKTtcbiAgaWYgKHJhZGlvcy5sZW5ndGgpIHtcbiAgICByYWRpb3NbMF0uZm9jdXMoKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGBpbnB1dE9wdGlvbnNgIGludG8gYW4gYXJyYXkgb2YgYFt2YWx1ZSwgbGFiZWxdYHNcbiAqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGlucHV0T3B0aW9uc1xuICogQHR5cGVkZWYge3N0cmluZ1tdfSBJbnB1dE9wdGlvbkZsYXR0ZW5lZFxuICogQHJldHVybnMge0lucHV0T3B0aW9uRmxhdHRlbmVkW119XG4gKi9cbmNvbnN0IGZvcm1hdElucHV0T3B0aW9ucyA9IGlucHV0T3B0aW9ucyA9PiB7XG4gIC8qKiBAdHlwZSB7SW5wdXRPcHRpb25GbGF0dGVuZWRbXX0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChpbnB1dE9wdGlvbnMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICBpbnB1dE9wdGlvbnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgbGV0IHZhbHVlRm9ybWF0dGVkID0gdmFsdWU7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlRm9ybWF0dGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBjYXNlIG9mIDxvcHRncm91cD5cbiAgICAgICAgdmFsdWVGb3JtYXR0ZWQgPSBmb3JtYXRJbnB1dE9wdGlvbnModmFsdWVGb3JtYXR0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goW2tleSwgdmFsdWVGb3JtYXR0ZWRdKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3Qua2V5cyhpbnB1dE9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGxldCB2YWx1ZUZvcm1hdHRlZCA9IGlucHV0T3B0aW9uc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZUZvcm1hdHRlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gY2FzZSBvZiA8b3B0Z3JvdXA+XG4gICAgICAgIHZhbHVlRm9ybWF0dGVkID0gZm9ybWF0SW5wdXRPcHRpb25zKHZhbHVlRm9ybWF0dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlRm9ybWF0dGVkXSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblZhbHVlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRJbnB1dFZhbHVlfSBpbnB1dFZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNTZWxlY3RlZCA9IChvcHRpb25WYWx1ZSwgaW5wdXRWYWx1ZSkgPT4ge1xuICByZXR1cm4gISFpbnB1dFZhbHVlICYmIGlucHV0VmFsdWUudG9TdHJpbmcoKSA9PT0gb3B0aW9uVmFsdWUudG9TdHJpbmcoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICovXG5jb25zdCBoYW5kbGVDb25maXJtQnV0dG9uQ2xpY2sgPSBpbnN0YW5jZSA9PiB7XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gIGluc3RhbmNlLmRpc2FibGVCdXR0b25zKCk7XG4gIGlmIChpbm5lclBhcmFtcy5pbnB1dCkge1xuICAgIGhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQoaW5zdGFuY2UsICdjb25maXJtJyk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlybShpbnN0YW5jZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICovXG5jb25zdCBoYW5kbGVEZW55QnV0dG9uQ2xpY2sgPSBpbnN0YW5jZSA9PiB7XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gIGluc3RhbmNlLmRpc2FibGVCdXR0b25zKCk7XG4gIGlmIChpbm5lclBhcmFtcy5yZXR1cm5JbnB1dFZhbHVlT25EZW55KSB7XG4gICAgaGFuZGxlQ29uZmlybU9yRGVueVdpdGhJbnB1dChpbnN0YW5jZSwgJ2RlbnknKTtcbiAgfSBlbHNlIHtcbiAgICBkZW55KGluc3RhbmNlLCBmYWxzZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlQ2FuY2VsQnV0dG9uQ2xpY2sgPSAoaW5zdGFuY2UsIGRpc21pc3NXaXRoKSA9PiB7XG4gIGluc3RhbmNlLmRpc2FibGVCdXR0b25zKCk7XG4gIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uY2FuY2VsKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHsnY29uZmlybScgfCAnZGVueSd9IHR5cGVcbiAqL1xuY29uc3QgaGFuZGxlQ29uZmlybU9yRGVueVdpdGhJbnB1dCA9IChpbnN0YW5jZSwgdHlwZSkgPT4ge1xuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICBpZiAoIWlubmVyUGFyYW1zLmlucHV0KSB7XG4gICAgZXJyb3IoYFRoZSBcImlucHV0XCIgcGFyYW1ldGVyIGlzIG5lZWRlZCB0byBiZSBzZXQgd2hlbiB1c2luZyByZXR1cm5JbnB1dFZhbHVlT24ke2NhcGl0YWxpemVGaXJzdExldHRlcih0eXBlKX1gKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXQgPSBpbnN0YW5jZS5nZXRJbnB1dCgpO1xuICBjb25zdCBpbnB1dFZhbHVlID0gZ2V0SW5wdXRWYWx1ZShpbnN0YW5jZSwgaW5uZXJQYXJhbXMpO1xuICBpZiAoaW5uZXJQYXJhbXMuaW5wdXRWYWxpZGF0b3IpIHtcbiAgICBoYW5kbGVJbnB1dFZhbGlkYXRvcihpbnN0YW5jZSwgaW5wdXRWYWx1ZSwgdHlwZSk7XG4gIH0gZWxzZSBpZiAoaW5wdXQgJiYgIWlucHV0LmNoZWNrVmFsaWRpdHkoKSkge1xuICAgIGluc3RhbmNlLmVuYWJsZUJ1dHRvbnMoKTtcbiAgICBpbnN0YW5jZS5zaG93VmFsaWRhdGlvbk1lc3NhZ2UoaW5uZXJQYXJhbXMudmFsaWRhdGlvbk1lc3NhZ2UgfHwgaW5wdXQudmFsaWRhdGlvbk1lc3NhZ2UpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdkZW55Jykge1xuICAgIGRlbnkoaW5zdGFuY2UsIGlucHV0VmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpcm0oaW5zdGFuY2UsIGlucHV0VmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydElucHV0VmFsdWV9IGlucHV0VmFsdWVcbiAqIEBwYXJhbSB7J2NvbmZpcm0nIHwgJ2RlbnknfSB0eXBlXG4gKi9cbmNvbnN0IGhhbmRsZUlucHV0VmFsaWRhdG9yID0gKGluc3RhbmNlLCBpbnB1dFZhbHVlLCB0eXBlKSA9PiB7XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gIGluc3RhbmNlLmRpc2FibGVJbnB1dCgpO1xuICBjb25zdCB2YWxpZGF0aW9uUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gYXNQcm9taXNlKGlubmVyUGFyYW1zLmlucHV0VmFsaWRhdG9yKGlucHV0VmFsdWUsIGlubmVyUGFyYW1zLnZhbGlkYXRpb25NZXNzYWdlKSkpO1xuICB2YWxpZGF0aW9uUHJvbWlzZS50aGVuKHZhbGlkYXRpb25NZXNzYWdlID0+IHtcbiAgICBpbnN0YW5jZS5lbmFibGVCdXR0b25zKCk7XG4gICAgaW5zdGFuY2UuZW5hYmxlSW5wdXQoKTtcbiAgICBpZiAodmFsaWRhdGlvbk1lc3NhZ2UpIHtcbiAgICAgIGluc3RhbmNlLnNob3dWYWxpZGF0aW9uTWVzc2FnZSh2YWxpZGF0aW9uTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZGVueScpIHtcbiAgICAgIGRlbnkoaW5zdGFuY2UsIGlucHV0VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maXJtKGluc3RhbmNlLCBpbnB1dFZhbHVlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuY29uc3QgZGVueSA9IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlIHx8IHVuZGVmaW5lZCk7XG4gIGlmIChpbm5lclBhcmFtcy5zaG93TG9hZGVyT25EZW55KSB7XG4gICAgc2hvd0xvYWRpbmcoZ2V0RGVueUJ1dHRvbigpKTtcbiAgfVxuICBpZiAoaW5uZXJQYXJhbXMucHJlRGVueSkge1xuICAgIGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlID0gdHJ1ZTsgLy8gRmxhZ2dpbmcgdGhlIGluc3RhbmNlIGFzIGF3YWl0aW5nIGEgcHJvbWlzZSBzbyBpdCdzIG93biBwcm9taXNlJ3MgcmVqZWN0L3Jlc29sdmUgbWV0aG9kcyBkb2Vzbid0IGdldCBkZXN0cm95ZWQgdW50aWwgdGhlIHJlc3VsdCBmcm9tIHRoaXMgcHJlRGVueSdzIHByb21pc2UgaXMgcmVjZWl2ZWRcbiAgICBjb25zdCBwcmVEZW55UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gYXNQcm9taXNlKGlubmVyUGFyYW1zLnByZURlbnkodmFsdWUsIGlubmVyUGFyYW1zLnZhbGlkYXRpb25NZXNzYWdlKSkpO1xuICAgIHByZURlbnlQcm9taXNlLnRoZW4ocHJlRGVueVZhbHVlID0+IHtcbiAgICAgIGlmIChwcmVEZW55VmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGluc3RhbmNlLmhpZGVMb2FkaW5nKCk7XG4gICAgICAgIGhhbmRsZUF3YWl0aW5nUHJvbWlzZShpbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5jbG9zZSh7XG4gICAgICAgICAgaXNEZW5pZWQ6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHR5cGVvZiBwcmVEZW55VmFsdWUgPT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiBwcmVEZW55VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4gcmVqZWN0V2l0aChpbnN0YW5jZSB8fCB1bmRlZmluZWQsIGVycm9yKSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY2xvc2Uoe1xuICAgICAgaXNEZW5pZWQ6IHRydWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICovXG5jb25zdCBzdWNjZWVkV2l0aCA9IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgaW5zdGFuY2UuY2xvc2Uoe1xuICAgIGlzQ29uZmlybWVkOiB0cnVlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yXG4gKi9cbmNvbnN0IHJlamVjdFdpdGggPSAoaW5zdGFuY2UsIGVycm9yKSA9PiB7XG4gIGluc3RhbmNlLnJlamVjdFByb21pc2UoZXJyb3IpO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmNvbnN0IGNvbmZpcm0gPSAoaW5zdGFuY2UsIHZhbHVlKSA9PiB7XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSB8fCB1bmRlZmluZWQpO1xuICBpZiAoaW5uZXJQYXJhbXMuc2hvd0xvYWRlck9uQ29uZmlybSkge1xuICAgIHNob3dMb2FkaW5nKCk7XG4gIH1cbiAgaWYgKGlubmVyUGFyYW1zLnByZUNvbmZpcm0pIHtcbiAgICBpbnN0YW5jZS5yZXNldFZhbGlkYXRpb25NZXNzYWdlKCk7XG4gICAgaW5zdGFuY2UuaXNBd2FpdGluZ1Byb21pc2UgPSB0cnVlOyAvLyBGbGFnZ2luZyB0aGUgaW5zdGFuY2UgYXMgYXdhaXRpbmcgYSBwcm9taXNlIHNvIGl0J3Mgb3duIHByb21pc2UncyByZWplY3QvcmVzb2x2ZSBtZXRob2RzIGRvZXNuJ3QgZ2V0IGRlc3Ryb3llZCB1bnRpbCB0aGUgcmVzdWx0IGZyb20gdGhpcyBwcmVDb25maXJtJ3MgcHJvbWlzZSBpcyByZWNlaXZlZFxuICAgIGNvbnN0IHByZUNvbmZpcm1Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBhc1Byb21pc2UoaW5uZXJQYXJhbXMucHJlQ29uZmlybSh2YWx1ZSwgaW5uZXJQYXJhbXMudmFsaWRhdGlvbk1lc3NhZ2UpKSk7XG4gICAgcHJlQ29uZmlybVByb21pc2UudGhlbihwcmVDb25maXJtVmFsdWUgPT4ge1xuICAgICAgaWYgKGlzVmlzaWJsZSQxKGdldFZhbGlkYXRpb25NZXNzYWdlKCkpIHx8IHByZUNvbmZpcm1WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICAgICAgaGFuZGxlQXdhaXRpbmdQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1Y2NlZWRXaXRoKGluc3RhbmNlLCB0eXBlb2YgcHJlQ29uZmlybVZhbHVlID09PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogcHJlQ29uZmlybVZhbHVlKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaChlcnJvciA9PiByZWplY3RXaXRoKGluc3RhbmNlIHx8IHVuZGVmaW5lZCwgZXJyb3IpKTtcbiAgfSBlbHNlIHtcbiAgICBzdWNjZWVkV2l0aChpbnN0YW5jZSwgdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIEhpZGVzIGxvYWRlciBhbmQgc2hvd3MgYmFjayB0aGUgYnV0dG9uIHdoaWNoIHdhcyBoaWRkZW4gYnkgLnNob3dMb2FkaW5nKClcbiAqL1xuZnVuY3Rpb24gaGlkZUxvYWRpbmcoKSB7XG4gIC8vIGRvIG5vdGhpbmcgaWYgcG9wdXAgaXMgY2xvc2VkXG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldCh0aGlzKTtcbiAgaWYgKCFpbm5lclBhcmFtcykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG4gIGhpZGUoZG9tQ2FjaGUubG9hZGVyKTtcbiAgaWYgKGlzVG9hc3QoKSkge1xuICAgIGlmIChpbm5lclBhcmFtcy5pY29uKSB7XG4gICAgICBzaG93KGdldEljb24oKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNob3dSZWxhdGVkQnV0dG9uKGRvbUNhY2hlKTtcbiAgfVxuICByZW1vdmVDbGFzcyhbZG9tQ2FjaGUucG9wdXAsIGRvbUNhY2hlLmFjdGlvbnNdLCBzd2FsQ2xhc3Nlcy5sb2FkaW5nKTtcbiAgZG9tQ2FjaGUucG9wdXAucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWJ1c3knKTtcbiAgZG9tQ2FjaGUucG9wdXAucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxvYWRpbmcnKTtcbiAgZG9tQ2FjaGUuY29uZmlybUJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICBkb21DYWNoZS5kZW55QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gIGRvbUNhY2hlLmNhbmNlbEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xufVxuY29uc3Qgc2hvd1JlbGF0ZWRCdXR0b24gPSBkb21DYWNoZSA9PiB7XG4gIGNvbnN0IGJ1dHRvblRvUmVwbGFjZSA9IGRvbUNhY2hlLnBvcHVwLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZG9tQ2FjaGUubG9hZGVyLmdldEF0dHJpYnV0ZSgnZGF0YS1idXR0b24tdG8tcmVwbGFjZScpKTtcbiAgaWYgKGJ1dHRvblRvUmVwbGFjZS5sZW5ndGgpIHtcbiAgICBzaG93KGJ1dHRvblRvUmVwbGFjZVswXSwgJ2lubGluZS1ibG9jaycpO1xuICB9IGVsc2UgaWYgKGFsbEJ1dHRvbnNBcmVIaWRkZW4oKSkge1xuICAgIGhpZGUoZG9tQ2FjaGUuYWN0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgaW5wdXQgRE9NIG5vZGUsIHRoaXMgbWV0aG9kIHdvcmtzIHdpdGggaW5wdXQgcGFyYW1ldGVyLlxuICpcbiAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0SW5wdXQoKSB7XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldCh0aGlzKTtcbiAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICBpZiAoIWRvbUNhY2hlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGdldElucHV0JDEoZG9tQ2FjaGUucG9wdXAsIGlubmVyUGFyYW1zLmlucHV0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBidXR0b25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gKi9cbmZ1bmN0aW9uIHNldEJ1dHRvbnNEaXNhYmxlZChpbnN0YW5jZSwgYnV0dG9ucywgZGlzYWJsZWQpIHtcbiAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KGluc3RhbmNlKTtcbiAgYnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgZG9tQ2FjaGVbYnV0dG9uXS5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBudWxsfSBpbnB1dFxuICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZFxuICovXG5mdW5jdGlvbiBzZXRJbnB1dERpc2FibGVkKGlucHV0LCBkaXNhYmxlZCkge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghcG9wdXAgfHwgIWlucHV0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgLyoqIEB0eXBlIHtOb2RlTGlzdE9mPEhUTUxJbnB1dEVsZW1lbnQ+fSAqL1xuICAgIGNvbnN0IHJhZGlvcyA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3JBbGwoYFtuYW1lPVwiJHtzd2FsQ2xhc3Nlcy5yYWRpb31cIl1gKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhZGlvcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmFkaW9zW2ldLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlucHV0LmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGUgYWxsIHRoZSBidXR0b25zXG4gKiBAdGhpcyB7U3dlZXRBbGVydH1cbiAqL1xuZnVuY3Rpb24gZW5hYmxlQnV0dG9ucygpIHtcbiAgc2V0QnV0dG9uc0Rpc2FibGVkKHRoaXMsIFsnY29uZmlybUJ1dHRvbicsICdkZW55QnV0dG9uJywgJ2NhbmNlbEJ1dHRvbiddLCBmYWxzZSk7XG59XG5cbi8qKlxuICogRGlzYWJsZSBhbGwgdGhlIGJ1dHRvbnNcbiAqIEB0aGlzIHtTd2VldEFsZXJ0fVxuICovXG5mdW5jdGlvbiBkaXNhYmxlQnV0dG9ucygpIHtcbiAgc2V0QnV0dG9uc0Rpc2FibGVkKHRoaXMsIFsnY29uZmlybUJ1dHRvbicsICdkZW55QnV0dG9uJywgJ2NhbmNlbEJ1dHRvbiddLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBFbmFibGUgdGhlIGlucHV0IGZpZWxkXG4gKiBAdGhpcyB7U3dlZXRBbGVydH1cbiAqL1xuZnVuY3Rpb24gZW5hYmxlSW5wdXQoKSB7XG4gIHNldElucHV0RGlzYWJsZWQodGhpcy5nZXRJbnB1dCgpLCBmYWxzZSk7XG59XG5cbi8qKlxuICogRGlzYWJsZSB0aGUgaW5wdXQgZmllbGRcbiAqIEB0aGlzIHtTd2VldEFsZXJ0fVxuICovXG5mdW5jdGlvbiBkaXNhYmxlSW5wdXQoKSB7XG4gIHNldElucHV0RGlzYWJsZWQodGhpcy5nZXRJbnB1dCgpLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBTaG93IGJsb2NrIHdpdGggdmFsaWRhdGlvbiBtZXNzYWdlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yXG4gKiBAdGhpcyB7U3dlZXRBbGVydH1cbiAqL1xuZnVuY3Rpb24gc2hvd1ZhbGlkYXRpb25NZXNzYWdlKGVycm9yKSB7XG4gIGNvbnN0IGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldCh0aGlzKTtcbiAgY29uc3QgcGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldCh0aGlzKTtcbiAgc2V0SW5uZXJIdG1sKGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlLCBlcnJvcik7XG4gIGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzWyd2YWxpZGF0aW9uLW1lc3NhZ2UnXTtcbiAgaWYgKHBhcmFtcy5jdXN0b21DbGFzcyAmJiBwYXJhbXMuY3VzdG9tQ2xhc3MudmFsaWRhdGlvbk1lc3NhZ2UpIHtcbiAgICBhZGRDbGFzcyhkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSwgcGFyYW1zLmN1c3RvbUNsYXNzLnZhbGlkYXRpb25NZXNzYWdlKTtcbiAgfVxuICBzaG93KGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlKTtcbiAgY29uc3QgaW5wdXQgPSB0aGlzLmdldElucHV0KCk7XG4gIGlmIChpbnB1dCkge1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCBzd2FsQ2xhc3Nlc1sndmFsaWRhdGlvbi1tZXNzYWdlJ10pO1xuICAgIGZvY3VzSW5wdXQoaW5wdXQpO1xuICAgIGFkZENsYXNzKGlucHV0LCBzd2FsQ2xhc3Nlcy5pbnB1dGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEhpZGUgYmxvY2sgd2l0aCB2YWxpZGF0aW9uIG1lc3NhZ2VcbiAqXG4gKiBAdGhpcyB7U3dlZXRBbGVydH1cbiAqL1xuZnVuY3Rpb24gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSgpIHtcbiAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICBpZiAoZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UpIHtcbiAgICBoaWRlKGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlKTtcbiAgfVxuICBjb25zdCBpbnB1dCA9IHRoaXMuZ2V0SW5wdXQoKTtcbiAgaWYgKGlucHV0KSB7XG4gICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcbiAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICByZW1vdmVDbGFzcyhpbnB1dCwgc3dhbENsYXNzZXMuaW5wdXRlcnJvcik7XG4gIH1cbn1cblxuY29uc3QgZGVmYXVsdFBhcmFtcyA9IHtcbiAgdGl0bGU6ICcnLFxuICB0aXRsZVRleHQ6ICcnLFxuICB0ZXh0OiAnJyxcbiAgaHRtbDogJycsXG4gIGZvb3RlcjogJycsXG4gIGljb246IHVuZGVmaW5lZCxcbiAgaWNvbkNvbG9yOiB1bmRlZmluZWQsXG4gIGljb25IdG1sOiB1bmRlZmluZWQsXG4gIHRlbXBsYXRlOiB1bmRlZmluZWQsXG4gIHRvYXN0OiBmYWxzZSxcbiAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICB0aGVtZTogJ2xpZ2h0JyxcbiAgc2hvd0NsYXNzOiB7XG4gICAgcG9wdXA6ICdzd2FsMi1zaG93JyxcbiAgICBiYWNrZHJvcDogJ3N3YWwyLWJhY2tkcm9wLXNob3cnLFxuICAgIGljb246ICdzd2FsMi1pY29uLXNob3cnXG4gIH0sXG4gIGhpZGVDbGFzczoge1xuICAgIHBvcHVwOiAnc3dhbDItaGlkZScsXG4gICAgYmFja2Ryb3A6ICdzd2FsMi1iYWNrZHJvcC1oaWRlJyxcbiAgICBpY29uOiAnc3dhbDItaWNvbi1oaWRlJ1xuICB9LFxuICBjdXN0b21DbGFzczoge30sXG4gIHRhcmdldDogJ2JvZHknLFxuICBjb2xvcjogdW5kZWZpbmVkLFxuICBiYWNrZHJvcDogdHJ1ZSxcbiAgaGVpZ2h0QXV0bzogdHJ1ZSxcbiAgYWxsb3dPdXRzaWRlQ2xpY2s6IHRydWUsXG4gIGFsbG93RXNjYXBlS2V5OiB0cnVlLFxuICBhbGxvd0VudGVyS2V5OiB0cnVlLFxuICBzdG9wS2V5ZG93blByb3BhZ2F0aW9uOiB0cnVlLFxuICBrZXlkb3duTGlzdGVuZXJDYXB0dXJlOiBmYWxzZSxcbiAgc2hvd0NvbmZpcm1CdXR0b246IHRydWUsXG4gIHNob3dEZW55QnV0dG9uOiBmYWxzZSxcbiAgc2hvd0NhbmNlbEJ1dHRvbjogZmFsc2UsXG4gIHByZUNvbmZpcm06IHVuZGVmaW5lZCxcbiAgcHJlRGVueTogdW5kZWZpbmVkLFxuICBjb25maXJtQnV0dG9uVGV4dDogJ09LJyxcbiAgY29uZmlybUJ1dHRvbkFyaWFMYWJlbDogJycsXG4gIGNvbmZpcm1CdXR0b25Db2xvcjogdW5kZWZpbmVkLFxuICBkZW55QnV0dG9uVGV4dDogJ05vJyxcbiAgZGVueUJ1dHRvbkFyaWFMYWJlbDogJycsXG4gIGRlbnlCdXR0b25Db2xvcjogdW5kZWZpbmVkLFxuICBjYW5jZWxCdXR0b25UZXh0OiAnQ2FuY2VsJyxcbiAgY2FuY2VsQnV0dG9uQXJpYUxhYmVsOiAnJyxcbiAgY2FuY2VsQnV0dG9uQ29sb3I6IHVuZGVmaW5lZCxcbiAgYnV0dG9uc1N0eWxpbmc6IHRydWUsXG4gIHJldmVyc2VCdXR0b25zOiBmYWxzZSxcbiAgZm9jdXNDb25maXJtOiB0cnVlLFxuICBmb2N1c0Rlbnk6IGZhbHNlLFxuICBmb2N1c0NhbmNlbDogZmFsc2UsXG4gIHJldHVybkZvY3VzOiB0cnVlLFxuICBzaG93Q2xvc2VCdXR0b246IGZhbHNlLFxuICBjbG9zZUJ1dHRvbkh0bWw6ICcmdGltZXM7JyxcbiAgY2xvc2VCdXR0b25BcmlhTGFiZWw6ICdDbG9zZSB0aGlzIGRpYWxvZycsXG4gIGxvYWRlckh0bWw6ICcnLFxuICBzaG93TG9hZGVyT25Db25maXJtOiBmYWxzZSxcbiAgc2hvd0xvYWRlck9uRGVueTogZmFsc2UsXG4gIGltYWdlVXJsOiB1bmRlZmluZWQsXG4gIGltYWdlV2lkdGg6IHVuZGVmaW5lZCxcbiAgaW1hZ2VIZWlnaHQ6IHVuZGVmaW5lZCxcbiAgaW1hZ2VBbHQ6ICcnLFxuICB0aW1lcjogdW5kZWZpbmVkLFxuICB0aW1lclByb2dyZXNzQmFyOiBmYWxzZSxcbiAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgcGFkZGluZzogdW5kZWZpbmVkLFxuICBiYWNrZ3JvdW5kOiB1bmRlZmluZWQsXG4gIGlucHV0OiB1bmRlZmluZWQsXG4gIGlucHV0UGxhY2Vob2xkZXI6ICcnLFxuICBpbnB1dExhYmVsOiAnJyxcbiAgaW5wdXRWYWx1ZTogJycsXG4gIGlucHV0T3B0aW9uczoge30sXG4gIGlucHV0QXV0b0ZvY3VzOiB0cnVlLFxuICBpbnB1dEF1dG9UcmltOiB0cnVlLFxuICBpbnB1dEF0dHJpYnV0ZXM6IHt9LFxuICBpbnB1dFZhbGlkYXRvcjogdW5kZWZpbmVkLFxuICByZXR1cm5JbnB1dFZhbHVlT25EZW55OiBmYWxzZSxcbiAgdmFsaWRhdGlvbk1lc3NhZ2U6IHVuZGVmaW5lZCxcbiAgZ3JvdzogZmFsc2UsXG4gIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgcHJvZ3Jlc3NTdGVwczogW10sXG4gIGN1cnJlbnRQcm9ncmVzc1N0ZXA6IHVuZGVmaW5lZCxcbiAgcHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlOiB1bmRlZmluZWQsXG4gIHdpbGxPcGVuOiB1bmRlZmluZWQsXG4gIGRpZE9wZW46IHVuZGVmaW5lZCxcbiAgZGlkUmVuZGVyOiB1bmRlZmluZWQsXG4gIHdpbGxDbG9zZTogdW5kZWZpbmVkLFxuICBkaWRDbG9zZTogdW5kZWZpbmVkLFxuICBkaWREZXN0cm95OiB1bmRlZmluZWQsXG4gIHNjcm9sbGJhclBhZGRpbmc6IHRydWVcbn07XG5jb25zdCB1cGRhdGFibGVQYXJhbXMgPSBbJ2FsbG93RXNjYXBlS2V5JywgJ2FsbG93T3V0c2lkZUNsaWNrJywgJ2JhY2tncm91bmQnLCAnYnV0dG9uc1N0eWxpbmcnLCAnY2FuY2VsQnV0dG9uQXJpYUxhYmVsJywgJ2NhbmNlbEJ1dHRvbkNvbG9yJywgJ2NhbmNlbEJ1dHRvblRleHQnLCAnY2xvc2VCdXR0b25BcmlhTGFiZWwnLCAnY2xvc2VCdXR0b25IdG1sJywgJ2NvbG9yJywgJ2NvbmZpcm1CdXR0b25BcmlhTGFiZWwnLCAnY29uZmlybUJ1dHRvbkNvbG9yJywgJ2NvbmZpcm1CdXR0b25UZXh0JywgJ2N1cnJlbnRQcm9ncmVzc1N0ZXAnLCAnY3VzdG9tQ2xhc3MnLCAnZGVueUJ1dHRvbkFyaWFMYWJlbCcsICdkZW55QnV0dG9uQ29sb3InLCAnZGVueUJ1dHRvblRleHQnLCAnZGlkQ2xvc2UnLCAnZGlkRGVzdHJveScsICdkcmFnZ2FibGUnLCAnZm9vdGVyJywgJ2hpZGVDbGFzcycsICdodG1sJywgJ2ljb24nLCAnaWNvbkNvbG9yJywgJ2ljb25IdG1sJywgJ2ltYWdlQWx0JywgJ2ltYWdlSGVpZ2h0JywgJ2ltYWdlVXJsJywgJ2ltYWdlV2lkdGgnLCAncHJlQ29uZmlybScsICdwcmVEZW55JywgJ3Byb2dyZXNzU3RlcHMnLCAncmV0dXJuRm9jdXMnLCAncmV2ZXJzZUJ1dHRvbnMnLCAnc2hvd0NhbmNlbEJ1dHRvbicsICdzaG93Q2xvc2VCdXR0b24nLCAnc2hvd0NvbmZpcm1CdXR0b24nLCAnc2hvd0RlbnlCdXR0b24nLCAndGV4dCcsICd0aXRsZScsICd0aXRsZVRleHQnLCAndGhlbWUnLCAnd2lsbENsb3NlJ107XG5cbi8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPn0gKi9cbmNvbnN0IGRlcHJlY2F0ZWRQYXJhbXMgPSB7XG4gIGFsbG93RW50ZXJLZXk6IHVuZGVmaW5lZFxufTtcbmNvbnN0IHRvYXN0SW5jb21wYXRpYmxlUGFyYW1zID0gWydhbGxvd091dHNpZGVDbGljaycsICdhbGxvd0VudGVyS2V5JywgJ2JhY2tkcm9wJywgJ2RyYWdnYWJsZScsICdmb2N1c0NvbmZpcm0nLCAnZm9jdXNEZW55JywgJ2ZvY3VzQ2FuY2VsJywgJ3JldHVybkZvY3VzJywgJ2hlaWdodEF1dG8nLCAna2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSddO1xuXG4vKipcbiAqIElzIHZhbGlkIHBhcmFtZXRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1ZhbGlkUGFyYW1ldGVyID0gcGFyYW1OYW1lID0+IHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZhdWx0UGFyYW1zLCBwYXJhbU5hbWUpO1xufTtcblxuLyoqXG4gKiBJcyB2YWxpZCBwYXJhbWV0ZXIgZm9yIFN3YWwudXBkYXRlKCkgbWV0aG9kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzVXBkYXRhYmxlUGFyYW1ldGVyID0gcGFyYW1OYW1lID0+IHtcbiAgcmV0dXJuIHVwZGF0YWJsZVBhcmFtcy5pbmRleE9mKHBhcmFtTmFtZSkgIT09IC0xO1xufTtcblxuLyoqXG4gKiBJcyBkZXByZWNhdGVkIHBhcmFtZXRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gKi9cbmNvbnN0IGlzRGVwcmVjYXRlZFBhcmFtZXRlciA9IHBhcmFtTmFtZSA9PiB7XG4gIHJldHVybiBkZXByZWNhdGVkUGFyYW1zW3BhcmFtTmFtZV07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbVxuICovXG5jb25zdCBjaGVja0lmUGFyYW1Jc1ZhbGlkID0gcGFyYW0gPT4ge1xuICBpZiAoIWlzVmFsaWRQYXJhbWV0ZXIocGFyYW0pKSB7XG4gICAgd2FybihgVW5rbm93biBwYXJhbWV0ZXIgXCIke3BhcmFtfVwiYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtXG4gKi9cbmNvbnN0IGNoZWNrSWZUb2FzdFBhcmFtSXNWYWxpZCA9IHBhcmFtID0+IHtcbiAgaWYgKHRvYXN0SW5jb21wYXRpYmxlUGFyYW1zLmluY2x1ZGVzKHBhcmFtKSkge1xuICAgIHdhcm4oYFRoZSBwYXJhbWV0ZXIgXCIke3BhcmFtfVwiIGlzIGluY29tcGF0aWJsZSB3aXRoIHRvYXN0c2ApO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbVxuICovXG5jb25zdCBjaGVja0lmUGFyYW1Jc0RlcHJlY2F0ZWQgPSBwYXJhbSA9PiB7XG4gIGNvbnN0IGlzRGVwcmVjYXRlZCA9IGlzRGVwcmVjYXRlZFBhcmFtZXRlcihwYXJhbSk7XG4gIGlmIChpc0RlcHJlY2F0ZWQpIHtcbiAgICB3YXJuQWJvdXREZXByZWNhdGlvbihwYXJhbSwgaXNEZXByZWNhdGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaG93IHJlbGV2YW50IHdhcm5pbmdzIGZvciBnaXZlbiBwYXJhbXNcbiAqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3Qgc2hvd1dhcm5pbmdzRm9yUGFyYW1zID0gcGFyYW1zID0+IHtcbiAgaWYgKHBhcmFtcy5iYWNrZHJvcCA9PT0gZmFsc2UgJiYgcGFyYW1zLmFsbG93T3V0c2lkZUNsaWNrKSB7XG4gICAgd2FybignXCJhbGxvd091dHNpZGVDbGlja1wiIHBhcmFtZXRlciByZXF1aXJlcyBgYmFja2Ryb3BgIHBhcmFtZXRlciB0byBiZSBzZXQgdG8gYHRydWVgJyk7XG4gIH1cbiAgaWYgKHBhcmFtcy50aGVtZSAmJiAhWydsaWdodCcsICdkYXJrJywgJ2F1dG8nLCAnYm9yZGVybGVzcyddLmluY2x1ZGVzKHBhcmFtcy50aGVtZSkpIHtcbiAgICB3YXJuKGBJbnZhbGlkIHRoZW1lIFwiJHtwYXJhbXMudGhlbWV9XCIuIEV4cGVjdGVkIFwibGlnaHRcIiwgXCJkYXJrXCIsIFwiYXV0b1wiLCBvciBcImJvcmRlcmxlc3NcImApO1xuICB9XG4gIGZvciAoY29uc3QgcGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgY2hlY2tJZlBhcmFtSXNWYWxpZChwYXJhbSk7XG4gICAgaWYgKHBhcmFtcy50b2FzdCkge1xuICAgICAgY2hlY2tJZlRvYXN0UGFyYW1Jc1ZhbGlkKHBhcmFtKTtcbiAgICB9XG4gICAgY2hlY2tJZlBhcmFtSXNEZXByZWNhdGVkKHBhcmFtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHBvcHVwIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZShwYXJhbXMpIHtcbiAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KHRoaXMpO1xuICBpZiAoIXBvcHVwIHx8IGhhc0NsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApKSB7XG4gICAgd2FybihgWW91J3JlIHRyeWluZyB0byB1cGRhdGUgdGhlIGNsb3NlZCBvciBjbG9zaW5nIHBvcHVwLCB0aGF0IHdvbid0IHdvcmsuIFVzZSB0aGUgdXBkYXRlKCkgbWV0aG9kIGluIHByZUNvbmZpcm0gcGFyYW1ldGVyIG9yIHNob3cgYSBuZXcgcG9wdXAuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZhbGlkVXBkYXRhYmxlUGFyYW1zID0gZmlsdGVyVmFsaWRQYXJhbXMocGFyYW1zKTtcbiAgY29uc3QgdXBkYXRlZFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyUGFyYW1zLCB2YWxpZFVwZGF0YWJsZVBhcmFtcyk7XG4gIHNob3dXYXJuaW5nc0ZvclBhcmFtcyh1cGRhdGVkUGFyYW1zKTtcbiAgY29udGFpbmVyLmRhdGFzZXRbJ3N3YWwyVGhlbWUnXSA9IHVwZGF0ZWRQYXJhbXMudGhlbWU7XG4gIHJlbmRlcih0aGlzLCB1cGRhdGVkUGFyYW1zKTtcbiAgcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLnNldCh0aGlzLCB1cGRhdGVkUGFyYW1zKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHBhcmFtczoge1xuICAgICAgdmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zLCBwYXJhbXMpLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gKi9cbmNvbnN0IGZpbHRlclZhbGlkUGFyYW1zID0gcGFyYW1zID0+IHtcbiAgY29uc3QgdmFsaWRVcGRhdGFibGVQYXJhbXMgPSB7fTtcbiAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICBpZiAoaXNVcGRhdGFibGVQYXJhbWV0ZXIocGFyYW0pKSB7XG4gICAgICB2YWxpZFVwZGF0YWJsZVBhcmFtc1twYXJhbV0gPSBwYXJhbXNbcGFyYW1dO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKGBJbnZhbGlkIHBhcmFtZXRlciB0byB1cGRhdGU6ICR7cGFyYW19YCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHZhbGlkVXBkYXRhYmxlUGFyYW1zO1xufTtcblxuLyoqXG4gKiBEaXNwb3NlIHRoZSBjdXJyZW50IFN3ZWV0QWxlcnQyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldCh0aGlzKTtcbiAgaWYgKCFpbm5lclBhcmFtcykge1xuICAgIGRpc3Bvc2VXZWFrTWFwcyh0aGlzKTsgLy8gVGhlIFdlYWtNYXBzIG1pZ2h0IGhhdmUgYmVlbiBwYXJ0bHkgZGVzdHJveWVkLCB3ZSBtdXN0IHJlY2FsbCBpdCB0byBkaXNwb3NlIGFueSByZW1haW5pbmcgV2Vha01hcHMgIzIzMzVcbiAgICByZXR1cm47IC8vIFRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFub3RoZXIgU3dhbCBjbG9zaW5nXG4gIGlmIChkb21DYWNoZS5wb3B1cCAmJiBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2spIHtcbiAgICBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2soKTtcbiAgICBkZWxldGUgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrO1xuICB9XG4gIGlmICh0eXBlb2YgaW5uZXJQYXJhbXMuZGlkRGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlubmVyUGFyYW1zLmRpZERlc3Ryb3koKTtcbiAgfVxuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIuZW1pdCgnZGlkRGVzdHJveScpO1xuICBkaXNwb3NlU3dhbCh0aGlzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKi9cbmNvbnN0IGRpc3Bvc2VTd2FsID0gaW5zdGFuY2UgPT4ge1xuICBkaXNwb3NlV2Vha01hcHMoaW5zdGFuY2UpO1xuICAvLyBVbnNldCB0aGlzLnBhcmFtcyBzbyBHQyB3aWxsIGRpc3Bvc2UgaXQgKCMxNTY5KVxuICBkZWxldGUgaW5zdGFuY2UucGFyYW1zO1xuICAvLyBVbnNldCBnbG9iYWxTdGF0ZSBwcm9wcyBzbyBHQyB3aWxsIGRpc3Bvc2UgZ2xvYmFsU3RhdGUgKCMxNTY5KVxuICBkZWxldGUgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXI7XG4gIGRlbGV0ZSBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0O1xuICAvLyBVbnNldCBjdXJyZW50SW5zdGFuY2VcbiAgZGVsZXRlIGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICovXG5jb25zdCBkaXNwb3NlV2Vha01hcHMgPSBpbnN0YW5jZSA9PiB7XG4gIC8vIElmIHRoZSBjdXJyZW50IGluc3RhbmNlIGlzIGF3YWl0aW5nIGEgcHJvbWlzZSByZXN1bHQsIHdlIGtlZXAgdGhlIHByaXZhdGVNZXRob2RzIHRvIGNhbGwgdGhlbSBvbmNlIHRoZSBwcm9taXNlIHJlc3VsdCBpcyByZXRyaWV2ZWQgIzIzMzVcbiAgaWYgKGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlKSB7XG4gICAgdW5zZXRXZWFrTWFwcyhwcml2YXRlUHJvcHMsIGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5pc0F3YWl0aW5nUHJvbWlzZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdW5zZXRXZWFrTWFwcyhwcml2YXRlTWV0aG9kcywgaW5zdGFuY2UpO1xuICAgIHVuc2V0V2Vha01hcHMocHJpdmF0ZVByb3BzLCBpbnN0YW5jZSk7XG4gICAgZGVsZXRlIGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlO1xuICAgIC8vIFVuc2V0IGluc3RhbmNlIG1ldGhvZHNcbiAgICBkZWxldGUgaW5zdGFuY2UuZGlzYWJsZUJ1dHRvbnM7XG4gICAgZGVsZXRlIGluc3RhbmNlLmVuYWJsZUJ1dHRvbnM7XG4gICAgZGVsZXRlIGluc3RhbmNlLmdldElucHV0O1xuICAgIGRlbGV0ZSBpbnN0YW5jZS5kaXNhYmxlSW5wdXQ7XG4gICAgZGVsZXRlIGluc3RhbmNlLmVuYWJsZUlucHV0O1xuICAgIGRlbGV0ZSBpbnN0YW5jZS5oaWRlTG9hZGluZztcbiAgICBkZWxldGUgaW5zdGFuY2UuZGlzYWJsZUxvYWRpbmc7XG4gICAgZGVsZXRlIGluc3RhbmNlLnNob3dWYWxpZGF0aW9uTWVzc2FnZTtcbiAgICBkZWxldGUgaW5zdGFuY2UucmVzZXRWYWxpZGF0aW9uTWVzc2FnZTtcbiAgICBkZWxldGUgaW5zdGFuY2UuY2xvc2U7XG4gICAgZGVsZXRlIGluc3RhbmNlLmNsb3NlUG9wdXA7XG4gICAgZGVsZXRlIGluc3RhbmNlLmNsb3NlTW9kYWw7XG4gICAgZGVsZXRlIGluc3RhbmNlLmNsb3NlVG9hc3Q7XG4gICAgZGVsZXRlIGluc3RhbmNlLnJlamVjdFByb21pc2U7XG4gICAgZGVsZXRlIGluc3RhbmNlLnVwZGF0ZTtcbiAgICBkZWxldGUgaW5zdGFuY2UuX2Rlc3Ryb3k7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICovXG5jb25zdCB1bnNldFdlYWtNYXBzID0gKG9iaiwgaW5zdGFuY2UpID0+IHtcbiAgZm9yIChjb25zdCBpIGluIG9iaikge1xuICAgIG9ialtpXS5kZWxldGUoaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgaW5zdGFuY2VNZXRob2RzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIF9kZXN0cm95OiBfZGVzdHJveSxcbiAgY2xvc2U6IGNsb3NlLFxuICBjbG9zZU1vZGFsOiBjbG9zZSxcbiAgY2xvc2VQb3B1cDogY2xvc2UsXG4gIGNsb3NlVG9hc3Q6IGNsb3NlLFxuICBkaXNhYmxlQnV0dG9uczogZGlzYWJsZUJ1dHRvbnMsXG4gIGRpc2FibGVJbnB1dDogZGlzYWJsZUlucHV0LFxuICBkaXNhYmxlTG9hZGluZzogaGlkZUxvYWRpbmcsXG4gIGVuYWJsZUJ1dHRvbnM6IGVuYWJsZUJ1dHRvbnMsXG4gIGVuYWJsZUlucHV0OiBlbmFibGVJbnB1dCxcbiAgZ2V0SW5wdXQ6IGdldElucHV0LFxuICBoYW5kbGVBd2FpdGluZ1Byb21pc2U6IGhhbmRsZUF3YWl0aW5nUHJvbWlzZSxcbiAgaGlkZUxvYWRpbmc6IGhpZGVMb2FkaW5nLFxuICByZWplY3RQcm9taXNlOiByZWplY3RQcm9taXNlLFxuICByZXNldFZhbGlkYXRpb25NZXNzYWdlOiByZXNldFZhbGlkYXRpb25NZXNzYWdlLFxuICBzaG93VmFsaWRhdGlvbk1lc3NhZ2U6IHNob3dWYWxpZGF0aW9uTWVzc2FnZSxcbiAgdXBkYXRlOiB1cGRhdGVcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlUG9wdXBDbGljayA9IChpbm5lclBhcmFtcywgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gIGlmIChpbm5lclBhcmFtcy50b2FzdCkge1xuICAgIGhhbmRsZVRvYXN0Q2xpY2soaW5uZXJQYXJhbXMsIGRvbUNhY2hlLCBkaXNtaXNzV2l0aCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWdub3JlIGNsaWNrIGV2ZW50cyB0aGF0IGhhZCBtb3VzZWRvd24gb24gdGhlIHBvcHVwIGJ1dCBtb3VzZXVwIG9uIHRoZSBjb250YWluZXJcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgdXNlciBkcmFncyBhIHNsaWRlclxuICAgIGhhbmRsZU1vZGFsTW91c2Vkb3duKGRvbUNhY2hlKTtcblxuICAgIC8vIElnbm9yZSBjbGljayBldmVudHMgdGhhdCBoYWQgbW91c2Vkb3duIG9uIHRoZSBjb250YWluZXIgYnV0IG1vdXNldXAgb24gdGhlIHBvcHVwXG4gICAgaGFuZGxlQ29udGFpbmVyTW91c2Vkb3duKGRvbUNhY2hlKTtcbiAgICBoYW5kbGVNb2RhbENsaWNrKGlubmVyUGFyYW1zLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlVG9hc3RDbGljayA9IChpbm5lclBhcmFtcywgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gIC8vIENsb3NpbmcgdG9hc3QgYnkgaW50ZXJuYWwgY2xpY2tcbiAgZG9tQ2FjaGUucG9wdXAub25jbGljayA9ICgpID0+IHtcbiAgICBpZiAoaW5uZXJQYXJhbXMgJiYgKGlzQW55QnV0dG9uU2hvd24oaW5uZXJQYXJhbXMpIHx8IGlubmVyUGFyYW1zLnRpbWVyIHx8IGlubmVyUGFyYW1zLmlucHV0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaXNtaXNzV2l0aChEaXNtaXNzUmVhc29uLmNsb3NlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc0FueUJ1dHRvblNob3duID0gaW5uZXJQYXJhbXMgPT4ge1xuICByZXR1cm4gISEoaW5uZXJQYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24gfHwgaW5uZXJQYXJhbXMuc2hvd0RlbnlCdXR0b24gfHwgaW5uZXJQYXJhbXMuc2hvd0NhbmNlbEJ1dHRvbiB8fCBpbm5lclBhcmFtcy5zaG93Q2xvc2VCdXR0b24pO1xufTtcbmxldCBpZ25vcmVPdXRzaWRlQ2xpY2sgPSBmYWxzZTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICovXG5jb25zdCBoYW5kbGVNb2RhbE1vdXNlZG93biA9IGRvbUNhY2hlID0+IHtcbiAgZG9tQ2FjaGUucG9wdXAub25tb3VzZWRvd24gPSAoKSA9PiB7XG4gICAgZG9tQ2FjaGUuY29udGFpbmVyLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkb21DYWNoZS5jb250YWluZXIub25tb3VzZXVwID0gKCkgPT4ge307XG4gICAgICAvLyBXZSBvbmx5IGNoZWNrIGlmIHRoZSBtb3VzZXVwIHRhcmdldCBpcyB0aGUgY29udGFpbmVyIGJlY2F1c2UgdXN1YWxseSBpdCBkb2Vzbid0XG4gICAgICAvLyBoYXZlIGFueSBvdGhlciBkaXJlY3QgY2hpbGRyZW4gYXNpZGUgb2YgdGhlIHBvcHVwXG4gICAgICBpZiAoZS50YXJnZXQgPT09IGRvbUNhY2hlLmNvbnRhaW5lcikge1xuICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9tQ2FjaGV9IGRvbUNhY2hlXG4gKi9cbmNvbnN0IGhhbmRsZUNvbnRhaW5lck1vdXNlZG93biA9IGRvbUNhY2hlID0+IHtcbiAgZG9tQ2FjaGUuY29udGFpbmVyLm9ubW91c2Vkb3duID0gZSA9PiB7XG4gICAgLy8gcHJldmVudCB0aGUgbW9kYWwgdGV4dCBmcm9tIGJlaW5nIHNlbGVjdGVkIG9uIGRvdWJsZSBjbGljayBvbiB0aGUgY29udGFpbmVyIChhbGxvd091dHNpZGVDbGljazogZmFsc2UpXG4gICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5jb250YWluZXIpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZG9tQ2FjaGUucG9wdXAub25tb3VzZXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRvbUNhY2hlLnBvcHVwLm9ubW91c2V1cCA9ICgpID0+IHt9O1xuICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBtb3VzZXVwIHRhcmdldCBpcyBhIGNoaWxkIG9mIHRoZSBwb3B1cFxuICAgICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5wb3B1cCB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGRvbUNhY2hlLnBvcHVwLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlTW9kYWxDbGljayA9IChpbm5lclBhcmFtcywgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gIGRvbUNhY2hlLmNvbnRhaW5lci5vbmNsaWNrID0gZSA9PiB7XG4gICAgaWYgKGlnbm9yZU91dHNpZGVDbGljaykge1xuICAgICAgaWdub3JlT3V0c2lkZUNsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLnRhcmdldCA9PT0gZG9tQ2FjaGUuY29udGFpbmVyICYmIGNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93T3V0c2lkZUNsaWNrKSkge1xuICAgICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5iYWNrZHJvcCk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3QgaXNKcXVlcnlFbGVtZW50ID0gZWxlbSA9PiB0eXBlb2YgZWxlbSA9PT0gJ29iamVjdCcgJiYgZWxlbS5qcXVlcnk7XG5jb25zdCBpc0VsZW1lbnQgPSBlbGVtID0+IGVsZW0gaW5zdGFuY2VvZiBFbGVtZW50IHx8IGlzSnF1ZXJ5RWxlbWVudChlbGVtKTtcbmNvbnN0IGFyZ3NUb1BhcmFtcyA9IGFyZ3MgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiAhaXNFbGVtZW50KGFyZ3NbMF0pKSB7XG4gICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGFyZ3NbMF0pO1xuICB9IGVsc2Uge1xuICAgIFsndGl0bGUnLCAnaHRtbCcsICdpY29uJ10uZm9yRWFjaCgobmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IGlzRWxlbWVudChhcmcpKSB7XG4gICAgICAgIHBhcmFtc1tuYW1lXSA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBvZiAke25hbWV9ISBFeHBlY3RlZCBcInN0cmluZ1wiIG9yIFwiRWxlbWVudFwiLCBnb3QgJHt0eXBlb2YgYXJnfWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIE1haW4gbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBTd2VldEFsZXJ0MiBwb3B1cFxuICpcbiAqIEBwYXJhbSAgey4uLlN3ZWV0QWxlcnRPcHRpb25zfSBhcmdzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTd2VldEFsZXJ0UmVzdWx0Pn1cbiAqL1xuZnVuY3Rpb24gZmlyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gbmV3IHRoaXMoLi4uYXJncyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBleHRlbmRlZCB2ZXJzaW9uIG9mIGBTd2FsYCBjb250YWluaW5nIGBwYXJhbXNgIGFzIGRlZmF1bHRzLlxuICogVXNlZnVsIGZvciByZXVzaW5nIFN3YWwgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBCZWZvcmU6XG4gKiBjb25zdCB0ZXh0UHJvbXB0T3B0aW9ucyA9IHsgaW5wdXQ6ICd0ZXh0Jywgc2hvd0NhbmNlbEJ1dHRvbjogdHJ1ZSB9XG4gKiBjb25zdCB7dmFsdWU6IGZpcnN0TmFtZX0gPSBhd2FpdCBTd2FsLmZpcmUoeyAuLi50ZXh0UHJvbXB0T3B0aW9ucywgdGl0bGU6ICdXaGF0IGlzIHlvdXIgZmlyc3QgbmFtZT8nIH0pXG4gKiBjb25zdCB7dmFsdWU6IGxhc3ROYW1lfSA9IGF3YWl0IFN3YWwuZmlyZSh7IC4uLnRleHRQcm9tcHRPcHRpb25zLCB0aXRsZTogJ1doYXQgaXMgeW91ciBsYXN0IG5hbWU/JyB9KVxuICpcbiAqIEFmdGVyOlxuICogY29uc3QgVGV4dFByb21wdCA9IFN3YWwubWl4aW4oeyBpbnB1dDogJ3RleHQnLCBzaG93Q2FuY2VsQnV0dG9uOiB0cnVlIH0pXG4gKiBjb25zdCB7dmFsdWU6IGZpcnN0TmFtZX0gPSBhd2FpdCBUZXh0UHJvbXB0KCdXaGF0IGlzIHlvdXIgZmlyc3QgbmFtZT8nKVxuICogY29uc3Qge3ZhbHVlOiBsYXN0TmFtZX0gPSBhd2FpdCBUZXh0UHJvbXB0KCdXaGF0IGlzIHlvdXIgbGFzdCBuYW1lPycpXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gbWl4aW5QYXJhbXNcbiAqIEByZXR1cm5zIHtTd2VldEFsZXJ0fVxuICovXG5mdW5jdGlvbiBtaXhpbihtaXhpblBhcmFtcykge1xuICBjbGFzcyBNaXhpblN3YWwgZXh0ZW5kcyB0aGlzIHtcbiAgICBfbWFpbihwYXJhbXMsIHByaW9yaXR5TWl4aW5QYXJhbXMpIHtcbiAgICAgIHJldHVybiBzdXBlci5fbWFpbihwYXJhbXMsIE9iamVjdC5hc3NpZ24oe30sIG1peGluUGFyYW1zLCBwcmlvcml0eU1peGluUGFyYW1zKSk7XG4gICAgfVxuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIE1peGluU3dhbDtcbn1cblxuLyoqXG4gKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpcyBzZXQsIHJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAqIE90aGVyd2lzZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgZ2V0VGltZXJMZWZ0ID0gKCkgPT4ge1xuICByZXR1cm4gZ2xvYmFsU3RhdGUudGltZW91dCAmJiBnbG9iYWxTdGF0ZS50aW1lb3V0LmdldFRpbWVyTGVmdCgpO1xufTtcblxuLyoqXG4gKiBTdG9wIHRpbWVyLiBSZXR1cm5zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb2YgdGltZXIgcmVtYWluZWQuXG4gKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkLlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gKi9cbmNvbnN0IHN0b3BUaW1lciA9ICgpID0+IHtcbiAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQpIHtcbiAgICBzdG9wVGltZXJQcm9ncmVzc0JhcigpO1xuICAgIHJldHVybiBnbG9iYWxTdGF0ZS50aW1lb3V0LnN0b3AoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXN1bWUgdGltZXIuIFJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgcmVzdW1lVGltZXIgPSAoKSA9PiB7XG4gIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0KSB7XG4gICAgY29uc3QgcmVtYWluaW5nID0gZ2xvYmFsU3RhdGUudGltZW91dC5zdGFydCgpO1xuICAgIGFuaW1hdGVUaW1lclByb2dyZXNzQmFyKHJlbWFpbmluZyk7XG4gICAgcmV0dXJuIHJlbWFpbmluZztcbiAgfVxufTtcblxuLyoqXG4gKiBSZXN1bWUgdGltZXIuIFJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgdG9nZ2xlVGltZXIgPSAoKSA9PiB7XG4gIGNvbnN0IHRpbWVyID0gZ2xvYmFsU3RhdGUudGltZW91dDtcbiAgcmV0dXJuIHRpbWVyICYmICh0aW1lci5ydW5uaW5nID8gc3RvcFRpbWVyKCkgOiByZXN1bWVUaW1lcigpKTtcbn07XG5cbi8qKlxuICogSW5jcmVhc2UgdGltZXIuIFJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiBhbiB1cGRhdGVkIHRpbWVyLlxuICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXNuJ3Qgc2V0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcbiAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gKi9cbmNvbnN0IGluY3JlYXNlVGltZXIgPSBtcyA9PiB7XG4gIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0KSB7XG4gICAgY29uc3QgcmVtYWluaW5nID0gZ2xvYmFsU3RhdGUudGltZW91dC5pbmNyZWFzZShtcyk7XG4gICAgYW5pbWF0ZVRpbWVyUHJvZ3Jlc3NCYXIocmVtYWluaW5nLCB0cnVlKTtcbiAgICByZXR1cm4gcmVtYWluaW5nO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRpbWVyIGlzIHJ1bm5pbmcuIFJldHVybnMgdHJ1ZSBpZiB0aW1lciBpcyBydW5uaW5nXG4gKiBvciBmYWxzZSBpZiB0aW1lciBpcyBwYXVzZWQgb3Igc3RvcHBlZC5cbiAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNUaW1lclJ1bm5pbmcgPSAoKSA9PiB7XG4gIHJldHVybiAhIShnbG9iYWxTdGF0ZS50aW1lb3V0ICYmIGdsb2JhbFN0YXRlLnRpbWVvdXQuaXNSdW5uaW5nKCkpO1xufTtcblxubGV0IGJvZHlDbGlja0xpc3RlbmVyQWRkZWQgPSBmYWxzZTtcbmNvbnN0IGNsaWNrSGFuZGxlcnMgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICovXG5mdW5jdGlvbiBiaW5kQ2xpY2tIYW5kbGVyKCkge1xuICBsZXQgYXR0ciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2RhdGEtc3dhbC10ZW1wbGF0ZSc7XG4gIGNsaWNrSGFuZGxlcnNbYXR0cl0gPSB0aGlzO1xuICBpZiAoIWJvZHlDbGlja0xpc3RlbmVyQWRkZWQpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYm9keUNsaWNrTGlzdGVuZXIpO1xuICAgIGJvZHlDbGlja0xpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICB9XG59XG5jb25zdCBib2R5Q2xpY2tMaXN0ZW5lciA9IGV2ZW50ID0+IHtcbiAgZm9yIChsZXQgZWwgPSBldmVudC50YXJnZXQ7IGVsICYmIGVsICE9PSBkb2N1bWVudDsgZWwgPSBlbC5wYXJlbnROb2RlKSB7XG4gICAgZm9yIChjb25zdCBhdHRyIGluIGNsaWNrSGFuZGxlcnMpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIGNsaWNrSGFuZGxlcnNbYXR0cl0uZmlyZSh7XG4gICAgICAgICAgdGVtcGxhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIFNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbXVkZ2UvNTgzMDM4Mj9wZXJtYWxpbmtfY29tbWVudF9pZD0yNjkxOTU3I2dpc3Rjb21tZW50LTI2OTE5NTdcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHtFdmVudHN9ICovXG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEByZXR1cm5zIHtFdmVudEhhbmRsZXJzfVxuICAgKi9cbiAgX2dldEhhbmRsZXJzQnlFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmV2ZW50c1tldmVudE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbm90IFNldCBiZWNhdXNlIHdlIG5lZWQgdG8ga2VlcCB0aGUgRklGTyBvcmRlclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL3B1bGwvMjc2MyNkaXNjdXNzaW9uX3IxNzQ4OTkwMzM0XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV2ZW50c1tldmVudE5hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtFdmVudEhhbmRsZXJ9IGV2ZW50SGFuZGxlclxuICAgKi9cbiAgb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICBjb25zdCBjdXJyZW50SGFuZGxlcnMgPSB0aGlzLl9nZXRIYW5kbGVyc0J5RXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgaWYgKCFjdXJyZW50SGFuZGxlcnMuaW5jbHVkZXMoZXZlbnRIYW5kbGVyKSkge1xuICAgICAgY3VycmVudEhhbmRsZXJzLnB1c2goZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0V2ZW50SGFuZGxlcn0gZXZlbnRIYW5kbGVyXG4gICAqL1xuICBvbmNlKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAgICovXG4gICAgY29uc3Qgb25jZUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBvbmNlRm4pO1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBldmVudEhhbmRsZXIuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgdGhpcy5vbihldmVudE5hbWUsIG9uY2VGbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAqL1xuICBlbWl0KGV2ZW50TmFtZSkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICB0aGlzLl9nZXRIYW5kbGVyc0J5RXZlbnROYW1lKGV2ZW50TmFtZSkuZm9yRWFjaChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50SGFuZGxlcn0gZXZlbnRIYW5kbGVyXG4gICAgICovXG4gICAgZXZlbnRIYW5kbGVyID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV2ZW50SGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtFdmVudEhhbmRsZXJ9IGV2ZW50SGFuZGxlclxuICAgKi9cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICBjb25zdCBjdXJyZW50SGFuZGxlcnMgPSB0aGlzLl9nZXRIYW5kbGVyc0J5RXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgY29uc3QgaW5kZXggPSBjdXJyZW50SGFuZGxlcnMuaW5kZXhPZihldmVudEhhbmRsZXIpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICBjdXJyZW50SGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKi9cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICh0aGlzLmV2ZW50c1tldmVudE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9wdWxsLzI3NjMjZGlzY3Vzc2lvbl9yMTc0OTIzOTIyMlxuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICB9XG59XG5cbmdsb2JhbFN0YXRlLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcn0gZXZlbnRIYW5kbGVyXG4gKi9cbmNvbnN0IG9uID0gKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSA9PiB7XG4gIGdsb2JhbFN0YXRlLmV2ZW50RW1pdHRlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyfSBldmVudEhhbmRsZXJcbiAqL1xuY29uc3Qgb25jZSA9IChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikgPT4ge1xuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIub25jZShldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZlbnROYW1lXVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXJ9IFtldmVudEhhbmRsZXJdXG4gKi9cbmNvbnN0IG9mZiA9IChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikgPT4ge1xuICAvLyBSZW1vdmUgYWxsIGhhbmRsZXJzIGZvciBhbGwgZXZlbnRzXG4gIGlmICghZXZlbnROYW1lKSB7XG4gICAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLnJlc2V0KCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChldmVudEhhbmRsZXIpIHtcbiAgICAvLyBSZW1vdmUgYSBzcGVjaWZpYyBoYW5kbGVyXG4gICAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZW1vdmUgYWxsIGhhbmRsZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50XG4gICAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuICB9XG59O1xuXG52YXIgc3RhdGljTWV0aG9kcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhcmdzVG9QYXJhbXM6IGFyZ3NUb1BhcmFtcyxcbiAgYmluZENsaWNrSGFuZGxlcjogYmluZENsaWNrSGFuZGxlcixcbiAgY2xpY2tDYW5jZWw6IGNsaWNrQ2FuY2VsLFxuICBjbGlja0NvbmZpcm06IGNsaWNrQ29uZmlybSxcbiAgY2xpY2tEZW55OiBjbGlja0RlbnksXG4gIGVuYWJsZUxvYWRpbmc6IHNob3dMb2FkaW5nLFxuICBmaXJlOiBmaXJlLFxuICBnZXRBY3Rpb25zOiBnZXRBY3Rpb25zLFxuICBnZXRDYW5jZWxCdXR0b246IGdldENhbmNlbEJ1dHRvbixcbiAgZ2V0Q2xvc2VCdXR0b246IGdldENsb3NlQnV0dG9uLFxuICBnZXRDb25maXJtQnV0dG9uOiBnZXRDb25maXJtQnV0dG9uLFxuICBnZXRDb250YWluZXI6IGdldENvbnRhaW5lcixcbiAgZ2V0RGVueUJ1dHRvbjogZ2V0RGVueUJ1dHRvbixcbiAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6IGdldEZvY3VzYWJsZUVsZW1lbnRzLFxuICBnZXRGb290ZXI6IGdldEZvb3RlcixcbiAgZ2V0SHRtbENvbnRhaW5lcjogZ2V0SHRtbENvbnRhaW5lcixcbiAgZ2V0SWNvbjogZ2V0SWNvbixcbiAgZ2V0SWNvbkNvbnRlbnQ6IGdldEljb25Db250ZW50LFxuICBnZXRJbWFnZTogZ2V0SW1hZ2UsXG4gIGdldElucHV0TGFiZWw6IGdldElucHV0TGFiZWwsXG4gIGdldExvYWRlcjogZ2V0TG9hZGVyLFxuICBnZXRQb3B1cDogZ2V0UG9wdXAsXG4gIGdldFByb2dyZXNzU3RlcHM6IGdldFByb2dyZXNzU3RlcHMsXG4gIGdldFRpbWVyTGVmdDogZ2V0VGltZXJMZWZ0LFxuICBnZXRUaW1lclByb2dyZXNzQmFyOiBnZXRUaW1lclByb2dyZXNzQmFyLFxuICBnZXRUaXRsZTogZ2V0VGl0bGUsXG4gIGdldFZhbGlkYXRpb25NZXNzYWdlOiBnZXRWYWxpZGF0aW9uTWVzc2FnZSxcbiAgaW5jcmVhc2VUaW1lcjogaW5jcmVhc2VUaW1lcixcbiAgaXNEZXByZWNhdGVkUGFyYW1ldGVyOiBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIsXG4gIGlzTG9hZGluZzogaXNMb2FkaW5nLFxuICBpc1RpbWVyUnVubmluZzogaXNUaW1lclJ1bm5pbmcsXG4gIGlzVXBkYXRhYmxlUGFyYW1ldGVyOiBpc1VwZGF0YWJsZVBhcmFtZXRlcixcbiAgaXNWYWxpZFBhcmFtZXRlcjogaXNWYWxpZFBhcmFtZXRlcixcbiAgaXNWaXNpYmxlOiBpc1Zpc2libGUsXG4gIG1peGluOiBtaXhpbixcbiAgb2ZmOiBvZmYsXG4gIG9uOiBvbixcbiAgb25jZTogb25jZSxcbiAgcmVzdW1lVGltZXI6IHJlc3VtZVRpbWVyLFxuICBzaG93TG9hZGluZzogc2hvd0xvYWRpbmcsXG4gIHN0b3BUaW1lcjogc3RvcFRpbWVyLFxuICB0b2dnbGVUaW1lcjogdG9nZ2xlVGltZXJcbn0pO1xuXG5jbGFzcyBUaW1lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBkZWxheSkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnJlbWFpbmluZyA9IGRlbGF5O1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgdGhpcy5pZCA9IHNldFRpbWVvdXQodGhpcy5jYWxsYmFjaywgdGhpcy5yZW1haW5pbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCAmJiB0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xuICAgICAgdGhpcy5yZW1haW5pbmcgLT0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnN0YXJ0ZWQuZ2V0VGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGluY3JlYXNlKG4pIHtcbiAgICBjb25zdCBydW5uaW5nID0gdGhpcy5ydW5uaW5nO1xuICAgIGlmIChydW5uaW5nKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG4gICAgdGhpcy5yZW1haW5pbmcgKz0gbjtcbiAgICBpZiAocnVubmluZykge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldFRpbWVyTGVmdCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVtYWluaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gIH1cbn1cblxuY29uc3Qgc3dhbFN0cmluZ1BhcmFtcyA9IFsnc3dhbC10aXRsZScsICdzd2FsLWh0bWwnLCAnc3dhbC1mb290ZXInXTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqIEByZXR1cm5zIHtTd2VldEFsZXJ0T3B0aW9uc31cbiAqL1xuY29uc3QgZ2V0VGVtcGxhdGVQYXJhbXMgPSBwYXJhbXMgPT4ge1xuICBjb25zdCB0ZW1wbGF0ZSA9IHR5cGVvZiBwYXJhbXMudGVtcGxhdGUgPT09ICdzdHJpbmcnID8gKC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcmFtcy50ZW1wbGF0ZSkpIDogcGFyYW1zLnRlbXBsYXRlO1xuICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH0gKi9cbiAgY29uc3QgdGVtcGxhdGVDb250ZW50ID0gdGVtcGxhdGUuY29udGVudDtcbiAgc2hvd1dhcm5pbmdzRm9yRWxlbWVudHModGVtcGxhdGVDb250ZW50KTtcbiAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihnZXRTd2FsUGFyYW1zKHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxGdW5jdGlvblBhcmFtcyh0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsQnV0dG9ucyh0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsSW1hZ2UodGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbEljb24odGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbElucHV0KHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxTdHJpbmdQYXJhbXModGVtcGxhdGVDb250ZW50LCBzd2FsU3RyaW5nUGFyYW1zKSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuY29uc3QgZ2V0U3dhbFBhcmFtcyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX0gKi9cbiAgY29uc3Qgc3dhbFBhcmFtcyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtcGFyYW0nKSk7XG4gIHN3YWxQYXJhbXMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhwYXJhbSwgWyduYW1lJywgJ3ZhbHVlJ10pO1xuICAgIGNvbnN0IHBhcmFtTmFtZSA9IC8qKiBAdHlwZSB7a2V5b2YgU3dlZXRBbGVydE9wdGlvbnN9ICovcGFyYW0uZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJhbS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgaWYgKCFwYXJhbU5hbWUgfHwgIXZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVmYXVsdFBhcmFtc1twYXJhbU5hbWVdID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJlc3VsdFtwYXJhbU5hbWVdID0gdmFsdWUgIT09ICdmYWxzZSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdFBhcmFtc1twYXJhbU5hbWVdID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVzdWx0W3BhcmFtTmFtZV0gPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W3BhcmFtTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmNvbnN0IGdldFN3YWxGdW5jdGlvblBhcmFtcyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX0gKi9cbiAgY29uc3Qgc3dhbEZ1bmN0aW9ucyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtZnVuY3Rpb24tcGFyYW0nKSk7XG4gIHN3YWxGdW5jdGlvbnMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgY29uc3QgcGFyYW1OYW1lID0gLyoqIEB0eXBlIHtrZXlvZiBTd2VldEFsZXJ0T3B0aW9uc30gKi9wYXJhbS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcmFtLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICBpZiAoIXBhcmFtTmFtZSB8fCAhdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdWx0W3BhcmFtTmFtZV0gPSBuZXcgRnVuY3Rpb24oYHJldHVybiAke3ZhbHVlfWApKCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmNvbnN0IGdldFN3YWxCdXR0b25zID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqL1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudFtdfSAqL1xuICBjb25zdCBzd2FsQnV0dG9ucyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtYnV0dG9uJykpO1xuICBzd2FsQnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhidXR0b24sIFsndHlwZScsICdjb2xvcicsICdhcmlhLWxhYmVsJ10pO1xuICAgIGNvbnN0IHR5cGUgPSBidXR0b24uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgaWYgKCF0eXBlIHx8ICFbJ2NvbmZpcm0nLCAnY2FuY2VsJywgJ2RlbnknXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXN1bHRbYCR7dHlwZX1CdXR0b25UZXh0YF0gPSBidXR0b24uaW5uZXJIVE1MO1xuICAgIHJlc3VsdFtgc2hvdyR7Y2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHR5cGUpfUJ1dHRvbmBdID0gdHJ1ZTtcbiAgICBpZiAoYnV0dG9uLmhhc0F0dHJpYnV0ZSgnY29sb3InKSkge1xuICAgICAgcmVzdWx0W2Ake3R5cGV9QnV0dG9uQ29sb3JgXSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgfVxuICAgIGlmIChidXR0b24uaGFzQXR0cmlidXRlKCdhcmlhLWxhYmVsJykpIHtcbiAgICAgIHJlc3VsdFtgJHt0eXBlfUJ1dHRvbkFyaWFMYWJlbGBdID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gKiBAcmV0dXJucyB7UGljazxTd2VldEFsZXJ0T3B0aW9ucywgJ2ltYWdlVXJsJyB8ICdpbWFnZVdpZHRoJyB8ICdpbWFnZUhlaWdodCcgfCAnaW1hZ2VBbHQnPn1cbiAqL1xuY29uc3QgZ2V0U3dhbEltYWdlID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuICBjb25zdCBpbWFnZSA9IHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yKCdzd2FsLWltYWdlJyk7XG4gIGlmIChpbWFnZSkge1xuICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMoaW1hZ2UsIFsnc3JjJywgJ3dpZHRoJywgJ2hlaWdodCcsICdhbHQnXSk7XG4gICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnc3JjJykpIHtcbiAgICAgIHJlc3VsdC5pbWFnZVVybCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJykgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaW1hZ2UuaGFzQXR0cmlidXRlKCd3aWR0aCcpKSB7XG4gICAgICByZXN1bHQuaW1hZ2VXaWR0aCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpbWFnZS5oYXNBdHRyaWJ1dGUoJ2hlaWdodCcpKSB7XG4gICAgICByZXN1bHQuaW1hZ2VIZWlnaHQgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnYWx0JykpIHtcbiAgICAgIHJlc3VsdC5pbWFnZUFsdCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnYWx0JykgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmNvbnN0IGdldFN3YWxJY29uID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuICBjb25zdCBpY29uID0gdGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3N3YWwtaWNvbicpO1xuICBpZiAoaWNvbikge1xuICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMoaWNvbiwgWyd0eXBlJywgJ2NvbG9yJ10pO1xuICAgIGlmIChpY29uLmhhc0F0dHJpYnV0ZSgndHlwZScpKSB7XG4gICAgICByZXN1bHQuaWNvbiA9IGljb24uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgfVxuICAgIGlmIChpY29uLmhhc0F0dHJpYnV0ZSgnY29sb3InKSkge1xuICAgICAgcmVzdWx0Lmljb25Db2xvciA9IGljb24uZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuICAgIH1cbiAgICByZXN1bHQuaWNvbkh0bWwgPSBpY29uLmlubmVySFRNTDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmNvbnN0IGdldFN3YWxJbnB1dCA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuICBjb25zdCBpbnB1dCA9IHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yKCdzd2FsLWlucHV0Jyk7XG4gIGlmIChpbnB1dCkge1xuICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMoaW5wdXQsIFsndHlwZScsICdsYWJlbCcsICdwbGFjZWhvbGRlcicsICd2YWx1ZSddKTtcbiAgICByZXN1bHQuaW5wdXQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSB8fCAndGV4dCc7XG4gICAgaWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgnbGFiZWwnKSkge1xuICAgICAgcmVzdWx0LmlucHV0TGFiZWwgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykpIHtcbiAgICAgIHJlc3VsdC5pbnB1dFBsYWNlaG9sZGVyID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICByZXN1bHQuaW5wdXRWYWx1ZSA9IGlucHV0LmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudFtdfSAqL1xuICBjb25zdCBpbnB1dE9wdGlvbnMgPSBBcnJheS5mcm9tKHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzd2FsLWlucHV0LW9wdGlvbicpKTtcbiAgaWYgKGlucHV0T3B0aW9ucy5sZW5ndGgpIHtcbiAgICByZXN1bHQuaW5wdXRPcHRpb25zID0ge307XG4gICAgaW5wdXRPcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMob3B0aW9uLCBbJ3ZhbHVlJ10pO1xuICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25OYW1lID0gb3B0aW9uLmlubmVySFRNTDtcbiAgICAgIHJlc3VsdC5pbnB1dE9wdGlvbnNbb3B0aW9uVmFsdWVdID0gb3B0aW9uTmFtZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1OYW1lc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmNvbnN0IGdldFN3YWxTdHJpbmdQYXJhbXMgPSAodGVtcGxhdGVDb250ZW50LCBwYXJhbU5hbWVzKSA9PiB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgaSBpbiBwYXJhbU5hbWVzKSB7XG4gICAgY29uc3QgcGFyYW1OYW1lID0gcGFyYW1OYW1lc1tpXTtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgbnVsbH0gKi9cbiAgICBjb25zdCB0YWcgPSB0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3RvcihwYXJhbU5hbWUpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXModGFnLCBbXSk7XG4gICAgICByZXN1bHRbcGFyYW1OYW1lLnJlcGxhY2UoL15zd2FsLS8sICcnKV0gPSB0YWcuaW5uZXJIVE1MLnRyaW0oKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAqL1xuY29uc3Qgc2hvd1dhcm5pbmdzRm9yRWxlbWVudHMgPSB0ZW1wbGF0ZUNvbnRlbnQgPT4ge1xuICBjb25zdCBhbGxvd2VkRWxlbWVudHMgPSBzd2FsU3RyaW5nUGFyYW1zLmNvbmNhdChbJ3N3YWwtcGFyYW0nLCAnc3dhbC1mdW5jdGlvbi1wYXJhbScsICdzd2FsLWJ1dHRvbicsICdzd2FsLWltYWdlJywgJ3N3YWwtaWNvbicsICdzd2FsLWlucHV0JywgJ3N3YWwtaW5wdXQtb3B0aW9uJ10pO1xuICBBcnJheS5mcm9tKHRlbXBsYXRlQ29udGVudC5jaGlsZHJlbikuZm9yRWFjaChlbCA9PiB7XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIWFsbG93ZWRFbGVtZW50cy5pbmNsdWRlcyh0YWdOYW1lKSkge1xuICAgICAgd2FybihgVW5yZWNvZ25pemVkIGVsZW1lbnQgPCR7dGFnTmFtZX0+YCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFsbG93ZWRBdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMgPSAoZWwsIGFsbG93ZWRBdHRyaWJ1dGVzKSA9PiB7XG4gIEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyaWJ1dGUgPT4ge1xuICAgIGlmIChhbGxvd2VkQXR0cmlidXRlcy5pbmRleE9mKGF0dHJpYnV0ZS5uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHdhcm4oW2BVbnJlY29nbml6ZWQgYXR0cmlidXRlIFwiJHthdHRyaWJ1dGUubmFtZX1cIiBvbiA8JHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9Pi5gLCBgJHthbGxvd2VkQXR0cmlidXRlcy5sZW5ndGggPyBgQWxsb3dlZCBhdHRyaWJ1dGVzIGFyZTogJHthbGxvd2VkQXR0cmlidXRlcy5qb2luKCcsICcpfWAgOiAnVG8gc2V0IHRoZSB2YWx1ZSwgdXNlIEhUTUwgd2l0aGluIHRoZSBlbGVtZW50Lid9YF0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCBTSE9XX0NMQVNTX1RJTUVPVVQgPSAxMDtcblxuLyoqXG4gKiBPcGVuIHBvcHVwLCBhZGQgbmVjZXNzYXJ5IGNsYXNzZXMgYW5kIHN0eWxlcywgZml4IHNjcm9sbGJhclxuICpcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBvcGVuUG9wdXAgPSBwYXJhbXMgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAodHlwZW9mIHBhcmFtcy53aWxsT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBhcmFtcy53aWxsT3Blbihwb3B1cCk7XG4gIH1cbiAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLmVtaXQoJ3dpbGxPcGVuJywgcG9wdXApO1xuICBjb25zdCBib2R5U3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gIGNvbnN0IGluaXRpYWxCb2R5T3ZlcmZsb3cgPSBib2R5U3R5bGVzLm92ZXJmbG93WTtcbiAgYWRkQ2xhc3Nlcyhjb250YWluZXIsIHBvcHVwLCBwYXJhbXMpO1xuXG4gIC8vIHNjcm9sbGluZyBpcyAnaGlkZGVuJyB1bnRpbCBhbmltYXRpb24gaXMgZG9uZSwgYWZ0ZXIgdGhhdCAnYXV0bydcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgc2V0U2Nyb2xsaW5nVmlzaWJpbGl0eShjb250YWluZXIsIHBvcHVwKTtcbiAgfSwgU0hPV19DTEFTU19USU1FT1VUKTtcbiAgaWYgKGlzTW9kYWwoKSkge1xuICAgIGZpeFNjcm9sbENvbnRhaW5lcihjb250YWluZXIsIHBhcmFtcy5zY3JvbGxiYXJQYWRkaW5nLCBpbml0aWFsQm9keU92ZXJmbG93KTtcbiAgICBzZXRBcmlhSGlkZGVuKCk7XG4gIH1cbiAgaWYgKCFpc1RvYXN0KCkgJiYgIWdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCkge1xuICAgIGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXJhbXMuZGlkT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gcGFyYW1zLmRpZE9wZW4ocG9wdXApKTtcbiAgfVxuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIuZW1pdCgnZGlkT3BlbicsIHBvcHVwKTtcbiAgcmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlc1snbm8tdHJhbnNpdGlvbiddKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBbmltYXRpb25FdmVudH0gZXZlbnRcbiAqL1xuY29uc3Qgc3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZCA9IGV2ZW50ID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgcG9wdXAucmVtb3ZlRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgc3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZCk7XG4gIHBvcHVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2FsT3BlbkFuaW1hdGlvbkZpbmlzaGVkKTtcbiAgY29udGFpbmVyLnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICovXG5jb25zdCBzZXRTY3JvbGxpbmdWaXNpYmlsaXR5ID0gKGNvbnRhaW5lciwgcG9wdXApID0+IHtcbiAgaWYgKGhhc0Nzc0FuaW1hdGlvbihwb3B1cCkpIHtcbiAgICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG4gICAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgc3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZCk7XG4gICAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3YWxPcGVuQW5pbWF0aW9uRmluaXNoZWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNjcm9sbGJhclBhZGRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsQm9keU92ZXJmbG93XG4gKi9cbmNvbnN0IGZpeFNjcm9sbENvbnRhaW5lciA9IChjb250YWluZXIsIHNjcm9sbGJhclBhZGRpbmcsIGluaXRpYWxCb2R5T3ZlcmZsb3cpID0+IHtcbiAgaU9TZml4KCk7XG4gIGlmIChzY3JvbGxiYXJQYWRkaW5nICYmIGluaXRpYWxCb2R5T3ZlcmZsb3cgIT09ICdoaWRkZW4nKSB7XG4gICAgcmVwbGFjZVNjcm9sbGJhcldpdGhQYWRkaW5nKGluaXRpYWxCb2R5T3ZlcmZsb3cpO1xuICB9XG5cbiAgLy8gc3dlZXRhbGVydDIvaXNzdWVzLzEyNDdcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IDA7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgYWRkQ2xhc3NlcyA9IChjb250YWluZXIsIHBvcHVwLCBwYXJhbXMpID0+IHtcbiAgYWRkQ2xhc3MoY29udGFpbmVyLCBwYXJhbXMuc2hvd0NsYXNzLmJhY2tkcm9wKTtcbiAgaWYgKHBhcmFtcy5hbmltYXRpb24pIHtcbiAgICAvLyB0aGlzIHdvcmthcm91bmQgd2l0aCBvcGFjaXR5IGlzIG5lZWRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yMDU5XG4gICAgcG9wdXAuc3R5bGUuc2V0UHJvcGVydHkoJ29wYWNpdHknLCAnMCcsICdpbXBvcnRhbnQnKTtcbiAgICBzaG93KHBvcHVwLCAnZ3JpZCcpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gQW5pbWF0ZSBwb3B1cCByaWdodCBhZnRlciBzaG93aW5nIGl0XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgcGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7XG4gICAgICAvLyBhbmQgcmVtb3ZlIHRoZSBvcGFjaXR5IHdvcmthcm91bmRcbiAgICAgIHBvcHVwLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdvcGFjaXR5Jyk7XG4gICAgfSwgU0hPV19DTEFTU19USU1FT1VUKTsgLy8gMTBtcyBpbiBvcmRlciB0byBmaXggIzIwNjJcbiAgfSBlbHNlIHtcbiAgICBzaG93KHBvcHVwLCAnZ3JpZCcpO1xuICB9XG4gIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlcy5zaG93bik7XG4gIGlmIChwYXJhbXMuaGVpZ2h0QXV0byAmJiBwYXJhbXMuYmFja2Ryb3AgJiYgIXBhcmFtcy50b2FzdCkge1xuICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1snaGVpZ2h0LWF1dG8nXSk7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0SW5wdXRWYWxpZGF0b3JzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbGlkYXRpb25NZXNzYWdlXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmcgfCB2b2lkPn1cbiAgICovXG4gIGVtYWlsOiAoc3RyaW5nLCB2YWxpZGF0aW9uTWVzc2FnZSkgPT4ge1xuICAgIHJldHVybiAvXlthLXpBLVowLTkuK18nLV0rQFthLXpBLVowLTkuLV0rXFwuW2EtekEtWjAtOS1dKyQvLnRlc3Qoc3RyaW5nKSA/IFByb21pc2UucmVzb2x2ZSgpIDogUHJvbWlzZS5yZXNvbHZlKHZhbGlkYXRpb25NZXNzYWdlIHx8ICdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnKTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWxpZGF0aW9uTWVzc2FnZV1cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nIHwgdm9pZD59XG4gICAqL1xuICB1cmw6IChzdHJpbmcsIHZhbGlkYXRpb25NZXNzYWdlKSA9PiB7XG4gICAgLy8gdGFrZW4gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzgwOTQzNSB3aXRoIGEgc21hbGwgY2hhbmdlIGZyb20gIzEzMDYgYW5kICMyMDEzXG4gICAgcmV0dXJuIC9eaHR0cHM/OlxcL1xcLyh3d3dcXC4pP1stYS16QS1aMC05QDolLl8rfiM9XXsxLDI1Nn1cXC5bYS16XXsyLDYzfVxcYihbLWEtekEtWjAtOUA6JV8rLn4jPyYvPV0qKSQvLnRlc3Qoc3RyaW5nKSA/IFByb21pc2UucmVzb2x2ZSgpIDogUHJvbWlzZS5yZXNvbHZlKHZhbGlkYXRpb25NZXNzYWdlIHx8ICdJbnZhbGlkIFVSTCcpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5mdW5jdGlvbiBzZXREZWZhdWx0SW5wdXRWYWxpZGF0b3JzKHBhcmFtcykge1xuICAvLyBVc2UgZGVmYXVsdCBgaW5wdXRWYWxpZGF0b3JgIGZvciBzdXBwb3J0ZWQgaW5wdXQgdHlwZXMgaWYgbm90IHByb3ZpZGVkXG4gIGlmIChwYXJhbXMuaW5wdXRWYWxpZGF0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhcmFtcy5pbnB1dCA9PT0gJ2VtYWlsJykge1xuICAgIHBhcmFtcy5pbnB1dFZhbGlkYXRvciA9IGRlZmF1bHRJbnB1dFZhbGlkYXRvcnNbJ2VtYWlsJ107XG4gIH1cbiAgaWYgKHBhcmFtcy5pbnB1dCA9PT0gJ3VybCcpIHtcbiAgICBwYXJhbXMuaW5wdXRWYWxpZGF0b3IgPSBkZWZhdWx0SW5wdXRWYWxpZGF0b3JzWyd1cmwnXTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUN1c3RvbVRhcmdldEVsZW1lbnQocGFyYW1zKSB7XG4gIC8vIERldGVybWluZSBpZiB0aGUgY3VzdG9tIHRhcmdldCBlbGVtZW50IGlzIHZhbGlkXG4gIGlmICghcGFyYW1zLnRhcmdldCB8fCB0eXBlb2YgcGFyYW1zLnRhcmdldCA9PT0gJ3N0cmluZycgJiYgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyYW1zLnRhcmdldCkgfHwgdHlwZW9mIHBhcmFtcy50YXJnZXQgIT09ICdzdHJpbmcnICYmICFwYXJhbXMudGFyZ2V0LmFwcGVuZENoaWxkKSB7XG4gICAgd2FybignVGFyZ2V0IHBhcmFtZXRlciBpcyBub3QgdmFsaWQsIGRlZmF1bHRpbmcgdG8gXCJib2R5XCInKTtcbiAgICBwYXJhbXMudGFyZ2V0ID0gJ2JvZHknO1xuICB9XG59XG5cbi8qKlxuICogU2V0IHR5cGUsIHRleHQgYW5kIGFjdGlvbnMgb24gcG9wdXBcbiAqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gc2V0UGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgc2V0RGVmYXVsdElucHV0VmFsaWRhdG9ycyhwYXJhbXMpO1xuXG4gIC8vIHNob3dMb2FkZXJPbkNvbmZpcm0gJiYgcHJlQ29uZmlybVxuICBpZiAocGFyYW1zLnNob3dMb2FkZXJPbkNvbmZpcm0gJiYgIXBhcmFtcy5wcmVDb25maXJtKSB7XG4gICAgd2Fybignc2hvd0xvYWRlck9uQ29uZmlybSBpcyBzZXQgdG8gdHJ1ZSwgYnV0IHByZUNvbmZpcm0gaXMgbm90IGRlZmluZWQuXFxuJyArICdzaG93TG9hZGVyT25Db25maXJtIHNob3VsZCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggcHJlQ29uZmlybSwgc2VlIHVzYWdlIGV4YW1wbGU6XFxuJyArICdodHRwczovL3N3ZWV0YWxlcnQyLmdpdGh1Yi5pby8jYWpheC1yZXF1ZXN0Jyk7XG4gIH1cbiAgdmFsaWRhdGVDdXN0b21UYXJnZXRFbGVtZW50KHBhcmFtcyk7XG5cbiAgLy8gUmVwbGFjZSBuZXdsaW5lcyB3aXRoIDxicj4gaW4gdGl0bGVcbiAgaWYgKHR5cGVvZiBwYXJhbXMudGl0bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyYW1zLnRpdGxlID0gcGFyYW1zLnRpdGxlLnNwbGl0KCdcXG4nKS5qb2luKCc8YnIgLz4nKTtcbiAgfVxuICBpbml0KHBhcmFtcyk7XG59XG5cbi8qKiBAdHlwZSB7U3dlZXRBbGVydH0gKi9cbmxldCBjdXJyZW50SW5zdGFuY2U7XG52YXIgX3Byb21pc2UgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmNsYXNzIFN3ZWV0QWxlcnQge1xuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQHRoaXMge1N3ZWV0QWxlcnR9XG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvbWlzZTxTd2VldEFsZXJ0UmVzdWx0Pn1cbiAgICAgKi9cbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyh0aGlzLCBfcHJvbWlzZSwgdm9pZCAwKTtcbiAgICAvLyBQcmV2ZW50IHJ1biBpbiBOb2RlIGVudlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdXJyZW50SW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgY29uc3Qgb3V0ZXJQYXJhbXMgPSBPYmplY3QuZnJlZXplKHRoaXMuY29uc3RydWN0b3IuYXJnc1RvUGFyYW1zKGFyZ3MpKTtcblxuICAgIC8qKiBAdHlwZSB7UmVhZG9ubHk8U3dlZXRBbGVydE9wdGlvbnM+fSAqL1xuICAgIHRoaXMucGFyYW1zID0gb3V0ZXJQYXJhbXM7XG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc0F3YWl0aW5nUHJvbWlzZSA9IGZhbHNlO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIoX3Byb21pc2UsIHRoaXMsIHRoaXMuX21haW4oY3VycmVudEluc3RhbmNlLnBhcmFtcykpO1xuICB9XG4gIF9tYWluKHVzZXJQYXJhbXMpIHtcbiAgICBsZXQgbWl4aW5QYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHNob3dXYXJuaW5nc0ZvclBhcmFtcyhPYmplY3QuYXNzaWduKHt9LCBtaXhpblBhcmFtcywgdXNlclBhcmFtcykpO1xuICAgIGlmIChnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgIGNvbnN0IHN3YWxQcm9taXNlUmVzb2x2ZSA9IHByaXZhdGVNZXRob2RzLnN3YWxQcm9taXNlUmVzb2x2ZS5nZXQoZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNBd2FpdGluZ1Byb21pc2VcbiAgICAgIH0gPSBnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2U7XG4gICAgICBnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UuX2Rlc3Ryb3koKTtcbiAgICAgIGlmICghaXNBd2FpdGluZ1Byb21pc2UpIHtcbiAgICAgICAgc3dhbFByb21pc2VSZXNvbHZlKHtcbiAgICAgICAgICBpc0Rpc21pc3NlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc01vZGFsKCkpIHtcbiAgICAgICAgdW5zZXRBcmlhSGlkZGVuKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByZXBhcmVQYXJhbXModXNlclBhcmFtcywgbWl4aW5QYXJhbXMpO1xuICAgIHNldFBhcmFtZXRlcnMoaW5uZXJQYXJhbXMpO1xuICAgIE9iamVjdC5mcmVlemUoaW5uZXJQYXJhbXMpO1xuXG4gICAgLy8gY2xlYXIgdGhlIHByZXZpb3VzIHRpbWVyXG4gICAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQpIHtcbiAgICAgIGdsb2JhbFN0YXRlLnRpbWVvdXQuc3RvcCgpO1xuICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlLnRpbWVvdXQ7XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgdGhlIHJlc3RvcmUgZm9jdXMgdGltZW91dFxuICAgIGNsZWFyVGltZW91dChnbG9iYWxTdGF0ZS5yZXN0b3JlRm9jdXNUaW1lb3V0KTtcbiAgICBjb25zdCBkb21DYWNoZSA9IHBvcHVsYXRlRG9tQ2FjaGUoY3VycmVudEluc3RhbmNlKTtcbiAgICByZW5kZXIoY3VycmVudEluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLnNldChjdXJyZW50SW5zdGFuY2UsIGlubmVyUGFyYW1zKTtcbiAgICByZXR1cm4gc3dhbFByb21pc2UoY3VycmVudEluc3RhbmNlLCBkb21DYWNoZSwgaW5uZXJQYXJhbXMpO1xuICB9XG5cbiAgLy8gYGNhdGNoYCBjYW5ub3QgYmUgdGhlIG5hbWUgb2YgYSBtb2R1bGUgZXhwb3J0LCBzbyB3ZSBkZWZpbmUgb3VyIHRoZW5hYmxlIG1ldGhvZHMgaGVyZSBpbnN0ZWFkXG4gIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICByZXR1cm4gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfcHJvbWlzZSwgdGhpcykudGhlbihvbkZ1bGZpbGxlZCk7XG4gIH1cbiAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICByZXR1cm4gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfcHJvbWlzZSwgdGhpcykuZmluYWxseShvbkZpbmFsbHkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtEb21DYWNoZX0gZG9tQ2FjaGVcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuY29uc3Qgc3dhbFByb21pc2UgPSAoaW5zdGFuY2UsIGRvbUNhY2hlLCBpbm5lclBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIGZ1bmN0aW9ucyB0byBoYW5kbGUgYWxsIGNsb3NpbmdzL2Rpc21pc3NhbHNcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Rpc21pc3NSZWFzb259IGRpc21pc3NcbiAgICAgKi9cbiAgICBjb25zdCBkaXNtaXNzV2l0aCA9IGRpc21pc3MgPT4ge1xuICAgICAgaW5zdGFuY2UuY2xvc2Uoe1xuICAgICAgICBpc0Rpc21pc3NlZDogdHJ1ZSxcbiAgICAgICAgZGlzbWlzc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlc29sdmUuc2V0KGluc3RhbmNlLCByZXNvbHZlKTtcbiAgICBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlamVjdC5zZXQoaW5zdGFuY2UsIHJlamVjdCk7XG4gICAgZG9tQ2FjaGUuY29uZmlybUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaGFuZGxlQ29uZmlybUJ1dHRvbkNsaWNrKGluc3RhbmNlKTtcbiAgICB9O1xuICAgIGRvbUNhY2hlLmRlbnlCdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgIGhhbmRsZURlbnlCdXR0b25DbGljayhpbnN0YW5jZSk7XG4gICAgfTtcbiAgICBkb21DYWNoZS5jYW5jZWxCdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgIGhhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrKGluc3RhbmNlLCBkaXNtaXNzV2l0aCk7XG4gICAgfTtcbiAgICBkb21DYWNoZS5jbG9zZUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5jbG9zZSk7XG4gICAgfTtcbiAgICBoYW5kbGVQb3B1cENsaWNrKGlubmVyUGFyYW1zLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpO1xuICAgIGFkZEtleWRvd25IYW5kbGVyKGdsb2JhbFN0YXRlLCBpbm5lclBhcmFtcywgZGlzbWlzc1dpdGgpO1xuICAgIGhhbmRsZUlucHV0T3B0aW9uc0FuZFZhbHVlKGluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgb3BlblBvcHVwKGlubmVyUGFyYW1zKTtcbiAgICBzZXR1cFRpbWVyKGdsb2JhbFN0YXRlLCBpbm5lclBhcmFtcywgZGlzbWlzc1dpdGgpO1xuICAgIGluaXRGb2N1cyhkb21DYWNoZSwgaW5uZXJQYXJhbXMpO1xuXG4gICAgLy8gU2Nyb2xsIGNvbnRhaW5lciB0byB0b3Agb24gb3BlbiAoIzEyNDcsICMxOTQ2KVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZG9tQ2FjaGUuY29udGFpbmVyLnNjcm9sbFRvcCA9IDA7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSB1c2VyUGFyYW1zXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBtaXhpblBhcmFtc1xuICogQHJldHVybnMge1N3ZWV0QWxlcnRPcHRpb25zfVxuICovXG5jb25zdCBwcmVwYXJlUGFyYW1zID0gKHVzZXJQYXJhbXMsIG1peGluUGFyYW1zKSA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlUGFyYW1zID0gZ2V0VGVtcGxhdGVQYXJhbXModXNlclBhcmFtcyk7XG4gIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJhbXMsIG1peGluUGFyYW1zLCB0ZW1wbGF0ZVBhcmFtcywgdXNlclBhcmFtcyk7IC8vIHByZWNlZGVuY2UgaXMgZGVzY3JpYmVkIGluICMyMTMxXG4gIHBhcmFtcy5zaG93Q2xhc3MgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyYW1zLnNob3dDbGFzcywgcGFyYW1zLnNob3dDbGFzcyk7XG4gIHBhcmFtcy5oaWRlQ2xhc3MgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyYW1zLmhpZGVDbGFzcywgcGFyYW1zLmhpZGVDbGFzcyk7XG4gIGlmIChwYXJhbXMuYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgIHBhcmFtcy5zaG93Q2xhc3MgPSB7XG4gICAgICBiYWNrZHJvcDogJ3N3YWwyLW5vYW5pbWF0aW9uJ1xuICAgIH07XG4gICAgcGFyYW1zLmhpZGVDbGFzcyA9IHt9O1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtEb21DYWNoZX1cbiAqL1xuY29uc3QgcG9wdWxhdGVEb21DYWNoZSA9IGluc3RhbmNlID0+IHtcbiAgY29uc3QgZG9tQ2FjaGUgPSB7XG4gICAgcG9wdXA6IGdldFBvcHVwKCksXG4gICAgY29udGFpbmVyOiBnZXRDb250YWluZXIoKSxcbiAgICBhY3Rpb25zOiBnZXRBY3Rpb25zKCksXG4gICAgY29uZmlybUJ1dHRvbjogZ2V0Q29uZmlybUJ1dHRvbigpLFxuICAgIGRlbnlCdXR0b246IGdldERlbnlCdXR0b24oKSxcbiAgICBjYW5jZWxCdXR0b246IGdldENhbmNlbEJ1dHRvbigpLFxuICAgIGxvYWRlcjogZ2V0TG9hZGVyKCksXG4gICAgY2xvc2VCdXR0b246IGdldENsb3NlQnV0dG9uKCksXG4gICAgdmFsaWRhdGlvbk1lc3NhZ2U6IGdldFZhbGlkYXRpb25NZXNzYWdlKCksXG4gICAgcHJvZ3Jlc3NTdGVwczogZ2V0UHJvZ3Jlc3NTdGVwcygpXG4gIH07XG4gIHByaXZhdGVQcm9wcy5kb21DYWNoZS5zZXQoaW5zdGFuY2UsIGRvbUNhY2hlKTtcbiAgcmV0dXJuIGRvbUNhY2hlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0dsb2JhbFN0YXRlfSBnbG9iYWxTdGF0ZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc21pc3NXaXRoXG4gKi9cbmNvbnN0IHNldHVwVGltZXIgPSAoZ2xvYmFsU3RhdGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCkgPT4ge1xuICBjb25zdCB0aW1lclByb2dyZXNzQmFyID0gZ2V0VGltZXJQcm9ncmVzc0JhcigpO1xuICBoaWRlKHRpbWVyUHJvZ3Jlc3NCYXIpO1xuICBpZiAoaW5uZXJQYXJhbXMudGltZXIpIHtcbiAgICBnbG9iYWxTdGF0ZS50aW1lb3V0ID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgIGRpc21pc3NXaXRoKCd0aW1lcicpO1xuICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlLnRpbWVvdXQ7XG4gICAgfSwgaW5uZXJQYXJhbXMudGltZXIpO1xuICAgIGlmIChpbm5lclBhcmFtcy50aW1lclByb2dyZXNzQmFyKSB7XG4gICAgICBzaG93KHRpbWVyUHJvZ3Jlc3NCYXIpO1xuICAgICAgYXBwbHlDdXN0b21DbGFzcyh0aW1lclByb2dyZXNzQmFyLCBpbm5lclBhcmFtcywgJ3RpbWVyUHJvZ3Jlc3NCYXInKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoZ2xvYmFsU3RhdGUudGltZW91dCAmJiBnbG9iYWxTdGF0ZS50aW1lb3V0LnJ1bm5pbmcpIHtcbiAgICAgICAgICAvLyB0aW1lciBjYW4gYmUgYWxyZWFkeSBzdG9wcGVkIG9yIHVuc2V0IGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICBhbmltYXRlVGltZXJQcm9ncmVzc0Jhcihpbm5lclBhcmFtcy50aW1lcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGZvY3VzIGluIHRoZSBwb3B1cDpcbiAqXG4gKiAxLiBJZiBgdG9hc3RgIGlzIGB0cnVlYCwgZG9uJ3Qgc3RlYWwgZm9jdXMgZnJvbSB0aGUgZG9jdW1lbnQuXG4gKiAyLiBFbHNlIGlmIHRoZXJlIGlzIGFuIFthdXRvZm9jdXNdIGVsZW1lbnQsIGZvY3VzIGl0LlxuICogMy4gRWxzZSBpZiBgZm9jdXNDb25maXJtYCBpcyBgdHJ1ZWAgYW5kIGNvbmZpcm0gYnV0dG9uIGlzIHZpc2libGUsIGZvY3VzIGl0LlxuICogNC4gRWxzZSBpZiBgZm9jdXNEZW55YCBpcyBgdHJ1ZWAgYW5kIGRlbnkgYnV0dG9uIGlzIHZpc2libGUsIGZvY3VzIGl0LlxuICogNS4gRWxzZSBpZiBgZm9jdXNDYW5jZWxgIGlzIGB0cnVlYCBhbmQgY2FuY2VsIGJ1dHRvbiBpcyB2aXNpYmxlLCBmb2N1cyBpdC5cbiAqIDYuIEVsc2UgZm9jdXMgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IGluIGEgcG9wdXAgKGlmIGFueSkuXG4gKlxuICogQHBhcmFtIHtEb21DYWNoZX0gZG9tQ2FjaGVcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKi9cbmNvbnN0IGluaXRGb2N1cyA9IChkb21DYWNoZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgaWYgKGlubmVyUGFyYW1zLnRvYXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRPRE86IHRoaXMgaXMgZHVtYiwgcmVtb3ZlIGBhbGxvd0VudGVyS2V5YCBwYXJhbSBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG4gIGlmICghY2FsbElmRnVuY3Rpb24oaW5uZXJQYXJhbXMuYWxsb3dFbnRlcktleSkpIHtcbiAgICB3YXJuQWJvdXREZXByZWNhdGlvbignYWxsb3dFbnRlcktleScpO1xuICAgIGJsdXJBY3RpdmVFbGVtZW50KCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmb2N1c0F1dG9mb2N1cyhkb21DYWNoZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZvY3VzQnV0dG9uKGRvbUNhY2hlLCBpbm5lclBhcmFtcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2V0Rm9jdXMoLTEsIDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGZvY3VzQXV0b2ZvY3VzID0gZG9tQ2FjaGUgPT4ge1xuICBjb25zdCBhdXRvZm9jdXNFbGVtZW50cyA9IEFycmF5LmZyb20oZG9tQ2FjaGUucG9wdXAucXVlcnlTZWxlY3RvckFsbCgnW2F1dG9mb2N1c10nKSk7XG4gIGZvciAoY29uc3QgYXV0b2ZvY3VzRWxlbWVudCBvZiBhdXRvZm9jdXNFbGVtZW50cykge1xuICAgIGlmIChhdXRvZm9jdXNFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgaXNWaXNpYmxlJDEoYXV0b2ZvY3VzRWxlbWVudCkpIHtcbiAgICAgIGF1dG9mb2N1c0VsZW1lbnQuZm9jdXMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9tQ2FjaGV9IGRvbUNhY2hlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGZvY3VzQnV0dG9uID0gKGRvbUNhY2hlLCBpbm5lclBhcmFtcykgPT4ge1xuICBpZiAoaW5uZXJQYXJhbXMuZm9jdXNEZW55ICYmIGlzVmlzaWJsZSQxKGRvbUNhY2hlLmRlbnlCdXR0b24pKSB7XG4gICAgZG9tQ2FjaGUuZGVueUJ1dHRvbi5mb2N1cygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbm5lclBhcmFtcy5mb2N1c0NhbmNlbCAmJiBpc1Zpc2libGUkMShkb21DYWNoZS5jYW5jZWxCdXR0b24pKSB7XG4gICAgZG9tQ2FjaGUuY2FuY2VsQnV0dG9uLmZvY3VzKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlubmVyUGFyYW1zLmZvY3VzQ29uZmlybSAmJiBpc1Zpc2libGUkMShkb21DYWNoZS5jb25maXJtQnV0dG9uKSkge1xuICAgIGRvbUNhY2hlLmNvbmZpcm1CdXR0b24uZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgYmx1ckFjdGl2ZUVsZW1lbnQgPSAoKSA9PiB7XG4gIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdHlwZW9mIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICB9XG59O1xuXG4vLyBEZWFyIHJ1c3NpYW4gdXNlcnMgdmlzaXRpbmcgcnVzc2lhbiBzaXRlcy4gTGV0J3MgaGF2ZSBmdW4uXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgL15ydVxcYi8udGVzdChuYXZpZ2F0b3IubGFuZ3VhZ2UpICYmIGxvY2F0aW9uLmhvc3QubWF0Y2goL1xcLihydXxzdXxieXx4bi0tcDFhaSkkLykpIHtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgaW5pdGlhdGlvbkRhdGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc3dhbC1pbml0aWF0aW9uJyk7XG4gIGlmICghaW5pdGlhdGlvbkRhdGUpIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc3dhbC1pbml0aWF0aW9uJywgYCR7bm93fWApO1xuICB9IGVsc2UgaWYgKChub3cuZ2V0VGltZSgpIC0gRGF0ZS5wYXJzZShpbml0aWF0aW9uRGF0ZSkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpID4gMykge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgY29uc3QgdWtyYWluaWFuQW50aGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgICAgIHVrcmFpbmlhbkFudGhlbS5zcmMgPSAnaHR0cHM6Ly9mbGFnLWdpbW4ucnUvd3AtY29udGVudC91cGxvYWRzLzIwMjEvMDkvVWtyYWluYS5tcDMnO1xuICAgICAgdWtyYWluaWFuQW50aGVtLmxvb3AgPSB0cnVlO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh1a3JhaW5pYW5BbnRoZW0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHVrcmFpbmlhbkFudGhlbS5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9KTtcbiAgICAgIH0sIDI1MDApO1xuICAgIH0sIDUwMCk7XG4gIH1cbn1cblxuLy8gQXNzaWduIGluc3RhbmNlIG1ldGhvZHMgZnJvbSBzcmMvaW5zdGFuY2VNZXRob2RzLyouanMgdG8gcHJvdG90eXBlXG5Td2VldEFsZXJ0LnByb3RvdHlwZS5kaXNhYmxlQnV0dG9ucyA9IGRpc2FibGVCdXR0b25zO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuZW5hYmxlQnV0dG9ucyA9IGVuYWJsZUJ1dHRvbnM7XG5Td2VldEFsZXJ0LnByb3RvdHlwZS5nZXRJbnB1dCA9IGdldElucHV0O1xuU3dlZXRBbGVydC5wcm90b3R5cGUuZGlzYWJsZUlucHV0ID0gZGlzYWJsZUlucHV0O1xuU3dlZXRBbGVydC5wcm90b3R5cGUuZW5hYmxlSW5wdXQgPSBlbmFibGVJbnB1dDtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmhpZGVMb2FkaW5nID0gaGlkZUxvYWRpbmc7XG5Td2VldEFsZXJ0LnByb3RvdHlwZS5kaXNhYmxlTG9hZGluZyA9IGhpZGVMb2FkaW5nO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuc2hvd1ZhbGlkYXRpb25NZXNzYWdlID0gc2hvd1ZhbGlkYXRpb25NZXNzYWdlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUucmVzZXRWYWxpZGF0aW9uTWVzc2FnZSA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2U7XG5Td2VldEFsZXJ0LnByb3RvdHlwZS5jbG9zZSA9IGNsb3NlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuY2xvc2VQb3B1cCA9IGNsb3NlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuY2xvc2VNb2RhbCA9IGNsb3NlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuY2xvc2VUb2FzdCA9IGNsb3NlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUucmVqZWN0UHJvbWlzZSA9IHJlamVjdFByb21pc2U7XG5Td2VldEFsZXJ0LnByb3RvdHlwZS51cGRhdGUgPSB1cGRhdGU7XG5Td2VldEFsZXJ0LnByb3RvdHlwZS5fZGVzdHJveSA9IF9kZXN0cm95O1xuXG4vLyBBc3NpZ24gc3RhdGljIG1ldGhvZHMgZnJvbSBzcmMvc3RhdGljTWV0aG9kcy8qLmpzIHRvIGNvbnN0cnVjdG9yXG5PYmplY3QuYXNzaWduKFN3ZWV0QWxlcnQsIHN0YXRpY01ldGhvZHMpO1xuXG4vLyBQcm94eSB0byBpbnN0YW5jZSBtZXRob2RzIHRvIGNvbnN0cnVjdG9yLCBmb3Igbm93LCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbk9iamVjdC5rZXlzKGluc3RhbmNlTWV0aG9kcykuZm9yRWFjaChrZXkgPT4ge1xuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQHJldHVybnMge2FueSB8IHVuZGVmaW5lZH1cbiAgICovXG4gIFN3ZWV0QWxlcnRba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZVtrZXldKSB7XG4gICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlW2tleV0oLi4uYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59KTtcblN3ZWV0QWxlcnQuRGlzbWlzc1JlYXNvbiA9IERpc21pc3NSZWFzb247XG5Td2VldEFsZXJ0LnZlcnNpb24gPSAnMTEuMTcuMic7XG5cbmNvbnN0IFN3YWwgPSBTd2VldEFsZXJ0O1xuLy8gQHRzLWlnbm9yZVxuU3dhbC5kZWZhdWx0ID0gU3dhbDtcblxuZXhwb3J0IHsgU3dhbCBhcyBkZWZhdWx0IH07XG5cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7aWYoZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQobiksbi5zdHlsZVNoZWV0KW4uc3R5bGVTaGVldC5kaXNhYmxlZHx8KG4uc3R5bGVTaGVldC5jc3NUZXh0PXQpO2Vsc2UgdHJ5e24uaW5uZXJIVE1MPXR9Y2F0Y2goZSl7bi5pbm5lclRleHQ9dH19KGRvY3VtZW50LFwiOnJvb3R7LS1zd2FsMi1jb250YWluZXItcGFkZGluZzogMC42MjVlbTstLXN3YWwyLWJhY2tkcm9wOiByZ2JhKDAsIDAsIDAsIDAuNCk7LS1zd2FsMi13aWR0aDogMzJlbTstLXN3YWwyLXBhZGRpbmc6IDAgMCAxLjI1ZW07LS1zd2FsMi1ib3JkZXI6IG5vbmU7LS1zd2FsMi1ib3JkZXItcmFkaXVzOiAwLjMxMjVyZW07LS1zd2FsMi1iYWNrZ3JvdW5kOiB3aGl0ZTstLXN3YWwyLWNvbG9yOiAjNTQ1NDU0Oy0tc3dhbDItZm9vdGVyLWJvcmRlci1jb2xvcjogI2VlZTstLXN3YWwyLXNob3ctYW5pbWF0aW9uOiBzd2FsMi1zaG93IDAuM3M7LS1zd2FsMi1oaWRlLWFuaW1hdGlvbjogc3dhbDItaGlkZSAwLjE1cyBmb3J3YXJkczstLXN3YWwyLWlucHV0LWJhY2tncm91bmQ6IHRyYW5zcGFyZW50Oy0tc3dhbDItcHJvZ3Jlc3Mtc3RlcC1iYWNrZ3JvdW5kOiAjYWRkOGU2Oy0tc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdlLWJhY2tncm91bmQ6ICNmMGYwZjA7LS1zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2UtY29sb3I6ICM2NjY7LS1zd2FsMi1jbG9zZS1idXR0b24tcG9zaXRpb246IGluaXRpYWw7LS1zd2FsMi1jbG9zZS1idXR0b24taW5zZXQ6IGF1dG87LS1zd2FsMi1jbG9zZS1idXR0b24tZm9udC1zaXplOiAyLjVlbTstLXN3YWwyLWNsb3NlLWJ1dHRvbi1jb2xvcjogI2NjY31bZGF0YS1zd2FsMi10aGVtZT1kYXJrXXstLXN3YWwyLWRhcmstdGhlbWUtYmxhY2s6ICMxOTE5MWE7LS1zd2FsMi1kYXJrLXRoZW1lLXdoaXRlOiAjZTFlMWUxOy0tc3dhbDItYmFja2dyb3VuZDogdmFyKC0tc3dhbDItZGFyay10aGVtZS1ibGFjayk7LS1zd2FsMi1jb2xvcjogdmFyKC0tc3dhbDItZGFyay10aGVtZS13aGl0ZSk7LS1zd2FsMi1mb290ZXItYm9yZGVyLWNvbG9yOiAjNTU1Oy0tc3dhbDItaW5wdXQtYmFja2dyb3VuZDogY29sb3ItbWl4KGluIHNyZ2IsIHZhcigtLXN3YWwyLWRhcmstdGhlbWUtYmxhY2spLCB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLXdoaXRlKSAxMCUpOy0tc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdlLWJhY2tncm91bmQ6IGNvbG9yLW1peCggaW4gc3JnYiwgdmFyKC0tc3dhbDItZGFyay10aGVtZS1ibGFjayksIHZhcigtLXN3YWwyLWRhcmstdGhlbWUtd2hpdGUpIDEwJSApOy0tc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdlLWNvbG9yOiB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLXdoaXRlKX1AbWVkaWEocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspe1tkYXRhLXN3YWwyLXRoZW1lPWF1dG9dey0tc3dhbDItZGFyay10aGVtZS1ibGFjazogIzE5MTkxYTstLXN3YWwyLWRhcmstdGhlbWUtd2hpdGU6ICNlMWUxZTE7LS1zd2FsMi1iYWNrZ3JvdW5kOiB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLWJsYWNrKTstLXN3YWwyLWNvbG9yOiB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLXdoaXRlKTstLXN3YWwyLWZvb3Rlci1ib3JkZXItY29sb3I6ICM1NTU7LS1zd2FsMi1pbnB1dC1iYWNrZ3JvdW5kOiBjb2xvci1taXgoaW4gc3JnYiwgdmFyKC0tc3dhbDItZGFyay10aGVtZS1ibGFjayksIHZhcigtLXN3YWwyLWRhcmstdGhlbWUtd2hpdGUpIDEwJSk7LS1zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2UtYmFja2dyb3VuZDogY29sb3ItbWl4KCBpbiBzcmdiLCB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLWJsYWNrKSwgdmFyKC0tc3dhbDItZGFyay10aGVtZS13aGl0ZSkgMTAlICk7LS1zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2UtY29sb3I6IHZhcigtLXN3YWwyLWRhcmstdGhlbWUtd2hpdGUpfX1ib2R5LnN3YWwyLXNob3duOm5vdCguc3dhbDItbm8tYmFja2Ryb3AsLnN3YWwyLXRvYXN0LXNob3duKXtvdmVyZmxvdzpoaWRkZW59Ym9keS5zd2FsMi1oZWlnaHQtYXV0b3toZWlnaHQ6YXV0byAhaW1wb3J0YW50fWJvZHkuc3dhbDItbm8tYmFja2Ryb3AgLnN3YWwyLWNvbnRhaW5lcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsMCkgIWltcG9ydGFudDtwb2ludGVyLWV2ZW50czpub25lfWJvZHkuc3dhbDItbm8tYmFja2Ryb3AgLnN3YWwyLWNvbnRhaW5lciAuc3dhbDItcG9wdXB7cG9pbnRlci1ldmVudHM6YWxsfWJvZHkuc3dhbDItbm8tYmFja2Ryb3AgLnN3YWwyLWNvbnRhaW5lciAuc3dhbDItbW9kYWx7Ym94LXNoYWRvdzowIDAgMTBweCB2YXIoLS1zd2FsMi1iYWNrZHJvcCl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVye2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDozNjBweDttYXgtd2lkdGg6MTAwJTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsMCk7cG9pbnRlci1ldmVudHM6bm9uZX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9we2luc2V0OjAgYXV0byBhdXRvIDUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLWVuZCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXJpZ2h0e2luc2V0OjAgMCBhdXRvIGF1dG99Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1zdGFydCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLWxlZnR7aW5zZXQ6MCBhdXRvIGF1dG8gMH1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXN0YXJ0LGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItbGVmdHtpbnNldDo1MCUgYXV0byBhdXRvIDA7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlcntpbnNldDo1MCUgYXV0byBhdXRvIDUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsIC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItZW5kLGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItcmlnaHR7aW5zZXQ6NTAlIDAgYXV0byBhdXRvO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tc3RhcnQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1sZWZ0e2luc2V0OmF1dG8gYXV0byAwIDB9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbXtpbnNldDphdXRvIGF1dG8gMCA1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1lbmQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1yaWdodHtpbnNldDphdXRvIDAgMCBhdXRvfUBtZWRpYSBwcmludHtib2R5LnN3YWwyLXNob3duOm5vdCguc3dhbDItbm8tYmFja2Ryb3AsLnN3YWwyLXRvYXN0LXNob3duKXtvdmVyZmxvdy15OnNjcm9sbCAhaW1wb3J0YW50fWJvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCwuc3dhbDItdG9hc3Qtc2hvd24pPlthcmlhLWhpZGRlbj10cnVlXXtkaXNwbGF5Om5vbmV9Ym9keS5zd2FsMi1zaG93bjpub3QoLnN3YWwyLW5vLWJhY2tkcm9wLC5zd2FsMi10b2FzdC1zaG93bikgLnN3YWwyLWNvbnRhaW5lcntwb3NpdGlvbjpzdGF0aWMgIWltcG9ydGFudH19ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpe2Rpc3BsYXk6Z3JpZDtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwNjA7aW5zZXQ6MDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Z3JpZC10ZW1wbGF0ZS1hcmVhczpcXFwidG9wLXN0YXJ0ICAgICB0b3AgICAgICAgICAgICB0b3AtZW5kXFxcIiBcXFwiY2VudGVyLXN0YXJ0ICBjZW50ZXIgICAgICAgICBjZW50ZXItZW5kXFxcIiBcXFwiYm90dG9tLXN0YXJ0ICBib3R0b20tY2VudGVyICBib3R0b20tZW5kXFxcIjtncmlkLXRlbXBsYXRlLXJvd3M6bWlubWF4KG1pbi1jb250ZW50LCBhdXRvKSBtaW5tYXgobWluLWNvbnRlbnQsIGF1dG8pIG1pbm1heChtaW4tY29udGVudCwgYXV0byk7aGVpZ2h0OjEwMCU7cGFkZGluZzp2YXIoLS1zd2FsMi1jb250YWluZXItcGFkZGluZyk7b3ZlcmZsb3cteDpoaWRkZW47dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4xczstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItYmFja2Ryb3Atc2hvdyxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItbm9hbmltYXRpb257YmFja2dyb3VuZDp2YXIoLS1zd2FsMi1iYWNrZHJvcCl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWJhY2tkcm9wLWhpZGV7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApICFpbXBvcnRhbnR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLXRvcC1zdGFydCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyLXN0YXJ0LGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tc3RhcnR7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOm1pbm1heCgwLCAxZnIpIGF1dG8gYXV0b31kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItdG9wLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1jZW50ZXIsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWJvdHRvbXtncmlkLXRlbXBsYXRlLWNvbHVtbnM6YXV0byBtaW5tYXgoMCwgMWZyKSBhdXRvfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi10b3AtZW5kLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1jZW50ZXItZW5kLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tZW5ke2dyaWQtdGVtcGxhdGUtY29sdW1uczphdXRvIGF1dG8gbWlubWF4KDAsIDFmcil9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLXRvcC1zdGFydD4uc3dhbDItcG9wdXB7YWxpZ24tc2VsZjpzdGFydH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItdG9wPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoyO3BsYWNlLXNlbGY6c3RhcnQgY2VudGVyfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi10b3AtZW5kPi5zd2FsMi1wb3B1cCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItdG9wLXJpZ2h0Pi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjozO3BsYWNlLXNlbGY6c3RhcnQgZW5kfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1jZW50ZXItc3RhcnQ+LnN3YWwyLXBvcHVwLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1jZW50ZXItbGVmdD4uc3dhbDItcG9wdXB7Z3JpZC1yb3c6MjthbGlnbi1zZWxmOmNlbnRlcn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoyO2dyaWQtcm93OjI7cGxhY2Utc2VsZjpjZW50ZXIgY2VudGVyfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1jZW50ZXItZW5kPi5zd2FsMi1wb3B1cCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyLXJpZ2h0Pi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjozO2dyaWQtcm93OjI7cGxhY2Utc2VsZjpjZW50ZXIgZW5kfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tc3RhcnQ+LnN3YWwyLXBvcHVwLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tbGVmdD4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MTtncmlkLXJvdzozO2FsaWduLXNlbGY6ZW5kfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjI7Z3JpZC1yb3c6MztwbGFjZS1zZWxmOmVuZCBjZW50ZXJ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWJvdHRvbS1lbmQ+LnN3YWwyLXBvcHVwLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tcmlnaHQ+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjM7Z3JpZC1yb3c6MztwbGFjZS1zZWxmOmVuZCBlbmR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWdyb3ctcm93Pi5zd2FsMi1wb3B1cCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItZ3Jvdy1mdWxsc2NyZWVuPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoxLzQ7d2lkdGg6MTAwJX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItZ3Jvdy1jb2x1bW4+LnN3YWwyLXBvcHVwLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ncm93LWZ1bGxzY3JlZW4+LnN3YWwyLXBvcHVwe2dyaWQtcm93OjEvNDthbGlnbi1zZWxmOnN0cmV0Y2h9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLW5vLXRyYW5zaXRpb257dHJhbnNpdGlvbjpub25lICFpbXBvcnRhbnR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItcG9wdXApe2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmJvcmRlci1ib3g7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOm1pbm1heCgwLCAxMDAlKTt3aWR0aDp2YXIoLS1zd2FsMi13aWR0aCk7bWF4LXdpZHRoOjEwMCU7cGFkZGluZzp2YXIoLS1zd2FsMi1wYWRkaW5nKTtib3JkZXI6dmFyKC0tc3dhbDItYm9yZGVyKTtib3JkZXItcmFkaXVzOnZhcigtLXN3YWwyLWJvcmRlci1yYWRpdXMpO2JhY2tncm91bmQ6dmFyKC0tc3dhbDItYmFja2dyb3VuZCk7Y29sb3I6dmFyKC0tc3dhbDItY29sb3IpO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOjFyZW19ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItcG9wdXApOmZvY3Vze291dGxpbmU6bm9uZX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1wb3B1cCkuc3dhbDItbG9hZGluZ3tvdmVyZmxvdy15OmhpZGRlbn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1wb3B1cCkuc3dhbDItZHJhZ2dhYmxle2N1cnNvcjpncmFifWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLXBvcHVwKS5zd2FsMi1kcmFnZ2FibGUgZGl2OndoZXJlKC5zd2FsMi1pY29uKXtjdXJzb3I6Z3JhYn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1wb3B1cCkuc3dhbDItZHJhZ2dpbmd7Y3Vyc29yOmdyYWJiaW5nfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLXBvcHVwKS5zd2FsMi1kcmFnZ2luZyBkaXY6d2hlcmUoLnN3YWwyLWljb24pe2N1cnNvcjpncmFiYmluZ31kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaDI6d2hlcmUoLnN3YWwyLXRpdGxlKXtwb3NpdGlvbjpyZWxhdGl2ZTttYXgtd2lkdGg6MTAwJTttYXJnaW46MDtwYWRkaW5nOi44ZW0gMWVtIDA7Y29sb3I6aW5oZXJpdDtmb250LXNpemU6MS44NzVlbTtmb250LXdlaWdodDo2MDA7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC10cmFuc2Zvcm06bm9uZTt3b3JkLXdyYXA6YnJlYWstd29yZDtjdXJzb3I6aW5pdGlhbH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1hY3Rpb25zKXtkaXNwbGF5OmZsZXg7ei1pbmRleDoxO2JveC1zaXppbmc6Ym9yZGVyLWJveDtmbGV4LXdyYXA6d3JhcDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDphdXRvO21hcmdpbjoxLjI1ZW0gYXV0byAwO3BhZGRpbmc6MH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1hY3Rpb25zKTpub3QoLnN3YWwyLWxvYWRpbmcpIC5zd2FsMi1zdHlsZWRbZGlzYWJsZWRde29wYWNpdHk6LjR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItYWN0aW9ucyk6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkOmhvdmVye2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHJnYmEoMCwgMCwgMCwgMC4xKSwgcmdiYSgwLCAwLCAwLCAwLjEpKX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1hY3Rpb25zKTpub3QoLnN3YWwyLWxvYWRpbmcpIC5zd2FsMi1zdHlsZWQ6YWN0aXZle2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHJnYmEoMCwgMCwgMCwgMC4yKSwgcmdiYSgwLCAwLCAwLCAwLjIpKX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1sb2FkZXIpe2Rpc3BsYXk6bm9uZTthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDoyLjJlbTtoZWlnaHQ6Mi4yZW07bWFyZ2luOjAgMS44NzVlbTthbmltYXRpb246c3dhbDItcm90YXRlLWxvYWRpbmcgMS41cyBsaW5lYXIgMHMgaW5maW5pdGUgbm9ybWFsO2JvcmRlci13aWR0aDouMjVlbTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXJhZGl1czoxMDAlO2JvcmRlci1jb2xvcjojMjc3OGM0IHJnYmEoMCwwLDAsMCkgIzI3NzhjNCByZ2JhKDAsMCwwLDApfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCl7bWFyZ2luOi4zMTI1ZW07cGFkZGluZzouNjI1ZW0gMS4xZW07dHJhbnNpdGlvbjpib3gtc2hhZG93IC4xcztib3gtc2hhZG93OjAgMCAwIDNweCByZ2JhKDAsMCwwLDApO2ZvbnQtd2VpZ2h0OjUwMH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1zdHlsZWQpOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1zdHlsZWQpOndoZXJlKC5zd2FsMi1jb25maXJtKXtib3JkZXI6MDtib3JkZXItcmFkaXVzOi4yNWVtO2JhY2tncm91bmQ6aW5pdGlhbDtiYWNrZ3JvdW5kLWNvbG9yOiM3MDY2ZTA7Y29sb3I6I2ZmZjtmb250LXNpemU6MWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCk6d2hlcmUoLnN3YWwyLWNvbmZpcm0pOmZvY3VzLXZpc2libGV7Ym94LXNoYWRvdzowIDAgMCAzcHggcmdiYSgxMTIsMTAyLDIyNCwuNSl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTp3aGVyZSguc3dhbDItZGVueSl7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czouMjVlbTtiYWNrZ3JvdW5kOmluaXRpYWw7YmFja2dyb3VuZC1jb2xvcjojZGMzNzQxO2NvbG9yOiNmZmY7Zm9udC1zaXplOjFlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1zdHlsZWQpOndoZXJlKC5zd2FsMi1kZW55KTpmb2N1cy12aXNpYmxle2JveC1zaGFkb3c6MCAwIDAgM3B4IHJnYmEoMjIwLDU1LDY1LC41KX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1zdHlsZWQpOndoZXJlKC5zd2FsMi1jYW5jZWwpe2JvcmRlcjowO2JvcmRlci1yYWRpdXM6LjI1ZW07YmFja2dyb3VuZDppbml0aWFsO2JhY2tncm91bmQtY29sb3I6IzZlNzg4MTtjb2xvcjojZmZmO2ZvbnQtc2l6ZToxZW19ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTp3aGVyZSguc3dhbDItY2FuY2VsKTpmb2N1cy12aXNpYmxle2JveC1zaGFkb3c6MCAwIDAgM3B4IHJnYmEoMTEwLDEyMCwxMjksLjUpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCkuc3dhbDItZGVmYXVsdC1vdXRsaW5lOmZvY3VzLXZpc2libGV7Ym94LXNoYWRvdzowIDAgMCAzcHggcmdiYSgxMDAsMTUwLDIwMCwuNSl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTpmb2N1cy12aXNpYmxle291dGxpbmU6bm9uZX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1zdHlsZWQpOjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLWZvb3Rlcil7bWFyZ2luOjFlbSAwIDA7cGFkZGluZzoxZW0gMWVtIDA7Ym9yZGVyLXRvcDoxcHggc29saWQgdmFyKC0tc3dhbDItZm9vdGVyLWJvcmRlci1jb2xvcik7Y29sb3I6aW5oZXJpdDtmb250LXNpemU6MWVtO3RleHQtYWxpZ246Y2VudGVyO2N1cnNvcjppbml0aWFsfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDtncmlkLWNvbHVtbjphdXRvICFpbXBvcnRhbnQ7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOnZhcigtLXN3YWwyLWJvcmRlci1yYWRpdXMpO2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6dmFyKC0tc3dhbDItYm9yZGVyLXJhZGl1cyl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFyKXt3aWR0aDoxMDAlO2hlaWdodDouMjVlbTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjIpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBpbWc6d2hlcmUoLnN3YWwyLWltYWdlKXttYXgtd2lkdGg6MTAwJTttYXJnaW46MmVtIGF1dG8gMWVtO2N1cnNvcjppbml0aWFsfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLWNsb3NlKXtwb3NpdGlvbjp2YXIoLS1zd2FsMi1jbG9zZS1idXR0b24tcG9zaXRpb24pO2luc2V0OnZhcigtLXN3YWwyLWNsb3NlLWJ1dHRvbi1pbnNldCk7ei1pbmRleDoyO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEuMmVtO2hlaWdodDoxLjJlbTttYXJnaW4tdG9wOjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLWJvdHRvbTotMS4yZW07cGFkZGluZzowO292ZXJmbG93OmhpZGRlbjt0cmFuc2l0aW9uOmNvbG9yIC4xcyxib3gtc2hhZG93IC4xcztib3JkZXI6bm9uZTtib3JkZXItcmFkaXVzOnZhcigtLXN3YWwyLWJvcmRlci1yYWRpdXMpO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwwKTtjb2xvcjp2YXIoLS1zd2FsMi1jbG9zZS1idXR0b24tY29sb3IpO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTtmb250LXNpemU6dmFyKC0tc3dhbDItY2xvc2UtYnV0dG9uLWZvbnQtc2l6ZSk7Y3Vyc29yOnBvaW50ZXI7anVzdGlmeS1zZWxmOmVuZH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1jbG9zZSk6aG92ZXJ7dHJhbnNmb3JtOm5vbmU7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApO2NvbG9yOiNmMjc0NzR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItY2xvc2UpOmZvY3VzLXZpc2libGV7b3V0bGluZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgM3B4IHJnYmEoMTAwLDE1MCwyMDAsLjUpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLWNsb3NlKTo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1odG1sLWNvbnRhaW5lcil7ei1pbmRleDoxO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjA7cGFkZGluZzoxZW0gMS42ZW0gLjNlbTtvdmVyZmxvdzphdXRvO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuMTI1ZW07Zm9udC13ZWlnaHQ6bm9ybWFsO2xpbmUtaGVpZ2h0Om5vcm1hbDt0ZXh0LWFsaWduOmNlbnRlcjt3b3JkLXdyYXA6YnJlYWstd29yZDt3b3JkLWJyZWFrOmJyZWFrLXdvcmQ7Y3Vyc29yOmluaXRpYWx9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1pbnB1dCksZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1maWxlKSxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgdGV4dGFyZWE6d2hlcmUoLnN3YWwyLXRleHRhcmVhKSxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgc2VsZWN0OndoZXJlKC5zd2FsMi1zZWxlY3QpLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLXJhZGlvKSxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgbGFiZWw6d2hlcmUoLnN3YWwyLWNoZWNrYm94KXttYXJnaW46MWVtIDJlbSAzcHh9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1pbnB1dCksZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1maWxlKSxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgdGV4dGFyZWE6d2hlcmUoLnN3YWwyLXRleHRhcmVhKXtib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6YXV0bzt0cmFuc2l0aW9uOmJvcmRlci1jb2xvciAuMXMsYm94LXNoYWRvdyAuMXM7Ym9yZGVyOjFweCBzb2xpZCAjZDlkOWQ5O2JvcmRlci1yYWRpdXM6LjE4NzVlbTtiYWNrZ3JvdW5kOnZhcigtLXN3YWwyLWlucHV0LWJhY2tncm91bmQpO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjA2KSwwIDAgMCAzcHggcmdiYSgwLDAsMCwwKTtjb2xvcjppbmhlcml0O2ZvbnQtc2l6ZToxLjEyNWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBpbnB1dDp3aGVyZSguc3dhbDItaW5wdXQpLnN3YWwyLWlucHV0ZXJyb3IsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1maWxlKS5zd2FsMi1pbnB1dGVycm9yLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSB0ZXh0YXJlYTp3aGVyZSguc3dhbDItdGV4dGFyZWEpLnN3YWwyLWlucHV0ZXJyb3J7Ym9yZGVyLWNvbG9yOiNmMjc0NzQgIWltcG9ydGFudDtib3gtc2hhZG93OjAgMCAycHggI2YyNzQ3NCAhaW1wb3J0YW50fWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBpbnB1dDp3aGVyZSguc3dhbDItaW5wdXQpOmZvY3VzLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBpbnB1dDp3aGVyZSguc3dhbDItZmlsZSk6Zm9jdXMsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIHRleHRhcmVhOndoZXJlKC5zd2FsMi10ZXh0YXJlYSk6Zm9jdXN7Ym9yZGVyOjFweCBzb2xpZCAjYjRkYmVkO291dGxpbmU6bm9uZTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4wNiksMCAwIDAgM3B4IHJnYmEoMTAwLDE1MCwyMDAsLjUpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBpbnB1dDp3aGVyZSguc3dhbDItaW5wdXQpOjpwbGFjZWhvbGRlcixkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaW5wdXQ6d2hlcmUoLnN3YWwyLWZpbGUpOjpwbGFjZWhvbGRlcixkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgdGV4dGFyZWE6d2hlcmUoLnN3YWwyLXRleHRhcmVhKTo6cGxhY2Vob2xkZXJ7Y29sb3I6I2NjY31kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhbmdle21hcmdpbjoxZW0gMmVtIDNweDtiYWNrZ3JvdW5kOnZhcigtLXN3YWwyLWJhY2tncm91bmQpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcmFuZ2UgaW5wdXR7d2lkdGg6ODAlfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcmFuZ2Ugb3V0cHV0e3dpZHRoOjIwJTtjb2xvcjppbmhlcml0O2ZvbnQtd2VpZ2h0OjYwMDt0ZXh0LWFsaWduOmNlbnRlcn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhbmdlIGlucHV0LGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcmFuZ2Ugb3V0cHV0e2hlaWdodDoyLjYyNWVtO3BhZGRpbmc6MDtmb250LXNpemU6MS4xMjVlbTtsaW5lLWhlaWdodDoyLjYyNWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItaW5wdXR7aGVpZ2h0OjIuNjI1ZW07cGFkZGluZzowIC43NWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItZmlsZXt3aWR0aDo3NSU7bWFyZ2luLXJpZ2h0OmF1dG87bWFyZ2luLWxlZnQ6YXV0bztiYWNrZ3JvdW5kOnZhcigtLXN3YWwyLWlucHV0LWJhY2tncm91bmQpO2ZvbnQtc2l6ZToxLjEyNWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItdGV4dGFyZWF7aGVpZ2h0OjYuNzVlbTtwYWRkaW5nOi43NWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItc2VsZWN0e21pbi13aWR0aDo1MCU7bWF4LXdpZHRoOjEwMCU7cGFkZGluZzouMzc1ZW0gLjYyNWVtO2JhY2tncm91bmQ6dmFyKC0tc3dhbDItaW5wdXQtYmFja2dyb3VuZCk7Y29sb3I6aW5oZXJpdDtmb250LXNpemU6MS4xMjVlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhZGlvLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItY2hlY2tib3h7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7YmFja2dyb3VuZDp2YXIoLS1zd2FsMi1iYWNrZ3JvdW5kKTtjb2xvcjppbmhlcml0fWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcmFkaW8gbGFiZWwsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1jaGVja2JveCBsYWJlbHttYXJnaW46MCAuNmVtO2ZvbnQtc2l6ZToxLjEyNWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcmFkaW8gaW5wdXQsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1jaGVja2JveCBpbnB1dHtmbGV4LXNocmluazowO21hcmdpbjowIC40ZW19ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGxhYmVsOndoZXJlKC5zd2FsMi1pbnB1dC1sYWJlbCl7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjFlbSBhdXRvIDB9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdlKXthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW46MWVtIDAgMDtwYWRkaW5nOi42MjVlbTtvdmVyZmxvdzpoaWRkZW47YmFja2dyb3VuZDp2YXIoLS1zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2UtYmFja2dyb3VuZCk7Y29sb3I6dmFyKC0tc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdlLWNvbG9yKTtmb250LXNpemU6MWVtO2ZvbnQtd2VpZ2h0OjMwMH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2UpOjpiZWZvcmV7Y29udGVudDpcXFwiIVxcXCI7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MS41ZW07bWluLXdpZHRoOjEuNWVtO2hlaWdodDoxLjVlbTttYXJnaW46MCAuNjI1ZW07Ym9yZGVyLXJhZGl1czo1MCU7YmFja2dyb3VuZC1jb2xvcjojZjI3NDc0O2NvbG9yOiNmZmY7Zm9udC13ZWlnaHQ6NjAwO2xpbmUtaGVpZ2h0OjEuNWVtO3RleHQtYWxpZ246Y2VudGVyfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcHJvZ3Jlc3Mtc3RlcHN7ZmxleC13cmFwOndyYXA7YWxpZ24taXRlbXM6Y2VudGVyO21heC13aWR0aDoxMDAlO21hcmdpbjoxLjI1ZW0gYXV0bztwYWRkaW5nOjA7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApO2ZvbnQtd2VpZ2h0OjYwMH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXByb2dyZXNzLXN0ZXBzIGxpe2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXB7ei1pbmRleDoyMDtmbGV4LXNocmluazowO3dpZHRoOjJlbTtoZWlnaHQ6MmVtO2JvcmRlci1yYWRpdXM6MmVtO2JhY2tncm91bmQ6IzI3NzhjNDtjb2xvcjojZmZmO2xpbmUtaGVpZ2h0OjJlbTt0ZXh0LWFsaWduOmNlbnRlcn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXByb2dyZXNzLXN0ZXBzIC5zd2FsMi1wcm9ncmVzcy1zdGVwLnN3YWwyLWFjdGl2ZS1wcm9ncmVzcy1zdGVwe2JhY2tncm91bmQ6IzI3NzhjNH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXByb2dyZXNzLXN0ZXBzIC5zd2FsMi1wcm9ncmVzcy1zdGVwLnN3YWwyLWFjdGl2ZS1wcm9ncmVzcy1zdGVwfi5zd2FsMi1wcm9ncmVzcy1zdGVwe2JhY2tncm91bmQ6dmFyKC0tc3dhbDItcHJvZ3Jlc3Mtc3RlcC1iYWNrZ3JvdW5kKTtjb2xvcjojZmZmfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXAuc3dhbDItYWN0aXZlLXByb2dyZXNzLXN0ZXB+LnN3YWwyLXByb2dyZXNzLXN0ZXAtbGluZXtiYWNrZ3JvdW5kOnZhcigtLXN3YWwyLXByb2dyZXNzLXN0ZXAtYmFja2dyb3VuZCl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcC1saW5le3otaW5kZXg6MTA7ZmxleC1zaHJpbms6MDt3aWR0aDoyLjVlbTtoZWlnaHQ6LjRlbTttYXJnaW46MCAtMXB4O2JhY2tncm91bmQ6IzI3NzhjNH1kaXY6d2hlcmUoLnN3YWwyLWljb24pe3Bvc2l0aW9uOnJlbGF0aXZlO2JveC1zaXppbmc6Y29udGVudC1ib3g7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDo1ZW07aGVpZ2h0OjVlbTttYXJnaW46Mi41ZW0gYXV0byAuNmVtO2JvcmRlcjouMjVlbSBzb2xpZCByZ2JhKDAsMCwwLDApO2JvcmRlci1yYWRpdXM6NTAlO2JvcmRlci1jb2xvcjojMDAwO2ZvbnQtZmFtaWx5OmluaGVyaXQ7bGluZS1oZWlnaHQ6NWVtO2N1cnNvcjpkZWZhdWx0O3VzZXItc2VsZWN0Om5vbmV9ZGl2OndoZXJlKC5zd2FsMi1pY29uKSAuc3dhbDItaWNvbi1jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOjMuNzVlbX1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLWVycm9ye2JvcmRlci1jb2xvcjojZjI3NDc0O2NvbG9yOiNmMjc0NzR9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1lcnJvciAuc3dhbDIteC1tYXJre3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtZ3JvdzoxfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV17ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6Mi4zMTI1ZW07d2lkdGg6Mi45Mzc1ZW07aGVpZ2h0Oi4zMTI1ZW07Ym9yZGVyLXJhZGl1czouMTI1ZW07YmFja2dyb3VuZC1jb2xvcjojZjI3NDc0fWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV1bY2xhc3MkPWxlZnRde2xlZnQ6MS4wNjI1ZW07dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9cmlnaHRde3JpZ2h0OjFlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1lcnJvci5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1lcnJvci5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXgtbWFya3thbmltYXRpb246c3dhbDItYW5pbWF0ZS1lcnJvci14LW1hcmsgLjVzfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItd2FybmluZ3tib3JkZXItY29sb3I6I2Y4YmI4Njtjb2xvcjojZjhiYjg2fWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItd2FybmluZy5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi13YXJuaW5nLnN3YWwyLWljb24tc2hvdyAuc3dhbDItaWNvbi1jb250ZW50e2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWktbWFyayAuNXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1pbmZve2JvcmRlci1jb2xvcjojM2ZjM2VlO2NvbG9yOiMzZmMzZWV9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1pbmZvLnN3YWwyLWljb24tc2hvd3thbmltYXRpb246c3dhbDItYW5pbWF0ZS1lcnJvci1pY29uIC41c31kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLWluZm8uc3dhbDItaWNvbi1zaG93IC5zd2FsMi1pY29uLWNvbnRlbnR7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtaS1tYXJrIC44c31kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXF1ZXN0aW9ue2JvcmRlci1jb2xvcjojODdhZGJkO2NvbG9yOiM4N2FkYmR9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1xdWVzdGlvbi5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1xdWVzdGlvbi5zd2FsMi1pY29uLXNob3cgLnN3YWwyLWljb24tY29udGVudHthbmltYXRpb246c3dhbDItYW5pbWF0ZS1xdWVzdGlvbi1tYXJrIC44c31kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXN1Y2Nlc3N7Ym9yZGVyLWNvbG9yOiNhNWRjODY7Y29sb3I6I2E1ZGM4Nn1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVde3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjMuNzVlbTtoZWlnaHQ6Ny41ZW07Ym9yZGVyLXJhZGl1czo1MCV9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9bGVmdF17dG9wOi0wLjQzNzVlbTtsZWZ0Oi0yLjA2MzVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtLW9yaWdpbjozLjc1ZW0gMy43NWVtO2JvcmRlci1yYWRpdXM6Ny41ZW0gMCAwIDcuNWVtfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPXJpZ2h0XXt0b3A6LTAuNjg3NWVtO2xlZnQ6MS44NzVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtLW9yaWdpbjowIDMuNzVlbTtib3JkZXItcmFkaXVzOjAgNy41ZW0gNy41ZW0gMH1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3twb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjI7dG9wOi0wLjI1ZW07bGVmdDotMC4yNWVtO2JveC1zaXppbmc6Y29udGVudC1ib3g7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3JkZXI6LjI1ZW0gc29saWQgcmdiYSgxNjUsMjIwLDEzNCwuMyk7Ym9yZGVyLXJhZGl1czo1MCV9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLWZpeHtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjE7dG9wOi41ZW07bGVmdDoxLjYyNWVtO3dpZHRoOi40Mzc1ZW07aGVpZ2h0OjUuNjI1ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV17ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjI7aGVpZ2h0Oi4zMTI1ZW07Ym9yZGVyLXJhZGl1czouMTI1ZW07YmFja2dyb3VuZC1jb2xvcjojYTVkYzg2fWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPXRpcF17dG9wOjIuODc1ZW07bGVmdDouODEyNWVtO3dpZHRoOjEuNTYyNWVtO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPWxvbmdde3RvcDoyLjM3NWVtO3JpZ2h0Oi41ZW07d2lkdGg6Mi45Mzc1ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtbGluZS10aXB7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcCAuNzVzfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtbGluZS1sb25ne2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nIC43NXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lLXJpZ2h0e2FuaW1hdGlvbjpzd2FsMi1yb3RhdGUtc3VjY2Vzcy1jaXJjdWxhci1saW5lIDQuMjVzIGVhc2UtaW59W2NsYXNzXj1zd2FsMl17LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnJnYmEoMCwwLDAsMCl9LnN3YWwyLXNob3d7YW5pbWF0aW9uOnZhcigtLXN3YWwyLXNob3ctYW5pbWF0aW9uKX0uc3dhbDItaGlkZXthbmltYXRpb246dmFyKC0tc3dhbDItaGlkZS1hbmltYXRpb24pfS5zd2FsMi1ub2FuaW1hdGlvbnt0cmFuc2l0aW9uOm5vbmV9LnN3YWwyLXNjcm9sbGJhci1tZWFzdXJle3Bvc2l0aW9uOmFic29sdXRlO3RvcDotOTk5OXB4O3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7b3ZlcmZsb3c6c2Nyb2xsfS5zd2FsMi1ydGwgLnN3YWwyLWNsb3Nle21hcmdpbi1yaWdodDppbml0aWFsO21hcmdpbi1sZWZ0OjB9LnN3YWwyLXJ0bCAuc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFye3JpZ2h0OjA7bGVmdDphdXRvfS5zd2FsMi10b2FzdHtib3gtc2l6aW5nOmJvcmRlci1ib3g7Z3JpZC1jb2x1bW46MS80ICFpbXBvcnRhbnQ7Z3JpZC1yb3c6MS80ICFpbXBvcnRhbnQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOm1pbi1jb250ZW50IGF1dG8gbWluLWNvbnRlbnQ7cGFkZGluZzoxZW07b3ZlcmZsb3cteTpoaWRkZW47YmFja2dyb3VuZDp2YXIoLS1zd2FsMi1iYWNrZ3JvdW5kKTtib3gtc2hhZG93OjAgMCAxcHggcmdiYSgwLDAsMCwuMDc1KSwwIDFweCAycHggcmdiYSgwLDAsMCwuMDc1KSwxcHggMnB4IDRweCByZ2JhKDAsMCwwLC4wNzUpLDFweCAzcHggOHB4IHJnYmEoMCwwLDAsLjA3NSksMnB4IDRweCAxNnB4IHJnYmEoMCwwLDAsLjA3NSk7cG9pbnRlci1ldmVudHM6YWxsfS5zd2FsMi10b2FzdD4qe2dyaWQtY29sdW1uOjJ9LnN3YWwyLXRvYXN0IGgyOndoZXJlKC5zd2FsMi10aXRsZSl7bWFyZ2luOi41ZW0gMWVtO3BhZGRpbmc6MDtmb250LXNpemU6MWVtO3RleHQtYWxpZ246aW5pdGlhbH0uc3dhbDItdG9hc3QgLnN3YWwyLWxvYWRpbmd7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uc3dhbDItdG9hc3QgaW5wdXQ6d2hlcmUoLnN3YWwyLWlucHV0KXtoZWlnaHQ6MmVtO21hcmdpbjouNWVtO2ZvbnQtc2l6ZToxZW19LnN3YWwyLXRvYXN0IC5zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2V7Zm9udC1zaXplOjFlbX0uc3dhbDItdG9hc3QgZGl2OndoZXJlKC5zd2FsMi1mb290ZXIpe21hcmdpbjouNWVtIDAgMDtwYWRkaW5nOi41ZW0gMCAwO2ZvbnQtc2l6ZTouOGVtfS5zd2FsMi10b2FzdCBidXR0b246d2hlcmUoLnN3YWwyLWNsb3NlKXtncmlkLWNvbHVtbjozLzM7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDouOGVtO2hlaWdodDouOGVtO21hcmdpbjowO2ZvbnQtc2l6ZToyZW19LnN3YWwyLXRvYXN0IGRpdjp3aGVyZSguc3dhbDItaHRtbC1jb250YWluZXIpe21hcmdpbjouNWVtIDFlbTtwYWRkaW5nOjA7b3ZlcmZsb3c6aW5pdGlhbDtmb250LXNpemU6MWVtO3RleHQtYWxpZ246aW5pdGlhbH0uc3dhbDItdG9hc3QgZGl2OndoZXJlKC5zd2FsMi1odG1sLWNvbnRhaW5lcik6ZW1wdHl7cGFkZGluZzowfS5zd2FsMi10b2FzdCAuc3dhbDItbG9hZGVye2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDoyZW07aGVpZ2h0OjJlbTttYXJnaW46LjI1ZW19LnN3YWwyLXRvYXN0IC5zd2FsMi1pY29ue2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDoyZW07bWluLXdpZHRoOjJlbTtoZWlnaHQ6MmVtO21hcmdpbjowIC41ZW0gMCAwfS5zd2FsMi10b2FzdCAuc3dhbDItaWNvbiAuc3dhbDItaWNvbi1jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOjEuOGVtO2ZvbnQtd2VpZ2h0OmJvbGR9LnN3YWwyLXRvYXN0IC5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3t3aWR0aDoyZW07aGVpZ2h0OjJlbX0uc3dhbDItdG9hc3QgLnN3YWwyLWljb24uc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV17dG9wOi44NzVlbTt3aWR0aDoxLjM3NWVtfS5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9bGVmdF17bGVmdDouMzEyNWVtfS5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9cmlnaHRde3JpZ2h0Oi4zMTI1ZW19LnN3YWwyLXRvYXN0IGRpdjp3aGVyZSguc3dhbDItYWN0aW9ucyl7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7aGVpZ2h0OmF1dG87bWFyZ2luOjA7bWFyZ2luLXRvcDouNWVtO3BhZGRpbmc6MCAuNWVtfS5zd2FsMi10b2FzdCBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCl7bWFyZ2luOi4yNWVtIC41ZW07cGFkZGluZzouNGVtIC42ZW07Zm9udC1zaXplOjFlbX0uc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3N7Ym9yZGVyLWNvbG9yOiNhNWRjODZ9LnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxLjZlbTtoZWlnaHQ6M2VtO2JvcmRlci1yYWRpdXM6NTAlfS5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPWxlZnRde3RvcDotMC44ZW07bGVmdDotMC41ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybS1vcmlnaW46MmVtIDJlbTtib3JkZXItcmFkaXVzOjRlbSAwIDAgNGVtfS5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPXJpZ2h0XXt0b3A6LTAuMjVlbTtsZWZ0Oi45Mzc1ZW07dHJhbnNmb3JtLW9yaWdpbjowIDEuNWVtO2JvcmRlci1yYWRpdXM6MCA0ZW0gNGVtIDB9LnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLXJpbmd7d2lkdGg6MmVtO2hlaWdodDoyZW19LnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLWZpeHt0b3A6MDtsZWZ0Oi40Mzc1ZW07d2lkdGg6LjQzNzVlbTtoZWlnaHQ6Mi42ODc1ZW19LnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXXtoZWlnaHQ6LjMxMjVlbX0uc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD10aXBde3RvcDoxLjEyNWVtO2xlZnQ6LjE4NzVlbTt3aWR0aDouNzVlbX0uc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD1sb25nXXt0b3A6LjkzNzVlbTtyaWdodDouMTg3NWVtO3dpZHRoOjEuMzc1ZW19LnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1saW5lLXRpcHthbmltYXRpb246c3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwIC43NXN9LnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1saW5lLWxvbmd7YW5pbWF0aW9uOnN3YWwyLXRvYXN0LWFuaW1hdGUtc3VjY2Vzcy1saW5lLWxvbmcgLjc1c30uc3dhbDItdG9hc3Quc3dhbDItc2hvd3thbmltYXRpb246c3dhbDItdG9hc3Qtc2hvdyAuNXN9LnN3YWwyLXRvYXN0LnN3YWwyLWhpZGV7YW5pbWF0aW9uOnN3YWwyLXRvYXN0LWhpZGUgLjFzIGZvcndhcmRzfUBrZXlmcmFtZXMgc3dhbDItc2hvd3swJXt0cmFuc2Zvcm06c2NhbGUoMC43KX00NSV7dHJhbnNmb3JtOnNjYWxlKDEuMDUpfTgwJXt0cmFuc2Zvcm06c2NhbGUoMC45NSl9MTAwJXt0cmFuc2Zvcm06c2NhbGUoMSl9fUBrZXlmcmFtZXMgc3dhbDItaGlkZXswJXt0cmFuc2Zvcm06c2NhbGUoMSk7b3BhY2l0eToxfTEwMCV7dHJhbnNmb3JtOnNjYWxlKDAuNSk7b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcHswJXt0b3A6MS4xODc1ZW07bGVmdDouMDYyNWVtO3dpZHRoOjB9NTQle3RvcDoxLjA2MjVlbTtsZWZ0Oi4xMjVlbTt3aWR0aDowfTcwJXt0b3A6Mi4xODc1ZW07bGVmdDotMC4zNzVlbTt3aWR0aDozLjEyNWVtfTg0JXt0b3A6M2VtO2xlZnQ6MS4zMTI1ZW07d2lkdGg6MS4wNjI1ZW19MTAwJXt0b3A6Mi44MTI1ZW07bGVmdDouODEyNWVtO3dpZHRoOjEuNTYyNWVtfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLWxvbmd7MCV7dG9wOjMuMzc1ZW07cmlnaHQ6Mi44NzVlbTt3aWR0aDowfTY1JXt0b3A6My4zNzVlbTtyaWdodDoyLjg3NWVtO3dpZHRoOjB9ODQle3RvcDoyLjE4NzVlbTtyaWdodDowO3dpZHRoOjMuNDM3NWVtfTEwMCV7dG9wOjIuMzc1ZW07cmlnaHQ6LjVlbTt3aWR0aDoyLjkzNzVlbX19QGtleWZyYW1lcyBzd2FsMi1yb3RhdGUtc3VjY2Vzcy1jaXJjdWxhci1saW5lezAle3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX01JXt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9MTIle3RyYW5zZm9ybTpyb3RhdGUoLTQwNWRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKC00MDVkZWcpfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtZXJyb3IteC1tYXJrezAle21hcmdpbi10b3A6MS42MjVlbTt0cmFuc2Zvcm06c2NhbGUoMC40KTtvcGFjaXR5OjB9NTAle21hcmdpbi10b3A6MS42MjVlbTt0cmFuc2Zvcm06c2NhbGUoMC40KTtvcGFjaXR5OjB9ODAle21hcmdpbi10b3A6LTAuMzc1ZW07dHJhbnNmb3JtOnNjYWxlKDEuMTUpfTEwMCV7bWFyZ2luLXRvcDowO3RyYW5zZm9ybTpzY2FsZSgxKTtvcGFjaXR5OjF9fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1lcnJvci1pY29uezAle3RyYW5zZm9ybTpyb3RhdGVYKDEwMGRlZyk7b3BhY2l0eTowfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZVgoMGRlZyk7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIHN3YWwyLXJvdGF0ZS1sb2FkaW5nezAle3RyYW5zZm9ybTpyb3RhdGUoMGRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1xdWVzdGlvbi1tYXJrezAle3RyYW5zZm9ybTpyb3RhdGVZKC0zNjBkZWcpfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZVkoMCl9fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1pLW1hcmt7MCV7dHJhbnNmb3JtOnJvdGF0ZVooNDVkZWcpO29wYWNpdHk6MH0yNSV7dHJhbnNmb3JtOnJvdGF0ZVooLTI1ZGVnKTtvcGFjaXR5Oi40fTUwJXt0cmFuc2Zvcm06cm90YXRlWigxNWRlZyk7b3BhY2l0eTouOH03NSV7dHJhbnNmb3JtOnJvdGF0ZVooLTVkZWcpO29wYWNpdHk6MX0xMDAle3RyYW5zZm9ybTpyb3RhdGVYKDApO29wYWNpdHk6MX19QGtleWZyYW1lcyBzd2FsMi10b2FzdC1zaG93ezAle3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0wLjYyNWVtKSByb3RhdGVaKDJkZWcpfTMzJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVaKC0yZGVnKX02NiV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMC4zMTI1ZW0pIHJvdGF0ZVooMmRlZyl9MTAwJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVaKDBkZWcpfX1Aa2V5ZnJhbWVzIHN3YWwyLXRvYXN0LWhpZGV7MTAwJXt0cmFuc2Zvcm06cm90YXRlWigxZGVnKTtvcGFjaXR5OjB9fUBrZXlmcmFtZXMgc3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwezAle3RvcDouNTYyNWVtO2xlZnQ6LjA2MjVlbTt3aWR0aDowfTU0JXt0b3A6LjEyNWVtO2xlZnQ6LjEyNWVtO3dpZHRoOjB9NzAle3RvcDouNjI1ZW07bGVmdDotMC4yNWVtO3dpZHRoOjEuNjI1ZW19ODQle3RvcDoxLjA2MjVlbTtsZWZ0Oi43NWVtO3dpZHRoOi41ZW19MTAwJXt0b3A6MS4xMjVlbTtsZWZ0Oi4xODc1ZW07d2lkdGg6Ljc1ZW19fUBrZXlmcmFtZXMgc3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZ3swJXt0b3A6MS42MjVlbTtyaWdodDoxLjM3NWVtO3dpZHRoOjB9NjUle3RvcDoxLjI1ZW07cmlnaHQ6LjkzNzVlbTt3aWR0aDowfTg0JXt0b3A6LjkzNzVlbTtyaWdodDowO3dpZHRoOjEuMTI1ZW19MTAwJXt0b3A6LjkzNzVlbTtyaWdodDouMTg3NWVtO3dpZHRoOjEuMzc1ZW19fVwiKTsiXSwibmFtZXMiOlsiX2Fzc2VydENsYXNzQnJhbmQiLCJlIiwidCIsIm4iLCJoYXMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbiIsIl9jbGFzc1ByaXZhdGVGaWVsZEdldDIiLCJzIiwiYSIsImdldCIsIl9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjIiwic2V0IiwiX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MiIsInIiLCJSRVNUT1JFX0ZPQ1VTX1RJTUVPVVQiLCJnbG9iYWxTdGF0ZSIsImZvY3VzUHJldmlvdXNBY3RpdmVFbGVtZW50IiwicHJldmlvdXNBY3RpdmVFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJmb2N1cyIsImRvY3VtZW50IiwiYm9keSIsInJlc3RvcmVBY3RpdmVFbGVtZW50IiwicmV0dXJuRm9jdXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsIngiLCJ3aW5kb3ciLCJzY3JvbGxYIiwieSIsInNjcm9sbFkiLCJyZXN0b3JlRm9jdXNUaW1lb3V0Iiwic2V0VGltZW91dCIsInNjcm9sbFRvIiwic3dhbFByZWZpeCIsImNsYXNzTmFtZXMiLCJzd2FsQ2xhc3NlcyIsInJlZHVjZSIsImFjYyIsImNsYXNzTmFtZSIsImljb25zIiwiaWNvblR5cGVzIiwiaWNvbiIsImNvbnNvbGVQcmVmaXgiLCJjYXBpdGFsaXplRmlyc3RMZXR0ZXIiLCJzdHIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwid2FybiIsIm1lc3NhZ2UiLCJjb25zb2xlIiwiam9pbiIsImVycm9yIiwicHJldmlvdXNXYXJuT25jZU1lc3NhZ2VzIiwid2Fybk9uY2UiLCJpbmNsdWRlcyIsInB1c2giLCJ3YXJuQWJvdXREZXByZWNhdGlvbiIsImRlcHJlY2F0ZWRQYXJhbSIsInVzZUluc3RlYWQiLCJ1bmRlZmluZWQiLCJjYWxsSWZGdW5jdGlvbiIsImFyZyIsImhhc1RvUHJvbWlzZUZuIiwidG9Qcm9taXNlIiwiYXNQcm9taXNlIiwiaXNQcm9taXNlIiwiZ2V0Q29udGFpbmVyIiwicXVlcnlTZWxlY3RvciIsImNvbnRhaW5lciIsImVsZW1lbnRCeVNlbGVjdG9yIiwic2VsZWN0b3JTdHJpbmciLCJlbGVtZW50QnlDbGFzcyIsImdldFBvcHVwIiwicG9wdXAiLCJnZXRJY29uIiwiZ2V0SWNvbkNvbnRlbnQiLCJnZXRUaXRsZSIsInRpdGxlIiwiZ2V0SHRtbENvbnRhaW5lciIsImdldEltYWdlIiwiaW1hZ2UiLCJnZXRQcm9ncmVzc1N0ZXBzIiwiZ2V0VmFsaWRhdGlvbk1lc3NhZ2UiLCJnZXRDb25maXJtQnV0dG9uIiwiYWN0aW9ucyIsImNvbmZpcm0iLCJnZXRDYW5jZWxCdXR0b24iLCJjYW5jZWwiLCJnZXREZW55QnV0dG9uIiwiZGVueSIsImdldElucHV0TGFiZWwiLCJnZXRMb2FkZXIiLCJsb2FkZXIiLCJnZXRBY3Rpb25zIiwiZ2V0Rm9vdGVyIiwiZm9vdGVyIiwiZ2V0VGltZXJQcm9ncmVzc0JhciIsImdldENsb3NlQnV0dG9uIiwiY2xvc2UiLCJmb2N1c2FibGUiLCJnZXRGb2N1c2FibGVFbGVtZW50cyIsImZvY3VzYWJsZUVsZW1lbnRzV2l0aFRhYmluZGV4IiwicXVlcnlTZWxlY3RvckFsbCIsImZvY3VzYWJsZUVsZW1lbnRzV2l0aFRhYmluZGV4U29ydGVkIiwiQXJyYXkiLCJmcm9tIiwic29ydCIsImIiLCJ0YWJpbmRleEEiLCJwYXJzZUludCIsImdldEF0dHJpYnV0ZSIsInRhYmluZGV4QiIsIm90aGVyRm9jdXNhYmxlRWxlbWVudHMiLCJvdGhlckZvY3VzYWJsZUVsZW1lbnRzRmlsdGVyZWQiLCJmaWx0ZXIiLCJlbCIsIlNldCIsImNvbmNhdCIsImlzVmlzaWJsZSQxIiwiaXNNb2RhbCIsImhhc0NsYXNzIiwic2hvd24iLCJpc1RvYXN0IiwidG9hc3QiLCJpc0xvYWRpbmciLCJoYXNBdHRyaWJ1dGUiLCJzZXRJbm5lckh0bWwiLCJlbGVtIiwiaHRtbCIsInRleHRDb250ZW50IiwicGFyc2VyIiwiRE9NUGFyc2VyIiwicGFyc2VkIiwicGFyc2VGcm9tU3RyaW5nIiwiaGVhZCIsImNoaWxkTm9kZXMiLCJmb3JFYWNoIiwiY2hpbGQiLCJhcHBlbmRDaGlsZCIsIkhUTUxWaWRlb0VsZW1lbnQiLCJIVE1MQXVkaW9FbGVtZW50IiwiY2xvbmVOb2RlIiwiY2xhc3NMaXN0Iiwic3BsaXQiLCJpIiwiY29udGFpbnMiLCJyZW1vdmVDdXN0b21DbGFzc2VzIiwicGFyYW1zIiwiT2JqZWN0IiwidmFsdWVzIiwic2hvd0NsYXNzIiwicmVtb3ZlIiwiYXBwbHlDdXN0b21DbGFzcyIsImN1c3RvbUNsYXNzIiwiYWRkQ2xhc3MiLCJnZXRJbnB1dCQxIiwiaW5wdXRDbGFzcyIsImNoZWNrYm94IiwicmFkaW8iLCJyYW5nZSIsImlucHV0IiwiZm9jdXNJbnB1dCIsInR5cGUiLCJ2YWwiLCJ2YWx1ZSIsInRvZ2dsZUNsYXNzIiwidGFyZ2V0IiwiY29uZGl0aW9uIiwiQm9vbGVhbiIsImlzQXJyYXkiLCJhZGQiLCJyZW1vdmVDbGFzcyIsImdldERpcmVjdENoaWxkQnlDbGFzcyIsImNoaWxkcmVuIiwiYXBwbHlOdW1lcmljYWxTdHlsZSIsInByb3BlcnR5Iiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsInJlbW92ZVByb3BlcnR5Iiwic2hvdyIsImRpc3BsYXkiLCJoaWRlIiwic2hvd1doZW5Jbm5lckh0bWxQcmVzZW50IiwiTXV0YXRpb25PYnNlcnZlciIsInRvZ2dsZSIsImlubmVySFRNTCIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwic2V0U3R5bGUiLCJwYXJlbnQiLCJzZWxlY3RvciIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZ2V0Q2xpZW50UmVjdHMiLCJhbGxCdXR0b25zQXJlSGlkZGVuIiwiaXNTY3JvbGxhYmxlIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiaGFzQ3NzQW5pbWF0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImFuaW1EdXJhdGlvbiIsInBhcnNlRmxvYXQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwidHJhbnNEdXJhdGlvbiIsImFuaW1hdGVUaW1lclByb2dyZXNzQmFyIiwidGltZXIiLCJyZXNldCIsInRpbWVyUHJvZ3Jlc3NCYXIiLCJ0cmFuc2l0aW9uIiwid2lkdGgiLCJzdG9wVGltZXJQcm9ncmVzc0JhciIsInRpbWVyUHJvZ3Jlc3NCYXJXaWR0aCIsInRpbWVyUHJvZ3Jlc3NCYXJGdWxsV2lkdGgiLCJ0aW1lclByb2dyZXNzQmFyUGVyY2VudCIsImlzTm9kZUVudiIsInN3ZWV0SFRNTCIsImZpbGUiLCJzZWxlY3QiLCJsYWJlbCIsInRleHRhcmVhIiwicmVwbGFjZSIsInJlc2V0T2xkQ29udGFpbmVyIiwib2xkQ29udGFpbmVyIiwiZG9jdW1lbnRFbGVtZW50IiwicmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxIiwiY3VycmVudEluc3RhbmNlIiwicmVzZXRWYWxpZGF0aW9uTWVzc2FnZSIsImFkZElucHV0Q2hhbmdlTGlzdGVuZXJzIiwicmFuZ2VPdXRwdXQiLCJvbmlucHV0Iiwib25jaGFuZ2UiLCJnZXRUYXJnZXQiLCJzZXR1cEFjY2Vzc2liaWxpdHkiLCJzZXRBdHRyaWJ1dGUiLCJzZXR1cFJUTCIsInRhcmdldEVsZW1lbnQiLCJkaXJlY3Rpb24iLCJydGwiLCJpbml0Iiwib2xkQ29udGFpbmVyRXhpc3RlZCIsImNyZWF0ZUVsZW1lbnQiLCJkYXRhc2V0IiwidGhlbWUiLCJwYXJzZUh0bWxUb0NvbnRhaW5lciIsInBhcmFtIiwiaGFuZGxlT2JqZWN0IiwianF1ZXJ5IiwiaGFuZGxlSnF1ZXJ5RWxlbSIsInRvU3RyaW5nIiwicmVuZGVyQWN0aW9ucyIsImluc3RhbmNlIiwic2hvd0NvbmZpcm1CdXR0b24iLCJzaG93RGVueUJ1dHRvbiIsInNob3dDYW5jZWxCdXR0b24iLCJyZW5kZXJCdXR0b25zIiwibG9hZGVySHRtbCIsImNvbmZpcm1CdXR0b24iLCJkZW55QnV0dG9uIiwiY2FuY2VsQnV0dG9uIiwicmVuZGVyQnV0dG9uIiwiaGFuZGxlQnV0dG9uc1N0eWxpbmciLCJyZXZlcnNlQnV0dG9ucyIsImluc2VydEJlZm9yZSIsImJ1dHRvbnNTdHlsaW5nIiwic3R5bGVkIiwiY29uZmlybUJ1dHRvbkNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiZGVueUJ1dHRvbkNvbG9yIiwiY2FuY2VsQnV0dG9uQ29sb3IiLCJidXR0b24iLCJidXR0b25UeXBlIiwiYnV0dG9uTmFtZSIsInJlbmRlckNsb3NlQnV0dG9uIiwiY2xvc2VCdXR0b24iLCJjbG9zZUJ1dHRvbkh0bWwiLCJzaG93Q2xvc2VCdXR0b24iLCJjbG9zZUJ1dHRvbkFyaWFMYWJlbCIsInJlbmRlckNvbnRhaW5lciIsImhhbmRsZUJhY2tkcm9wUGFyYW0iLCJiYWNrZHJvcCIsImhhbmRsZVBvc2l0aW9uUGFyYW0iLCJwb3NpdGlvbiIsImhhbmRsZUdyb3dQYXJhbSIsImdyb3ciLCJiYWNrZ3JvdW5kIiwiY2VudGVyIiwicHJpdmF0ZVByb3BzIiwiaW5uZXJQYXJhbXMiLCJXZWFrTWFwIiwiZG9tQ2FjaGUiLCJpbnB1dENsYXNzZXMiLCJyZW5kZXJJbnB1dCIsInJlcmVuZGVyIiwiaW5wdXRDb250YWluZXIiLCJzZXRBdHRyaWJ1dGVzIiwiaW5wdXRBdHRyaWJ1dGVzIiwic2hvd0lucHV0Iiwic2V0Q3VzdG9tQ2xhc3MiLCJyZW5kZXJJbnB1dFR5cGUiLCJrZXlzIiwiZ2V0SW5wdXRDb250YWluZXIiLCJpbnB1dEF1dG9Gb2N1cyIsInJlbW92ZUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiYXR0ck5hbWUiLCJuYW1lIiwicmVtb3ZlQXR0cmlidXRlIiwiYXR0ciIsInNldElucHV0UGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlciIsImlucHV0UGxhY2Vob2xkZXIiLCJzZXRJbnB1dExhYmVsIiwicHJlcGVuZFRvIiwiaW5wdXRMYWJlbCIsImxhYmVsQ2xhc3MiLCJpZCIsImlubmVyVGV4dCIsImluc2VydEFkamFjZW50RWxlbWVudCIsImlucHV0VHlwZSIsImNoZWNrQW5kU2V0SW5wdXRWYWx1ZSIsImlucHV0VmFsdWUiLCJ0ZXh0IiwiZW1haWwiLCJwYXNzd29yZCIsIm51bWJlciIsInRlbCIsInVybCIsInNlYXJjaCIsImRhdGUiLCJ0aW1lIiwid2VlayIsIm1vbnRoIiwicmFuZ2VJbnB1dCIsImRpc2FibGVkIiwic2VsZWN0ZWQiLCJjaGVja2JveENvbnRhaW5lciIsImNoZWNrZWQiLCJnZXRNYXJnaW4iLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJpbml0aWFsUG9wdXBXaWR0aCIsInRleHRhcmVhUmVzaXplSGFuZGxlciIsInRleHRhcmVhV2lkdGgiLCJhdHRyaWJ1dGVGaWx0ZXIiLCJyZW5kZXJDb250ZW50IiwiaHRtbENvbnRhaW5lciIsInJlbmRlckZvb3RlciIsInJlbmRlckljb24iLCJzZXRDb250ZW50IiwiYXBwbHlTdHlsZXMiLCJpY29uSHRtbCIsImluZGV4T2YiLCJjb2xvclNjaGVtZVF1ZXJ5TGlzdCIsIm1hdGNoTWVkaWEiLCJhZGRFdmVudExpc3RlbmVyIiwiYWRqdXN0U3VjY2Vzc0ljb25CYWNrZ3JvdW5kQ29sb3IiLCJpY29uVHlwZSIsImljb25DbGFzc05hbWUiLCJlbnRyaWVzIiwic2V0Q29sb3IiLCJwb3B1cEJhY2tncm91bmRDb2xvciIsInN1Y2Nlc3NJY29uUGFydHMiLCJzdWNjZXNzSWNvbkh0bWwiLCJlcnJvckljb25IdG1sIiwib2xkQ29udGVudCIsIm5ld0NvbnRlbnQiLCJpY29uQ29udGVudCIsImRlZmF1bHRJY29uSHRtbCIsInF1ZXN0aW9uIiwid2FybmluZyIsImluZm8iLCJ0cmltIiwiaWNvbkNvbG9yIiwiY29sb3IiLCJib3JkZXJDb2xvciIsInNlbCIsImNvbnRlbnQiLCJyZW5kZXJJbWFnZSIsImltYWdlVXJsIiwiaW1hZ2VBbHQiLCJpbWFnZVdpZHRoIiwiaW1hZ2VIZWlnaHQiLCJkcmFnZ2luZyIsIm1vdXNlZG93blgiLCJtb3VzZWRvd25ZIiwiaW5pdGlhbFgiLCJpbml0aWFsWSIsImFkZERyYWdnYWJsZUxpc3RlbmVycyIsImRvd24iLCJtb3ZlIiwidXAiLCJyZW1vdmVEcmFnZ2FibGVMaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJjbGllbnRYWSIsImdldENsaWVudFhZIiwiY2xpZW50WCIsImNsaWVudFkiLCJpbnNldElubGluZVN0YXJ0IiwiaW5zZXRCbG9ja1N0YXJ0Iiwic3RhcnRzV2l0aCIsInRvdWNoZXMiLCJyZW5kZXJQb3B1cCIsInBhZGRpbmciLCJhZGRDbGFzc2VzJDEiLCJkcmFnZ2FibGUiLCJtb2RhbCIsInJlbmRlclByb2dyZXNzU3RlcHMiLCJwcm9ncmVzc1N0ZXBzQ29udGFpbmVyIiwicHJvZ3Jlc3NTdGVwcyIsImN1cnJlbnRQcm9ncmVzc1N0ZXAiLCJzdGVwIiwiaW5kZXgiLCJzdGVwRWwiLCJjcmVhdGVTdGVwRWxlbWVudCIsImxpbmVFbCIsImNyZWF0ZUxpbmVFbGVtZW50IiwicHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlIiwicmVuZGVyVGl0bGUiLCJ0aXRsZVRleHQiLCJyZW5kZXIiLCJkaWRSZW5kZXIiLCJldmVudEVtaXR0ZXIiLCJlbWl0IiwiaXNWaXNpYmxlIiwiY2xpY2tDb25maXJtIiwiX2RvbSRnZXRDb25maXJtQnV0dG9uIiwiY2xpY2siLCJjbGlja0RlbnkiLCJfZG9tJGdldERlbnlCdXR0b24iLCJjbGlja0NhbmNlbCIsIl9kb20kZ2V0Q2FuY2VsQnV0dG9uIiwiRGlzbWlzc1JlYXNvbiIsImZyZWV6ZSIsImVzYyIsInJlbW92ZUtleWRvd25IYW5kbGVyIiwia2V5ZG93blRhcmdldCIsImtleWRvd25IYW5kbGVyQWRkZWQiLCJrZXlkb3duSGFuZGxlciIsImNhcHR1cmUiLCJrZXlkb3duTGlzdGVuZXJDYXB0dXJlIiwiYWRkS2V5ZG93bkhhbmRsZXIiLCJkaXNtaXNzV2l0aCIsInNldEZvY3VzIiwiaW5jcmVtZW50IiwiX2RvbSRnZXRQb3B1cCIsImZvY3VzYWJsZUVsZW1lbnRzIiwiYXJyb3dLZXlzTmV4dEJ1dHRvbiIsImFycm93S2V5c1ByZXZpb3VzQnV0dG9uIiwiaXNDb21wb3NpbmciLCJrZXlDb2RlIiwic3RvcEtleWRvd25Qcm9wYWdhdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsImtleSIsImhhbmRsZUVudGVyIiwiaGFuZGxlVGFiIiwiaGFuZGxlQXJyb3dzIiwiaGFuZGxlRXNjIiwiYWxsb3dFbnRlcktleSIsIm91dGVySFRNTCIsInByZXZlbnREZWZhdWx0IiwiYnRuSW5kZXgiLCJzaGlmdEtleSIsImJ1dHRvbnMiLCJhY3RpdmVFbGVtZW50Iiwic2libGluZyIsImJ1dHRvblRvRm9jdXMiLCJIVE1MQnV0dG9uRWxlbWVudCIsImFsbG93RXNjYXBlS2V5IiwicHJpdmF0ZU1ldGhvZHMiLCJzd2FsUHJvbWlzZVJlc29sdmUiLCJzd2FsUHJvbWlzZVJlamVjdCIsInNldEFyaWFIaWRkZW4iLCJib2R5Q2hpbGRyZW4iLCJ1bnNldEFyaWFIaWRkZW4iLCJpc1NhZmFyaU9ySU9TIiwiR2VzdHVyZUV2ZW50IiwiaU9TZml4IiwiaW9zZml4Iiwib2Zmc2V0Iiwic2Nyb2xsVG9wIiwidG9wIiwibG9ja0JvZHlTY3JvbGwiLCJwcmV2ZW50VG91Y2hNb3ZlIiwib250b3VjaHN0YXJ0Iiwic2hvdWxkUHJldmVudFRvdWNoTW92ZSIsIm9udG91Y2htb3ZlIiwiaXNTdHlsdXMiLCJpc1pvb20iLCJ0YWdOYW1lIiwidG91Y2hUeXBlIiwidW5kb0lPU2ZpeCIsIm1lYXN1cmVTY3JvbGxiYXIiLCJzY3JvbGxEaXYiLCJzY3JvbGxiYXJXaWR0aCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFdpZHRoIiwicmVtb3ZlQ2hpbGQiLCJwcmV2aW91c0JvZHlQYWRkaW5nIiwicmVwbGFjZVNjcm9sbGJhcldpdGhQYWRkaW5nIiwiaW5pdGlhbEJvZHlPdmVyZmxvdyIsImlubmVySGVpZ2h0IiwicGFkZGluZ1JpZ2h0IiwidW5kb1JlcGxhY2VTY3JvbGxiYXJXaXRoUGFkZGluZyIsInJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZSIsImRpZENsb3NlIiwidHJpZ2dlckRpZENsb3NlQW5kRGlzcG9zZSIsInRoZW4iLCJyZW1vdmVCb2R5Q2xhc3NlcyIsInJlc29sdmVWYWx1ZSIsInByZXBhcmVSZXNvbHZlVmFsdWUiLCJ0cmlnZ2VyQ2xvc2VQb3B1cCIsImlzQXdhaXRpbmdQcm9taXNlIiwiaXNEaXNtaXNzZWQiLCJoYW5kbGVBd2FpdGluZ1Byb21pc2UiLCJoaWRlQ2xhc3MiLCJoYW5kbGVQb3B1cEFuaW1hdGlvbiIsInJlamVjdFByb21pc2UiLCJfZGVzdHJveSIsImlzQ29uZmlybWVkIiwiaXNEZW5pZWQiLCJhc3NpZ24iLCJfZ2xvYmFsU3RhdGUkZXZlbnRFbWkiLCJhbmltYXRpb25Jc1N1cHBvcnRlZCIsIndpbGxDbG9zZSIsImFuaW1hdGVQb3B1cCIsInN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjayIsImJpbmQiLCJzd2FsQ2xvc2VBbmltYXRpb25GaW5pc2hlZCIsIl9nbG9iYWxTdGF0ZSRzd2FsQ2xvcyIsImNhbGwiLCJfZ2xvYmFsU3RhdGUkZXZlbnRFbWkyIiwic2hvd0xvYWRpbmciLCJidXR0b25Ub1JlcGxhY2UiLCJTd2FsIiwicmVwbGFjZUJ1dHRvbiIsImxvYWRpbmciLCJoYW5kbGVJbnB1dE9wdGlvbnNBbmRWYWx1ZSIsImhhbmRsZUlucHV0T3B0aW9ucyIsInNvbWUiLCJoYW5kbGVJbnB1dFZhbHVlIiwiZ2V0SW5wdXRWYWx1ZSIsImdldElucHV0IiwiZ2V0Q2hlY2tib3hWYWx1ZSIsImdldFJhZGlvVmFsdWUiLCJnZXRGaWxlVmFsdWUiLCJpbnB1dEF1dG9UcmltIiwiZmlsZXMiLCJwcm9jZXNzSW5wdXRPcHRpb25zIiwiaW5wdXRPcHRpb25zIiwicG9wdWxhdGVTZWxlY3RPcHRpb25zIiwiZm9ybWF0SW5wdXRPcHRpb25zIiwicG9wdWxhdGVSYWRpb09wdGlvbnMiLCJoaWRlTG9hZGluZyIsImNhdGNoIiwiZXJyIiwicmVuZGVyT3B0aW9uIiwib3B0aW9uTGFiZWwiLCJvcHRpb25WYWx1ZSIsIm9wdGlvbiIsImlzU2VsZWN0ZWQiLCJpbnB1dE9wdGlvbiIsIm9wdGdyb3VwIiwibyIsInJhZGlvVmFsdWUiLCJyYWRpb0xhYmVsIiwicmFkaW9JbnB1dCIsInJhZGlvTGFiZWxFbGVtZW50IiwicmFkaW9zIiwicmVzdWx0IiwiTWFwIiwidmFsdWVGb3JtYXR0ZWQiLCJoYW5kbGVDb25maXJtQnV0dG9uQ2xpY2siLCJkaXNhYmxlQnV0dG9ucyIsImhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQiLCJoYW5kbGVEZW55QnV0dG9uQ2xpY2siLCJyZXR1cm5JbnB1dFZhbHVlT25EZW55IiwiaGFuZGxlQ2FuY2VsQnV0dG9uQ2xpY2siLCJpbnB1dFZhbGlkYXRvciIsImhhbmRsZUlucHV0VmFsaWRhdG9yIiwiY2hlY2tWYWxpZGl0eSIsImVuYWJsZUJ1dHRvbnMiLCJzaG93VmFsaWRhdGlvbk1lc3NhZ2UiLCJ2YWxpZGF0aW9uTWVzc2FnZSIsImRpc2FibGVJbnB1dCIsInZhbGlkYXRpb25Qcm9taXNlIiwiZW5hYmxlSW5wdXQiLCJzaG93TG9hZGVyT25EZW55IiwicHJlRGVueSIsInByZURlbnlQcm9taXNlIiwicHJlRGVueVZhbHVlIiwicmVqZWN0V2l0aCIsInN1Y2NlZWRXaXRoIiwic2hvd0xvYWRlck9uQ29uZmlybSIsInByZUNvbmZpcm0iLCJwcmVDb25maXJtUHJvbWlzZSIsInByZUNvbmZpcm1WYWx1ZSIsInNob3dSZWxhdGVkQnV0dG9uIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInNldEJ1dHRvbnNEaXNhYmxlZCIsInNldElucHV0RGlzYWJsZWQiLCJpbnB1dGVycm9yIiwiZGVmYXVsdFBhcmFtcyIsInRlbXBsYXRlIiwiYW5pbWF0aW9uIiwiaGVpZ2h0QXV0byIsImFsbG93T3V0c2lkZUNsaWNrIiwiY29uZmlybUJ1dHRvblRleHQiLCJjb25maXJtQnV0dG9uQXJpYUxhYmVsIiwiZGVueUJ1dHRvblRleHQiLCJkZW55QnV0dG9uQXJpYUxhYmVsIiwiY2FuY2VsQnV0dG9uVGV4dCIsImNhbmNlbEJ1dHRvbkFyaWFMYWJlbCIsImZvY3VzQ29uZmlybSIsImZvY3VzRGVueSIsImZvY3VzQ2FuY2VsIiwid2lsbE9wZW4iLCJkaWRPcGVuIiwiZGlkRGVzdHJveSIsInNjcm9sbGJhclBhZGRpbmciLCJ1cGRhdGFibGVQYXJhbXMiLCJkZXByZWNhdGVkUGFyYW1zIiwidG9hc3RJbmNvbXBhdGlibGVQYXJhbXMiLCJpc1ZhbGlkUGFyYW1ldGVyIiwicGFyYW1OYW1lIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJpc1VwZGF0YWJsZVBhcmFtZXRlciIsImlzRGVwcmVjYXRlZFBhcmFtZXRlciIsImNoZWNrSWZQYXJhbUlzVmFsaWQiLCJjaGVja0lmVG9hc3RQYXJhbUlzVmFsaWQiLCJjaGVja0lmUGFyYW1Jc0RlcHJlY2F0ZWQiLCJpc0RlcHJlY2F0ZWQiLCJzaG93V2FybmluZ3NGb3JQYXJhbXMiLCJ1cGRhdGUiLCJ2YWxpZFVwZGF0YWJsZVBhcmFtcyIsImZpbHRlclZhbGlkUGFyYW1zIiwidXBkYXRlZFBhcmFtcyIsImRlZmluZVByb3BlcnRpZXMiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJkaXNwb3NlV2Vha01hcHMiLCJkaXNwb3NlU3dhbCIsInVuc2V0V2Vha01hcHMiLCJkaXNhYmxlTG9hZGluZyIsImNsb3NlUG9wdXAiLCJjbG9zZU1vZGFsIiwiY2xvc2VUb2FzdCIsIm9iaiIsImRlbGV0ZSIsImluc3RhbmNlTWV0aG9kcyIsIl9fcHJvdG9fXyIsImhhbmRsZVBvcHVwQ2xpY2siLCJoYW5kbGVUb2FzdENsaWNrIiwiaGFuZGxlTW9kYWxNb3VzZWRvd24iLCJoYW5kbGVDb250YWluZXJNb3VzZWRvd24iLCJoYW5kbGVNb2RhbENsaWNrIiwib25jbGljayIsImlzQW55QnV0dG9uU2hvd24iLCJpZ25vcmVPdXRzaWRlQ2xpY2siLCJvbm1vdXNlZG93biIsIm9ubW91c2V1cCIsImlzSnF1ZXJ5RWxlbWVudCIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJhcmdzVG9QYXJhbXMiLCJhcmdzIiwiZmlyZSIsIl9sZW4iLCJfa2V5IiwibWl4aW4iLCJtaXhpblBhcmFtcyIsIk1peGluU3dhbCIsIl9tYWluIiwicHJpb3JpdHlNaXhpblBhcmFtcyIsImdldFRpbWVyTGVmdCIsInRpbWVvdXQiLCJzdG9wVGltZXIiLCJzdG9wIiwicmVzdW1lVGltZXIiLCJyZW1haW5pbmciLCJzdGFydCIsInRvZ2dsZVRpbWVyIiwicnVubmluZyIsImluY3JlYXNlVGltZXIiLCJtcyIsImluY3JlYXNlIiwiaXNUaW1lclJ1bm5pbmciLCJpc1J1bm5pbmciLCJib2R5Q2xpY2tMaXN0ZW5lckFkZGVkIiwiY2xpY2tIYW5kbGVycyIsImJpbmRDbGlja0hhbmRsZXIiLCJib2R5Q2xpY2tMaXN0ZW5lciIsInBhcmVudE5vZGUiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsImV2ZW50cyIsIl9nZXRIYW5kbGVyc0J5RXZlbnROYW1lIiwiZXZlbnROYW1lIiwib24iLCJldmVudEhhbmRsZXIiLCJjdXJyZW50SGFuZGxlcnMiLCJvbmNlIiwiX3RoaXMiLCJvbmNlRm4iLCJyZW1vdmVMaXN0ZW5lciIsImFwcGx5IiwiX2xlbjIiLCJfa2V5MiIsInNwbGljZSIsInJlbW92ZUFsbExpc3RlbmVycyIsIm9mZiIsInN0YXRpY01ldGhvZHMiLCJlbmFibGVMb2FkaW5nIiwiVGltZXIiLCJjYWxsYmFjayIsImRlbGF5Iiwic3RhcnRlZCIsIkRhdGUiLCJjbGVhclRpbWVvdXQiLCJnZXRUaW1lIiwic3dhbFN0cmluZ1BhcmFtcyIsImdldFRlbXBsYXRlUGFyYW1zIiwidGVtcGxhdGVDb250ZW50Iiwic2hvd1dhcm5pbmdzRm9yRWxlbWVudHMiLCJnZXRTd2FsUGFyYW1zIiwiZ2V0U3dhbEZ1bmN0aW9uUGFyYW1zIiwiZ2V0U3dhbEJ1dHRvbnMiLCJnZXRTd2FsSW1hZ2UiLCJnZXRTd2FsSWNvbiIsImdldFN3YWxJbnB1dCIsImdldFN3YWxTdHJpbmdQYXJhbXMiLCJzd2FsUGFyYW1zIiwic2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyIsIkpTT04iLCJwYXJzZSIsInN3YWxGdW5jdGlvbnMiLCJGdW5jdGlvbiIsInN3YWxCdXR0b25zIiwib3B0aW9uTmFtZSIsInBhcmFtTmFtZXMiLCJ0YWciLCJhbGxvd2VkRWxlbWVudHMiLCJ0b0xvd2VyQ2FzZSIsImFsbG93ZWRBdHRyaWJ1dGVzIiwiYXR0cmlidXRlIiwiU0hPV19DTEFTU19USU1FT1VUIiwib3BlblBvcHVwIiwiYm9keVN0eWxlcyIsIm92ZXJmbG93WSIsImFkZENsYXNzZXMiLCJzZXRTY3JvbGxpbmdWaXNpYmlsaXR5IiwiZml4U2Nyb2xsQ29udGFpbmVyIiwic3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZCIsImRlZmF1bHRJbnB1dFZhbGlkYXRvcnMiLCJzdHJpbmciLCJ0ZXN0Iiwic2V0RGVmYXVsdElucHV0VmFsaWRhdG9ycyIsInZhbGlkYXRlQ3VzdG9tVGFyZ2V0RWxlbWVudCIsInNldFBhcmFtZXRlcnMiLCJfcHJvbWlzZSIsIlN3ZWV0QWxlcnQiLCJvdXRlclBhcmFtcyIsInVzZXJQYXJhbXMiLCJwcmVwYXJlUGFyYW1zIiwicG9wdWxhdGVEb21DYWNoZSIsInN3YWxQcm9taXNlIiwib25GdWxmaWxsZWQiLCJmaW5hbGx5Iiwib25GaW5hbGx5IiwicmVqZWN0IiwiZGlzbWlzcyIsInNldHVwVGltZXIiLCJpbml0Rm9jdXMiLCJ0ZW1wbGF0ZVBhcmFtcyIsImJsdXJBY3RpdmVFbGVtZW50IiwiZm9jdXNBdXRvZm9jdXMiLCJmb2N1c0J1dHRvbiIsImF1dG9mb2N1c0VsZW1lbnRzIiwiYXV0b2ZvY3VzRWxlbWVudCIsImJsdXIiLCJuYXZpZ2F0b3IiLCJsYW5ndWFnZSIsImxvY2F0aW9uIiwiaG9zdCIsIm1hdGNoIiwibm93IiwiaW5pdGlhdGlvbkRhdGUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsInBvaW50ZXJFdmVudHMiLCJ1a3JhaW5pYW5BbnRoZW0iLCJzcmMiLCJsb29wIiwicGxheSIsInZlcnNpb24iLCJkZWZhdWx0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sweetalert2/dist/sweetalert2.esm.all.js\n");

/***/ })

};
;